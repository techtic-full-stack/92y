# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: query_root
    mutation: mutation_root
    subscription: subscription_root
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached("refresh the cache entry" refresh: Boolean! = false, "measured in seconds" ttl: Int! = 60) on QUERY

type EnrollOutput {
    id: uuid!
}

type PaymentMethod {
    card: PaymentMethodCard
    details: PaymentMethodDetails
    id: String!
    saved: Boolean
}

type PaymentMethodAddress {
    city: String
    country: String
    line1: String
    line2: String
    postalCode: String
    state: String
}

type PaymentMethodCard {
    cardType: String
    expMonth: Int
    expYear: Int
    last4: String
}

type PaymentMethodDetails {
    address: PaymentMethodAddress
    name: String!
}

type RetryPaymentOutput {
    ok: Boolean!
}

type SignedUpload {
    id: uuid!
    signedUploadUrl: String!
}

type SignupOutput {
    id: uuid!
    "An object relationship"
    user: users!
}

type SubscriptionOverviewOutput {
    createdAt: String
    expiresOn: String
    invoiceAmount: Int!
    pastDueAmount: Int!
    paymentMethods: [PaymentMethod]!
    proratedAmount: Int
}

type SubscriptionPlans {
    details: [String!]!
    id: String
    interval: plan_interval_types
    isSubscription: Boolean!
    name: String!
    price: Float!
    title: String
}

type ValidateCouponResponse {
    amount: Float!
    code: String!
    discount: String!
}

"columns and relationships of \"class_tags\""
type class_tags {
    description: String!
    value: String!
}

"aggregated selection of \"class_tags\""
type class_tags_aggregate {
    aggregate: class_tags_aggregate_fields
    nodes: [class_tags!]!
}

"aggregate fields of \"class_tags\""
type class_tags_aggregate_fields {
    count(columns: [class_tags_select_column!], distinct: Boolean): Int!
    max: class_tags_max_fields
    min: class_tags_min_fields
}

"aggregate max on columns"
type class_tags_max_fields {
    description: String
    value: String
}

"aggregate min on columns"
type class_tags_min_fields {
    description: String
    value: String
}

"response of any mutation on the table \"class_tags\""
type class_tags_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [class_tags!]!
}

"columns and relationships of \"collection_courses\""
type collection_courses {
    "An object relationship"
    collection: collections!
    collectionId: uuid!
    "An object relationship"
    course: courses!
    courseId: uuid!
    id: uuid!
    order: Int
}

"aggregated selection of \"collection_courses\""
type collection_courses_aggregate {
    aggregate: collection_courses_aggregate_fields
    nodes: [collection_courses!]!
}

"aggregate fields of \"collection_courses\""
type collection_courses_aggregate_fields {
    avg: collection_courses_avg_fields
    count(columns: [collection_courses_select_column!], distinct: Boolean): Int!
    max: collection_courses_max_fields
    min: collection_courses_min_fields
    stddev: collection_courses_stddev_fields
    stddev_pop: collection_courses_stddev_pop_fields
    stddev_samp: collection_courses_stddev_samp_fields
    sum: collection_courses_sum_fields
    var_pop: collection_courses_var_pop_fields
    var_samp: collection_courses_var_samp_fields
    variance: collection_courses_variance_fields
}

"aggregate avg on columns"
type collection_courses_avg_fields {
    order: Float
}

"aggregate max on columns"
type collection_courses_max_fields {
    collectionId: uuid
    courseId: uuid
    id: uuid
    order: Int
}

"aggregate min on columns"
type collection_courses_min_fields {
    collectionId: uuid
    courseId: uuid
    id: uuid
    order: Int
}

"response of any mutation on the table \"collection_courses\""
type collection_courses_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [collection_courses!]!
}

"aggregate stddev on columns"
type collection_courses_stddev_fields {
    order: Float
}

"aggregate stddev_pop on columns"
type collection_courses_stddev_pop_fields {
    order: Float
}

"aggregate stddev_samp on columns"
type collection_courses_stddev_samp_fields {
    order: Float
}

"aggregate sum on columns"
type collection_courses_sum_fields {
    order: Int
}

"aggregate var_pop on columns"
type collection_courses_var_pop_fields {
    order: Float
}

"aggregate var_samp on columns"
type collection_courses_var_samp_fields {
    order: Float
}

"aggregate variance on columns"
type collection_courses_variance_fields {
    order: Float
}

"columns and relationships of \"collections\""
type collections {
    "An array relationship"
    collection_courses(
        "distinct select on columns"
        distinct_on: [collection_courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [collection_courses_order_by!]
        "filter the rows returned"
        where: collection_courses_bool_exp
    ): [collection_courses!]!
    "An aggregate relationship"
    collection_courses_aggregate(
        "distinct select on columns"
        distinct_on: [collection_courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [collection_courses_order_by!]
        "filter the rows returned"
        where: collection_courses_bool_exp
    ): collection_courses_aggregate!
    headline: String!
    id: uuid!
    "An object relationship"
    image: uploads
    imageId: uuid
    name: String!
    slug: String!
    "An object relationship"
    topic: topics
    topicId: uuid
}

"aggregated selection of \"collections\""
type collections_aggregate {
    aggregate: collections_aggregate_fields
    nodes: [collections!]!
}

"aggregate fields of \"collections\""
type collections_aggregate_fields {
    count(columns: [collections_select_column!], distinct: Boolean): Int!
    max: collections_max_fields
    min: collections_min_fields
}

"aggregate max on columns"
type collections_max_fields {
    headline: String
    id: uuid
    imageId: uuid
    name: String
    slug: String
    topicId: uuid
}

"aggregate min on columns"
type collections_min_fields {
    headline: String
    id: uuid
    imageId: uuid
    name: String
    slug: String
    topicId: uuid
}

"response of any mutation on the table \"collections\""
type collections_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [collections!]!
}

"columns and relationships of \"config_types\""
type config_types {
    description: String!
    value: String!
}

"aggregated selection of \"config_types\""
type config_types_aggregate {
    aggregate: config_types_aggregate_fields
    nodes: [config_types!]!
}

"aggregate fields of \"config_types\""
type config_types_aggregate_fields {
    count(columns: [config_types_select_column!], distinct: Boolean): Int!
    max: config_types_max_fields
    min: config_types_min_fields
}

"aggregate max on columns"
type config_types_max_fields {
    description: String
    value: String
}

"aggregate min on columns"
type config_types_min_fields {
    description: String
    value: String
}

"response of any mutation on the table \"config_types\""
type config_types_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [config_types!]!
}

"columns and relationships of \"config_values\""
type config_values {
    configType: config_types_enum!
    "An object relationship"
    descriptor: config_types!
    format: String!
    options("JSON select path" path: String): json
    "A computed field, executes function \"get_config_relationship_entities\""
    relationships("JSON select path" path: String): json
    value("JSON select path" path: String): json
}

"aggregated selection of \"config_values\""
type config_values_aggregate {
    aggregate: config_values_aggregate_fields
    nodes: [config_values!]!
}

"aggregate fields of \"config_values\""
type config_values_aggregate_fields {
    count(columns: [config_values_select_column!], distinct: Boolean): Int!
    max: config_values_max_fields
    min: config_values_min_fields
}

"aggregate max on columns"
type config_values_max_fields {
    format: String
}

"aggregate min on columns"
type config_values_min_fields {
    format: String
}

"response of any mutation on the table \"config_values\""
type config_values_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [config_values!]!
}

"columns and relationships of \"coupons\""
type coupons {
    amount: Int
    discount: String
    id: String!
    name: String!
    stripeObject("JSON select path" path: String): json!
}

"aggregated selection of \"coupons\""
type coupons_aggregate {
    aggregate: coupons_aggregate_fields
    nodes: [coupons!]!
}

"aggregate fields of \"coupons\""
type coupons_aggregate_fields {
    avg: coupons_avg_fields
    count(columns: [coupons_select_column!], distinct: Boolean): Int!
    max: coupons_max_fields
    min: coupons_min_fields
    stddev: coupons_stddev_fields
    stddev_pop: coupons_stddev_pop_fields
    stddev_samp: coupons_stddev_samp_fields
    sum: coupons_sum_fields
    var_pop: coupons_var_pop_fields
    var_samp: coupons_var_samp_fields
    variance: coupons_variance_fields
}

"aggregate avg on columns"
type coupons_avg_fields {
    amount: Float
}

"aggregate max on columns"
type coupons_max_fields {
    amount: Int
    discount: String
    id: String
    name: String
}

"aggregate min on columns"
type coupons_min_fields {
    amount: Int
    discount: String
    id: String
    name: String
}

"response of any mutation on the table \"coupons\""
type coupons_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [coupons!]!
}

"aggregate stddev on columns"
type coupons_stddev_fields {
    amount: Float
}

"aggregate stddev_pop on columns"
type coupons_stddev_pop_fields {
    amount: Float
}

"aggregate stddev_samp on columns"
type coupons_stddev_samp_fields {
    amount: Float
}

"aggregate sum on columns"
type coupons_sum_fields {
    amount: Int
}

"aggregate var_pop on columns"
type coupons_var_pop_fields {
    amount: Float
}

"aggregate var_samp on columns"
type coupons_var_samp_fields {
    amount: Float
}

"aggregate variance on columns"
type coupons_variance_fields {
    amount: Float
}

"columns and relationships of \"course_resources\""
type course_resources {
    "An object relationship"
    course: courses!
    courseId: uuid!
    createdAt: timestamptz
    id: uuid!
    link: String
    name: String!
    resourceType: resource_types_enum!
    "An object relationship"
    upload: uploads
    uploadId: uuid
}

"aggregated selection of \"course_resources\""
type course_resources_aggregate {
    aggregate: course_resources_aggregate_fields
    nodes: [course_resources!]!
}

"aggregate fields of \"course_resources\""
type course_resources_aggregate_fields {
    count(columns: [course_resources_select_column!], distinct: Boolean): Int!
    max: course_resources_max_fields
    min: course_resources_min_fields
}

"aggregate max on columns"
type course_resources_max_fields {
    courseId: uuid
    createdAt: timestamptz
    id: uuid
    link: String
    name: String
    uploadId: uuid
}

"aggregate min on columns"
type course_resources_min_fields {
    courseId: uuid
    createdAt: timestamptz
    id: uuid
    link: String
    name: String
    uploadId: uuid
}

"response of any mutation on the table \"course_resources\""
type course_resources_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [course_resources!]!
}

"columns and relationships of \"course_tags\""
type course_tags {
    classTag: class_tags_enum!
    "An object relationship"
    course: courses!
    courseId: uuid!
    id: uuid!
    "An object relationship"
    tag: class_tags!
}

"aggregated selection of \"course_tags\""
type course_tags_aggregate {
    aggregate: course_tags_aggregate_fields
    nodes: [course_tags!]!
}

"aggregate fields of \"course_tags\""
type course_tags_aggregate_fields {
    count(columns: [course_tags_select_column!], distinct: Boolean): Int!
    max: course_tags_max_fields
    min: course_tags_min_fields
}

"aggregate max on columns"
type course_tags_max_fields {
    courseId: uuid
    id: uuid
}

"aggregate min on columns"
type course_tags_min_fields {
    courseId: uuid
    id: uuid
}

"response of any mutation on the table \"course_tags\""
type course_tags_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [course_tags!]!
}

"columns and relationships of \"course_types\""
type course_types {
    description: String!
    value: String!
}

"aggregated selection of \"course_types\""
type course_types_aggregate {
    aggregate: course_types_aggregate_fields
    nodes: [course_types!]!
}

"aggregate fields of \"course_types\""
type course_types_aggregate_fields {
    count(columns: [course_types_select_column!], distinct: Boolean): Int!
    max: course_types_max_fields
    min: course_types_min_fields
}

"aggregate max on columns"
type course_types_max_fields {
    description: String
    value: String
}

"aggregate min on columns"
type course_types_min_fields {
    description: String
    value: String
}

"response of any mutation on the table \"course_types\""
type course_types_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [course_types!]!
}

"columns and relationships of \"courses\""
type courses {
    "A computed field, executes function \"get_collection_for_course\""
    collection(
        "distinct select on columns"
        distinct_on: [collections_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [collections_order_by!]
        "filter the rows returned"
        where: collections_bool_exp
    ): [collections!]
    "An array relationship"
    collections(
        "distinct select on columns"
        distinct_on: [collection_courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [collection_courses_order_by!]
        "filter the rows returned"
        where: collection_courses_bool_exp
    ): [collection_courses!]!
    "An aggregate relationship"
    collections_aggregate(
        "distinct select on columns"
        distinct_on: [collection_courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [collection_courses_order_by!]
        "filter the rows returned"
        where: collection_courses_bool_exp
    ): collection_courses_aggregate!
    courseType: course_types_enum!
    "An object relationship"
    courseTypeDescriptor: course_types!
    createdAt: timestamptz!
    "A computed field, executes function \"get_course_total_price\""
    currentTotalPrice: numeric
    dayOfWeek: Int!
    "An object relationship"
    educator: educators
    educatorId: uuid
    endTime: timetz
    "A computed field, executes function \"get_user_course_enrollment_status\""
    enrolled: Boolean
    "An array relationship"
    enrollments(
        "distinct select on columns"
        distinct_on: [enrollments_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollments_order_by!]
        "filter the rows returned"
        where: enrollments_bool_exp
    ): [enrollments!]!
    "An aggregate relationship"
    enrollments_aggregate(
        "distinct select on columns"
        distinct_on: [enrollments_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollments_order_by!]
        "filter the rows returned"
        where: enrollments_bool_exp
    ): enrollments_aggregate!
    headline: String
    id: uuid!
    "An object relationship"
    image: uploads!
    imageId: uuid!
    includeInSubscription: Boolean!
    mailchimpSegmentId: String
    maxSessionEndsAt: timestamptz
    maxSessionStartsAt: timestamptz
    minSessionEndsAt: timestamptz
    minSessionStartsAt: timestamptz
    name: String
    overview: String
    price: Int!
    published: Boolean!
    publishedAt: timestamptz
    "An array relationship"
    resources(
        "distinct select on columns"
        distinct_on: [course_resources_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [course_resources_order_by!]
        "filter the rows returned"
        where: course_resources_bool_exp
    ): [course_resources!]!
    "An aggregate relationship"
    resources_aggregate(
        "distinct select on columns"
        distinct_on: [course_resources_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [course_resources_order_by!]
        "filter the rows returned"
        where: course_resources_bool_exp
    ): course_resources_aggregate!
    "An array relationship"
    sessions(
        "distinct select on columns"
        distinct_on: [sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [sessions_order_by!]
        "filter the rows returned"
        where: sessions_bool_exp
    ): [sessions!]!
    "An aggregate relationship"
    sessions_aggregate(
        "distinct select on columns"
        distinct_on: [sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [sessions_order_by!]
        "filter the rows returned"
        where: sessions_bool_exp
    ): sessions_aggregate!
    slug: String!
    startTime: timetz!
    "An array relationship"
    tags(
        "distinct select on columns"
        distinct_on: [course_tags_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [course_tags_order_by!]
        "filter the rows returned"
        where: course_tags_bool_exp
    ): [course_tags!]!
    "An aggregate relationship"
    tags_aggregate(
        "distinct select on columns"
        distinct_on: [course_tags_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [course_tags_order_by!]
        "filter the rows returned"
        where: course_tags_bool_exp
    ): course_tags_aggregate!
    "An object relationship"
    topic: topics!
    topicId: uuid!
    updatedAt: timestamptz
}

"aggregated selection of \"courses\""
type courses_aggregate {
    aggregate: courses_aggregate_fields
    nodes: [courses!]!
}

"aggregate fields of \"courses\""
type courses_aggregate_fields {
    avg: courses_avg_fields
    count(columns: [courses_select_column!], distinct: Boolean): Int!
    max: courses_max_fields
    min: courses_min_fields
    stddev: courses_stddev_fields
    stddev_pop: courses_stddev_pop_fields
    stddev_samp: courses_stddev_samp_fields
    sum: courses_sum_fields
    var_pop: courses_var_pop_fields
    var_samp: courses_var_samp_fields
    variance: courses_variance_fields
}

"aggregate avg on columns"
type courses_avg_fields {
    dayOfWeek: Float
    price: Float
}

"columns and relationships of \"courses_for_collection_assignment\""
type courses_for_collection_assignment {
    course_type: String
    created_at: timestamptz
    day_of_week: Int
    educator_id: uuid
    end_time: timetz
    headline: String
    id: uuid
    "An object relationship"
    image: uploads
    image_id: uuid
    max_session_ends_at: timestamptz
    max_session_starts_at: timestamptz
    min_session_ends_at: timestamptz
    min_session_starts_at: timestamptz
    name: String
    overview: String
    price_per_session: Int
    published: Boolean
    published_at: timestamptz
    slug: String
    start_time: timetz
    topic_id: uuid
    updated_at: timestamptz
}

"aggregated selection of \"courses_for_collection_assignment\""
type courses_for_collection_assignment_aggregate {
    aggregate: courses_for_collection_assignment_aggregate_fields
    nodes: [courses_for_collection_assignment!]!
}

"aggregate fields of \"courses_for_collection_assignment\""
type courses_for_collection_assignment_aggregate_fields {
    avg: courses_for_collection_assignment_avg_fields
    count(columns: [courses_for_collection_assignment_select_column!], distinct: Boolean): Int!
    max: courses_for_collection_assignment_max_fields
    min: courses_for_collection_assignment_min_fields
    stddev: courses_for_collection_assignment_stddev_fields
    stddev_pop: courses_for_collection_assignment_stddev_pop_fields
    stddev_samp: courses_for_collection_assignment_stddev_samp_fields
    sum: courses_for_collection_assignment_sum_fields
    var_pop: courses_for_collection_assignment_var_pop_fields
    var_samp: courses_for_collection_assignment_var_samp_fields
    variance: courses_for_collection_assignment_variance_fields
}

"aggregate avg on columns"
type courses_for_collection_assignment_avg_fields {
    day_of_week: Float
    price_per_session: Float
}

"aggregate max on columns"
type courses_for_collection_assignment_max_fields {
    course_type: String
    created_at: timestamptz
    day_of_week: Int
    educator_id: uuid
    end_time: timetz
    headline: String
    id: uuid
    image_id: uuid
    max_session_ends_at: timestamptz
    max_session_starts_at: timestamptz
    min_session_ends_at: timestamptz
    min_session_starts_at: timestamptz
    name: String
    overview: String
    price_per_session: Int
    published_at: timestamptz
    slug: String
    start_time: timetz
    topic_id: uuid
    updated_at: timestamptz
}

"aggregate min on columns"
type courses_for_collection_assignment_min_fields {
    course_type: String
    created_at: timestamptz
    day_of_week: Int
    educator_id: uuid
    end_time: timetz
    headline: String
    id: uuid
    image_id: uuid
    max_session_ends_at: timestamptz
    max_session_starts_at: timestamptz
    min_session_ends_at: timestamptz
    min_session_starts_at: timestamptz
    name: String
    overview: String
    price_per_session: Int
    published_at: timestamptz
    slug: String
    start_time: timetz
    topic_id: uuid
    updated_at: timestamptz
}

"aggregate stddev on columns"
type courses_for_collection_assignment_stddev_fields {
    day_of_week: Float
    price_per_session: Float
}

"aggregate stddev_pop on columns"
type courses_for_collection_assignment_stddev_pop_fields {
    day_of_week: Float
    price_per_session: Float
}

"aggregate stddev_samp on columns"
type courses_for_collection_assignment_stddev_samp_fields {
    day_of_week: Float
    price_per_session: Float
}

"aggregate sum on columns"
type courses_for_collection_assignment_sum_fields {
    day_of_week: Int
    price_per_session: Int
}

"aggregate var_pop on columns"
type courses_for_collection_assignment_var_pop_fields {
    day_of_week: Float
    price_per_session: Float
}

"aggregate var_samp on columns"
type courses_for_collection_assignment_var_samp_fields {
    day_of_week: Float
    price_per_session: Float
}

"aggregate variance on columns"
type courses_for_collection_assignment_variance_fields {
    day_of_week: Float
    price_per_session: Float
}

"aggregate max on columns"
type courses_max_fields {
    createdAt: timestamptz
    dayOfWeek: Int
    educatorId: uuid
    endTime: timetz
    headline: String
    id: uuid
    imageId: uuid
    mailchimpSegmentId: String
    maxSessionEndsAt: timestamptz
    maxSessionStartsAt: timestamptz
    minSessionEndsAt: timestamptz
    minSessionStartsAt: timestamptz
    name: String
    overview: String
    price: Int
    publishedAt: timestamptz
    slug: String
    startTime: timetz
    topicId: uuid
    updatedAt: timestamptz
}

"aggregate min on columns"
type courses_min_fields {
    createdAt: timestamptz
    dayOfWeek: Int
    educatorId: uuid
    endTime: timetz
    headline: String
    id: uuid
    imageId: uuid
    mailchimpSegmentId: String
    maxSessionEndsAt: timestamptz
    maxSessionStartsAt: timestamptz
    minSessionEndsAt: timestamptz
    minSessionStartsAt: timestamptz
    name: String
    overview: String
    price: Int
    publishedAt: timestamptz
    slug: String
    startTime: timetz
    topicId: uuid
    updatedAt: timestamptz
}

"response of any mutation on the table \"courses\""
type courses_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [courses!]!
}

"aggregate stddev on columns"
type courses_stddev_fields {
    dayOfWeek: Float
    price: Float
}

"aggregate stddev_pop on columns"
type courses_stddev_pop_fields {
    dayOfWeek: Float
    price: Float
}

"aggregate stddev_samp on columns"
type courses_stddev_samp_fields {
    dayOfWeek: Float
    price: Float
}

"aggregate sum on columns"
type courses_sum_fields {
    dayOfWeek: Int
    price: Int
}

"aggregate var_pop on columns"
type courses_var_pop_fields {
    dayOfWeek: Float
    price: Float
}

"aggregate var_samp on columns"
type courses_var_samp_fields {
    dayOfWeek: Float
    price: Float
}

"aggregate variance on columns"
type courses_variance_fields {
    dayOfWeek: Float
    price: Float
}

"columns and relationships of \"educator_books\""
type educator_books {
    "An object relationship"
    cover: uploads!
    "An object relationship"
    educator: users!
    educatorId: uuid!
    id: uuid!
    imageId: uuid!
    link: String
    name: String!
    order: Int
    year: Int!
}

"aggregated selection of \"educator_books\""
type educator_books_aggregate {
    aggregate: educator_books_aggregate_fields
    nodes: [educator_books!]!
}

"aggregate fields of \"educator_books\""
type educator_books_aggregate_fields {
    avg: educator_books_avg_fields
    count(columns: [educator_books_select_column!], distinct: Boolean): Int!
    max: educator_books_max_fields
    min: educator_books_min_fields
    stddev: educator_books_stddev_fields
    stddev_pop: educator_books_stddev_pop_fields
    stddev_samp: educator_books_stddev_samp_fields
    sum: educator_books_sum_fields
    var_pop: educator_books_var_pop_fields
    var_samp: educator_books_var_samp_fields
    variance: educator_books_variance_fields
}

"aggregate avg on columns"
type educator_books_avg_fields {
    order: Float
    year: Float
}

"aggregate max on columns"
type educator_books_max_fields {
    educatorId: uuid
    id: uuid
    imageId: uuid
    link: String
    name: String
    order: Int
    year: Int
}

"aggregate min on columns"
type educator_books_min_fields {
    educatorId: uuid
    id: uuid
    imageId: uuid
    link: String
    name: String
    order: Int
    year: Int
}

"response of any mutation on the table \"educator_books\""
type educator_books_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [educator_books!]!
}

"aggregate stddev on columns"
type educator_books_stddev_fields {
    order: Float
    year: Float
}

"aggregate stddev_pop on columns"
type educator_books_stddev_pop_fields {
    order: Float
    year: Float
}

"aggregate stddev_samp on columns"
type educator_books_stddev_samp_fields {
    order: Float
    year: Float
}

"aggregate sum on columns"
type educator_books_sum_fields {
    order: Int
    year: Int
}

"aggregate var_pop on columns"
type educator_books_var_pop_fields {
    order: Float
    year: Float
}

"aggregate var_samp on columns"
type educator_books_var_samp_fields {
    order: Float
    year: Float
}

"aggregate variance on columns"
type educator_books_variance_fields {
    order: Float
    year: Float
}

"columns and relationships of \"educator_educations\""
type educator_educations {
    "An object relationship"
    educator: users!
    educatorId: uuid!
    id: uuid!
    "An object relationship"
    image: uploads!
    imageId: uuid!
    order: Int
    title: String!
}

"aggregated selection of \"educator_educations\""
type educator_educations_aggregate {
    aggregate: educator_educations_aggregate_fields
    nodes: [educator_educations!]!
}

"aggregate fields of \"educator_educations\""
type educator_educations_aggregate_fields {
    avg: educator_educations_avg_fields
    count(columns: [educator_educations_select_column!], distinct: Boolean): Int!
    max: educator_educations_max_fields
    min: educator_educations_min_fields
    stddev: educator_educations_stddev_fields
    stddev_pop: educator_educations_stddev_pop_fields
    stddev_samp: educator_educations_stddev_samp_fields
    sum: educator_educations_sum_fields
    var_pop: educator_educations_var_pop_fields
    var_samp: educator_educations_var_samp_fields
    variance: educator_educations_variance_fields
}

"aggregate avg on columns"
type educator_educations_avg_fields {
    order: Float
}

"aggregate max on columns"
type educator_educations_max_fields {
    educatorId: uuid
    id: uuid
    imageId: uuid
    order: Int
    title: String
}

"aggregate min on columns"
type educator_educations_min_fields {
    educatorId: uuid
    id: uuid
    imageId: uuid
    order: Int
    title: String
}

"response of any mutation on the table \"educator_educations\""
type educator_educations_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [educator_educations!]!
}

"aggregate stddev on columns"
type educator_educations_stddev_fields {
    order: Float
}

"aggregate stddev_pop on columns"
type educator_educations_stddev_pop_fields {
    order: Float
}

"aggregate stddev_samp on columns"
type educator_educations_stddev_samp_fields {
    order: Float
}

"aggregate sum on columns"
type educator_educations_sum_fields {
    order: Int
}

"aggregate var_pop on columns"
type educator_educations_var_pop_fields {
    order: Float
}

"aggregate var_samp on columns"
type educator_educations_var_samp_fields {
    order: Float
}

"aggregate variance on columns"
type educator_educations_variance_fields {
    order: Float
}

"columns and relationships of \"educator_profiles\""
type educator_profiles {
    awardsAndFeatures: String!
    bio: String!
    "An object relationship"
    educator: educators
    educatorId: uuid!
    prefix: String
    primaryTopicId: uuid
    tagline: String!
    "An object relationship"
    topic: topics
}

"aggregated selection of \"educator_profiles\""
type educator_profiles_aggregate {
    aggregate: educator_profiles_aggregate_fields
    nodes: [educator_profiles!]!
}

"aggregate fields of \"educator_profiles\""
type educator_profiles_aggregate_fields {
    count(columns: [educator_profiles_select_column!], distinct: Boolean): Int!
    max: educator_profiles_max_fields
    min: educator_profiles_min_fields
}

"aggregate max on columns"
type educator_profiles_max_fields {
    awardsAndFeatures: String
    bio: String
    educatorId: uuid
    prefix: String
    primaryTopicId: uuid
    tagline: String
}

"aggregate min on columns"
type educator_profiles_min_fields {
    awardsAndFeatures: String
    bio: String
    educatorId: uuid
    prefix: String
    primaryTopicId: uuid
    tagline: String
}

"response of any mutation on the table \"educator_profiles\""
type educator_profiles_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [educator_profiles!]!
}

"columns and relationships of \"educator_publications\""
type educator_publications {
    createdAt: timestamptz!
    "An object relationship"
    educator: users!
    educatorId: uuid!
    id: uuid!
    "An object relationship"
    image: uploads!
    imageId: uuid!
    link: String
    order: Int!
    title: String!
    updatedAt: timestamptz!
    year: Int!
}

"aggregated selection of \"educator_publications\""
type educator_publications_aggregate {
    aggregate: educator_publications_aggregate_fields
    nodes: [educator_publications!]!
}

"aggregate fields of \"educator_publications\""
type educator_publications_aggregate_fields {
    avg: educator_publications_avg_fields
    count(columns: [educator_publications_select_column!], distinct: Boolean): Int!
    max: educator_publications_max_fields
    min: educator_publications_min_fields
    stddev: educator_publications_stddev_fields
    stddev_pop: educator_publications_stddev_pop_fields
    stddev_samp: educator_publications_stddev_samp_fields
    sum: educator_publications_sum_fields
    var_pop: educator_publications_var_pop_fields
    var_samp: educator_publications_var_samp_fields
    variance: educator_publications_variance_fields
}

"aggregate avg on columns"
type educator_publications_avg_fields {
    order: Float
    year: Float
}

"aggregate max on columns"
type educator_publications_max_fields {
    createdAt: timestamptz
    educatorId: uuid
    id: uuid
    imageId: uuid
    link: String
    order: Int
    title: String
    updatedAt: timestamptz
    year: Int
}

"aggregate min on columns"
type educator_publications_min_fields {
    createdAt: timestamptz
    educatorId: uuid
    id: uuid
    imageId: uuid
    link: String
    order: Int
    title: String
    updatedAt: timestamptz
    year: Int
}

"response of any mutation on the table \"educator_publications\""
type educator_publications_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [educator_publications!]!
}

"aggregate stddev on columns"
type educator_publications_stddev_fields {
    order: Float
    year: Float
}

"aggregate stddev_pop on columns"
type educator_publications_stddev_pop_fields {
    order: Float
    year: Float
}

"aggregate stddev_samp on columns"
type educator_publications_stddev_samp_fields {
    order: Float
    year: Float
}

"aggregate sum on columns"
type educator_publications_sum_fields {
    order: Int
    year: Int
}

"aggregate var_pop on columns"
type educator_publications_var_pop_fields {
    order: Float
    year: Float
}

"aggregate var_samp on columns"
type educator_publications_var_samp_fields {
    order: Float
    year: Float
}

"aggregate variance on columns"
type educator_publications_variance_fields {
    order: Float
    year: Float
}

"columns and relationships of \"educator_teaching_styles\""
type educator_teaching_styles {
    "An object relationship"
    educator: users!
    educatorId: uuid!
    style: teaching_styles_enum!
    "An object relationship"
    teachingStyle: teaching_styles!
}

"aggregated selection of \"educator_teaching_styles\""
type educator_teaching_styles_aggregate {
    aggregate: educator_teaching_styles_aggregate_fields
    nodes: [educator_teaching_styles!]!
}

"aggregate fields of \"educator_teaching_styles\""
type educator_teaching_styles_aggregate_fields {
    count(columns: [educator_teaching_styles_select_column!], distinct: Boolean): Int!
    max: educator_teaching_styles_max_fields
    min: educator_teaching_styles_min_fields
}

"aggregate max on columns"
type educator_teaching_styles_max_fields {
    educatorId: uuid
}

"aggregate min on columns"
type educator_teaching_styles_min_fields {
    educatorId: uuid
}

"response of any mutation on the table \"educator_teaching_styles\""
type educator_teaching_styles_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [educator_teaching_styles!]!
}

"columns and relationships of \"educator_testimonials\""
type educator_testimonials {
    content: String!
    educatorId: uuid!
    id: uuid!
    order: numeric!
    subTitle: String!
    title: String!
}

"aggregated selection of \"educator_testimonials\""
type educator_testimonials_aggregate {
    aggregate: educator_testimonials_aggregate_fields
    nodes: [educator_testimonials!]!
}

"aggregate fields of \"educator_testimonials\""
type educator_testimonials_aggregate_fields {
    avg: educator_testimonials_avg_fields
    count(columns: [educator_testimonials_select_column!], distinct: Boolean): Int!
    max: educator_testimonials_max_fields
    min: educator_testimonials_min_fields
    stddev: educator_testimonials_stddev_fields
    stddev_pop: educator_testimonials_stddev_pop_fields
    stddev_samp: educator_testimonials_stddev_samp_fields
    sum: educator_testimonials_sum_fields
    var_pop: educator_testimonials_var_pop_fields
    var_samp: educator_testimonials_var_samp_fields
    variance: educator_testimonials_variance_fields
}

"aggregate avg on columns"
type educator_testimonials_avg_fields {
    order: Float
}

"aggregate max on columns"
type educator_testimonials_max_fields {
    content: String
    educatorId: uuid
    id: uuid
    order: numeric
    subTitle: String
    title: String
}

"aggregate min on columns"
type educator_testimonials_min_fields {
    content: String
    educatorId: uuid
    id: uuid
    order: numeric
    subTitle: String
    title: String
}

"response of any mutation on the table \"educator_testimonials\""
type educator_testimonials_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [educator_testimonials!]!
}

"aggregate stddev on columns"
type educator_testimonials_stddev_fields {
    order: Float
}

"aggregate stddev_pop on columns"
type educator_testimonials_stddev_pop_fields {
    order: Float
}

"aggregate stddev_samp on columns"
type educator_testimonials_stddev_samp_fields {
    order: Float
}

"aggregate sum on columns"
type educator_testimonials_sum_fields {
    order: numeric
}

"aggregate var_pop on columns"
type educator_testimonials_var_pop_fields {
    order: Float
}

"aggregate var_samp on columns"
type educator_testimonials_var_samp_fields {
    order: Float
}

"aggregate variance on columns"
type educator_testimonials_variance_fields {
    order: Float
}

"columns and relationships of \"educator_topics\""
type educator_topics {
    id: uuid
    mask_upload_id: uuid
    name: String
    order: Int
    primary_color: String
    secondary_color: String
    slug: String
}

"aggregated selection of \"educator_topics\""
type educator_topics_aggregate {
    aggregate: educator_topics_aggregate_fields
    nodes: [educator_topics!]!
}

"aggregate fields of \"educator_topics\""
type educator_topics_aggregate_fields {
    avg: educator_topics_avg_fields
    count(columns: [educator_topics_select_column!], distinct: Boolean): Int!
    max: educator_topics_max_fields
    min: educator_topics_min_fields
    stddev: educator_topics_stddev_fields
    stddev_pop: educator_topics_stddev_pop_fields
    stddev_samp: educator_topics_stddev_samp_fields
    sum: educator_topics_sum_fields
    var_pop: educator_topics_var_pop_fields
    var_samp: educator_topics_var_samp_fields
    variance: educator_topics_variance_fields
}

"aggregate avg on columns"
type educator_topics_avg_fields {
    order: Float
}

"aggregate max on columns"
type educator_topics_max_fields {
    id: uuid
    mask_upload_id: uuid
    name: String
    order: Int
    primary_color: String
    secondary_color: String
    slug: String
}

"aggregate min on columns"
type educator_topics_min_fields {
    id: uuid
    mask_upload_id: uuid
    name: String
    order: Int
    primary_color: String
    secondary_color: String
    slug: String
}

"response of any mutation on the table \"educator_topics\""
type educator_topics_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [educator_topics!]!
}

"aggregate stddev on columns"
type educator_topics_stddev_fields {
    order: Float
}

"aggregate stddev_pop on columns"
type educator_topics_stddev_pop_fields {
    order: Float
}

"aggregate stddev_samp on columns"
type educator_topics_stddev_samp_fields {
    order: Float
}

"aggregate sum on columns"
type educator_topics_sum_fields {
    order: Int
}

"aggregate var_pop on columns"
type educator_topics_var_pop_fields {
    order: Float
}

"aggregate var_samp on columns"
type educator_topics_var_samp_fields {
    order: Float
}

"aggregate variance on columns"
type educator_topics_variance_fields {
    order: Float
}

"columns and relationships of \"educators\""
type educators {
    "An object relationship"
    avatar: uploads
    avatarId: uuid
    "An array relationship"
    books(
        "distinct select on columns"
        distinct_on: [educator_books_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_books_order_by!]
        "filter the rows returned"
        where: educator_books_bool_exp
    ): [educator_books!]!
    "An aggregate relationship"
    books_aggregate(
        "distinct select on columns"
        distinct_on: [educator_books_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_books_order_by!]
        "filter the rows returned"
        where: educator_books_bool_exp
    ): educator_books_aggregate!
    "An array relationship"
    courses(
        "distinct select on columns"
        distinct_on: [courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_order_by!]
        "filter the rows returned"
        where: courses_bool_exp
    ): [courses!]!
    "An aggregate relationship"
    courses_aggregate(
        "distinct select on columns"
        distinct_on: [courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_order_by!]
        "filter the rows returned"
        where: courses_bool_exp
    ): courses_aggregate!
    created_at: timestamptz
    "An array relationship"
    educations(
        "distinct select on columns"
        distinct_on: [educator_educations_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_educations_order_by!]
        "filter the rows returned"
        where: educator_educations_bool_exp
    ): [educator_educations!]!
    "An aggregate relationship"
    educations_aggregate(
        "distinct select on columns"
        distinct_on: [educator_educations_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_educations_order_by!]
        "filter the rows returned"
        where: educator_educations_bool_exp
    ): educator_educations_aggregate!
    email: citext
    firstName: String
    fullName: citext
    has_confirmed: Boolean
    id: uuid
    is_mailchimp_registered: Boolean
    lastName: String
    "An object relationship"
    profile: educator_profiles
    "An array relationship"
    publications(
        "distinct select on columns"
        distinct_on: [educator_publications_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_publications_order_by!]
        "filter the rows returned"
        where: educator_publications_bool_exp
    ): [educator_publications!]!
    "An aggregate relationship"
    publications_aggregate(
        "distinct select on columns"
        distinct_on: [educator_publications_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_publications_order_by!]
        "filter the rows returned"
        where: educator_publications_bool_exp
    ): educator_publications_aggregate!
    role: String
    slug: String
    "An array relationship"
    teachingStyles(
        "distinct select on columns"
        distinct_on: [educator_teaching_styles_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_teaching_styles_order_by!]
        "filter the rows returned"
        where: educator_teaching_styles_bool_exp
    ): [educator_teaching_styles!]!
    "An aggregate relationship"
    teachingStyles_aggregate(
        "distinct select on columns"
        distinct_on: [educator_teaching_styles_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_teaching_styles_order_by!]
        "filter the rows returned"
        where: educator_teaching_styles_bool_exp
    ): educator_teaching_styles_aggregate!
    "An array relationship"
    testimonials(
        "distinct select on columns"
        distinct_on: [educator_testimonials_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_testimonials_order_by!]
        "filter the rows returned"
        where: educator_testimonials_bool_exp
    ): [educator_testimonials!]!
    "An aggregate relationship"
    testimonials_aggregate(
        "distinct select on columns"
        distinct_on: [educator_testimonials_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_testimonials_order_by!]
        "filter the rows returned"
        where: educator_testimonials_bool_exp
    ): educator_testimonials_aggregate!
    updated_at: timestamptz
}

"aggregated selection of \"educators\""
type educators_aggregate {
    aggregate: educators_aggregate_fields
    nodes: [educators!]!
}

"aggregate fields of \"educators\""
type educators_aggregate_fields {
    count(columns: [educators_select_column!], distinct: Boolean): Int!
    max: educators_max_fields
    min: educators_min_fields
}

"aggregate max on columns"
type educators_max_fields {
    avatarId: uuid
    created_at: timestamptz
    email: citext
    firstName: String
    fullName: citext
    id: uuid
    lastName: String
    role: String
    slug: String
    updated_at: timestamptz
}

"aggregate min on columns"
type educators_min_fields {
    avatarId: uuid
    created_at: timestamptz
    email: citext
    firstName: String
    fullName: citext
    id: uuid
    lastName: String
    role: String
    slug: String
    updated_at: timestamptz
}

"response of any mutation on the table \"educators\""
type educators_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [educators!]!
}

"columns and relationships of \"enrollment_sessions\""
type enrollment_sessions {
    "An object relationship"
    course: courses!
    courseId: uuid!
    "An object relationship"
    enrollment: enrollments!
    enrollmentId: uuid!
    id: uuid!
    "An object relationship"
    session: sessions!
    sessionId: uuid!
    "An object relationship"
    user: users
    userId: uuid
}

"aggregated selection of \"enrollment_sessions\""
type enrollment_sessions_aggregate {
    aggregate: enrollment_sessions_aggregate_fields
    nodes: [enrollment_sessions!]!
}

"aggregate fields of \"enrollment_sessions\""
type enrollment_sessions_aggregate_fields {
    count(columns: [enrollment_sessions_select_column!], distinct: Boolean): Int!
    max: enrollment_sessions_max_fields
    min: enrollment_sessions_min_fields
}

"aggregate max on columns"
type enrollment_sessions_max_fields {
    courseId: uuid
    enrollmentId: uuid
    id: uuid
    sessionId: uuid
    userId: uuid
}

"aggregate min on columns"
type enrollment_sessions_min_fields {
    courseId: uuid
    enrollmentId: uuid
    id: uuid
    sessionId: uuid
    userId: uuid
}

"response of any mutation on the table \"enrollment_sessions\""
type enrollment_sessions_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [enrollment_sessions!]!
}

"columns and relationships of \"enrollments\""
type enrollments {
    "An object relationship"
    course: courses!
    courseId: uuid!
    createdAt: timestamptz!
    id: uuid!
    "An array relationship"
    sessions(
        "distinct select on columns"
        distinct_on: [enrollment_sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollment_sessions_order_by!]
        "filter the rows returned"
        where: enrollment_sessions_bool_exp
    ): [enrollment_sessions!]!
    "An aggregate relationship"
    sessions_aggregate(
        "distinct select on columns"
        distinct_on: [enrollment_sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollment_sessions_order_by!]
        "filter the rows returned"
        where: enrollment_sessions_bool_exp
    ): enrollment_sessions_aggregate!
    "An object relationship"
    user: users!
    userId: uuid!
    withSubscription: Boolean!
}

"aggregated selection of \"enrollments\""
type enrollments_aggregate {
    aggregate: enrollments_aggregate_fields
    nodes: [enrollments!]!
}

"aggregate fields of \"enrollments\""
type enrollments_aggregate_fields {
    count(columns: [enrollments_select_column!], distinct: Boolean): Int!
    max: enrollments_max_fields
    min: enrollments_min_fields
}

"aggregate max on columns"
type enrollments_max_fields {
    courseId: uuid
    createdAt: timestamptz
    id: uuid
    userId: uuid
}

"aggregate min on columns"
type enrollments_min_fields {
    courseId: uuid
    createdAt: timestamptz
    id: uuid
    userId: uuid
}

"response of any mutation on the table \"enrollments\""
type enrollments_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [enrollments!]!
}

"mutation root"
type mutation_root {
    cancelSubscription(subscriptionId: uuid!): String
    "delete single row from the table: \"class_tags\""
    delete_class_tag(value: String!): class_tags
    "delete data from the table: \"class_tags\""
    delete_class_tags(
        "filter the rows which have to be deleted"
        where: class_tags_bool_exp!
    ): class_tags_mutation_response
    "delete single row from the table: \"collections\""
    delete_collection(id: uuid!): collections
    "delete single row from the table: \"collection_courses\""
    delete_collection_course(id: uuid!): collection_courses
    "delete data from the table: \"collection_courses\""
    delete_collection_courses(
        "filter the rows which have to be deleted"
        where: collection_courses_bool_exp!
    ): collection_courses_mutation_response
    "delete data from the table: \"collections\""
    delete_collections(
        "filter the rows which have to be deleted"
        where: collections_bool_exp!
    ): collections_mutation_response
    "delete data from the table: \"config_types\""
    delete_config_types(
        "filter the rows which have to be deleted"
        where: config_types_bool_exp!
    ): config_types_mutation_response
    "delete single row from the table: \"config_types\""
    delete_config_types_by_pk(value: String!): config_types
    "delete single row from the table: \"config_values\""
    delete_config_value(configType: config_types_enum!): config_values
    "delete data from the table: \"config_values\""
    delete_config_values(
        "filter the rows which have to be deleted"
        where: config_values_bool_exp!
    ): config_values_mutation_response
    "delete single row from the table: \"coupons\""
    delete_coupon(id: String!): coupons
    "delete data from the table: \"coupons\""
    delete_coupons("filter the rows which have to be deleted" where: coupons_bool_exp!): coupons_mutation_response
    "delete single row from the table: \"courses\""
    delete_course(id: uuid!): courses
    "delete single row from the table: \"course_resources\""
    delete_course_resource(id: uuid!): course_resources
    "delete data from the table: \"course_resources\""
    delete_course_resources(
        "filter the rows which have to be deleted"
        where: course_resources_bool_exp!
    ): course_resources_mutation_response
    "delete single row from the table: \"course_tags\""
    delete_course_tag(id: uuid!): course_tags
    "delete data from the table: \"course_tags\""
    delete_course_tags(
        "filter the rows which have to be deleted"
        where: course_tags_bool_exp!
    ): course_tags_mutation_response
    "delete data from the table: \"course_types\""
    delete_course_types(
        "filter the rows which have to be deleted"
        where: course_types_bool_exp!
    ): course_types_mutation_response
    "delete single row from the table: \"course_types\""
    delete_course_types_by_pk(value: String!): course_types
    "delete data from the table: \"courses\""
    delete_courses("filter the rows which have to be deleted" where: courses_bool_exp!): courses_mutation_response
    "delete single row from the table: \"educator_books\""
    delete_educator_book(id: uuid!): educator_books
    "delete data from the table: \"educator_books\""
    delete_educator_books(
        "filter the rows which have to be deleted"
        where: educator_books_bool_exp!
    ): educator_books_mutation_response
    "delete single row from the table: \"educator_educations\""
    delete_educator_education(id: uuid!): educator_educations
    "delete data from the table: \"educator_educations\""
    delete_educator_educations(
        "filter the rows which have to be deleted"
        where: educator_educations_bool_exp!
    ): educator_educations_mutation_response
    "delete single row from the table: \"educator_profiles\""
    delete_educator_profile(educatorId: uuid!): educator_profiles
    "delete data from the table: \"educator_profiles\""
    delete_educator_profiles(
        "filter the rows which have to be deleted"
        where: educator_profiles_bool_exp!
    ): educator_profiles_mutation_response
    "delete single row from the table: \"educator_publications\""
    delete_educator_publication(id: uuid!): educator_publications
    "delete data from the table: \"educator_publications\""
    delete_educator_publications(
        "filter the rows which have to be deleted"
        where: educator_publications_bool_exp!
    ): educator_publications_mutation_response
    "delete single row from the table: \"educator_teaching_styles\""
    delete_educator_teaching_style(educatorId: uuid!, style: teaching_styles_enum!): educator_teaching_styles
    "delete data from the table: \"educator_teaching_styles\""
    delete_educator_teaching_styles(
        "filter the rows which have to be deleted"
        where: educator_teaching_styles_bool_exp!
    ): educator_teaching_styles_mutation_response
    "delete single row from the table: \"educator_testimonials\""
    delete_educator_testimonial(id: uuid!): educator_testimonials
    "delete data from the table: \"educator_testimonials\""
    delete_educator_testimonials(
        "filter the rows which have to be deleted"
        where: educator_testimonials_bool_exp!
    ): educator_testimonials_mutation_response
    "delete data from the table: \"educator_topics\""
    delete_educator_topics(
        "filter the rows which have to be deleted"
        where: educator_topics_bool_exp!
    ): educator_topics_mutation_response
    "delete data from the table: \"educators\""
    delete_educators("filter the rows which have to be deleted" where: educators_bool_exp!): educators_mutation_response
    "delete single row from the table: \"enrollments\""
    delete_enrollment(id: uuid!): enrollments
    "delete data from the table: \"enrollment_sessions\""
    delete_enrollment_sessions(
        "filter the rows which have to be deleted"
        where: enrollment_sessions_bool_exp!
    ): enrollment_sessions_mutation_response
    "delete single row from the table: \"enrollment_sessions\""
    delete_enrollment_sessions_by_pk(id: uuid!): enrollment_sessions
    "delete data from the table: \"enrollments\""
    delete_enrollments(
        "filter the rows which have to be deleted"
        where: enrollments_bool_exp!
    ): enrollments_mutation_response
    "delete single row from the table: \"orders\""
    delete_order(id: uuid!): orders
    "delete data from the table: \"orderable_entities\""
    delete_orderable_entities(
        "filter the rows which have to be deleted"
        where: orderable_entities_bool_exp!
    ): orderable_entities_mutation_response
    "delete single row from the table: \"orderable_entities\""
    delete_orderable_entities_by_pk(value: String!): orderable_entities
    "delete data from the table: \"orders\""
    delete_orders("filter the rows which have to be deleted" where: orders_bool_exp!): orders_mutation_response
    "delete data from the table: \"organization\""
    delete_organization(
        "filter the rows which have to be deleted"
        where: organization_bool_exp!
    ): organization_mutation_response
    "delete single row from the table: \"organization\""
    delete_organization_by_pk(id: uuid!): organization
    "delete single row from the table: \"products\""
    delete_product(id: String!): products
    "delete single row from the table: \"product_prices\""
    delete_product_price(id: String!): product_prices
    "delete data from the table: \"product_prices\""
    delete_product_prices(
        "filter the rows which have to be deleted"
        where: product_prices_bool_exp!
    ): product_prices_mutation_response
    "delete data from the table: \"products\""
    delete_products("filter the rows which have to be deleted" where: products_bool_exp!): products_mutation_response
    "delete single row from the table: \"promo_codes\""
    delete_promo_code(id: String!): promo_codes
    "delete data from the table: \"promo_codes\""
    delete_promo_codes(
        "filter the rows which have to be deleted"
        where: promo_codes_bool_exp!
    ): promo_codes_mutation_response
    "delete data from the table: \"redirect_mappings\""
    delete_redirect_mappings(
        "filter the rows which have to be deleted"
        where: redirect_mappings_bool_exp!
    ): redirect_mappings_mutation_response
    "delete single row from the table: \"redirect_mappings\""
    delete_redirect_mappings_by_pk(from_slug: String!, kind: String!, to_slug: String!): redirect_mappings
    "delete data from the table: \"resource_types\""
    delete_resource_types(
        "filter the rows which have to be deleted"
        where: resource_types_bool_exp!
    ): resource_types_mutation_response
    "delete single row from the table: \"resource_types\""
    delete_resource_types_by_pk(value: String!): resource_types
    "delete single row from the table: \"sessions\""
    delete_session(id: uuid!): sessions
    "delete data from the table: \"sessions\""
    delete_sessions("filter the rows which have to be deleted" where: sessions_bool_exp!): sessions_mutation_response
    "delete single row from the table: \"stripe_customers\""
    delete_stripe_customer(userId: uuid!): stripe_customers
    "delete data from the table: \"stripe_customers\""
    delete_stripe_customers(
        "filter the rows which have to be deleted"
        where: stripe_customers_bool_exp!
    ): stripe_customers_mutation_response
    "delete single row from the table: \"subscriptions\""
    delete_subscription(id: uuid!): subscriptions
    "delete data from the table: \"subscription_status\""
    delete_subscription_status(
        "filter the rows which have to be deleted"
        where: subscription_status_bool_exp!
    ): subscription_status_mutation_response
    "delete single row from the table: \"subscription_status\""
    delete_subscription_status_by_pk(value: String!): subscription_status
    "delete data from the table: \"subscriptions\""
    delete_subscriptions(
        "filter the rows which have to be deleted"
        where: subscriptions_bool_exp!
    ): subscriptions_mutation_response
    "delete single row from the table: \"teaching_styles\""
    delete_teaching_style(value: String!): teaching_styles
    "delete data from the table: \"teaching_styles\""
    delete_teaching_styles(
        "filter the rows which have to be deleted"
        where: teaching_styles_bool_exp!
    ): teaching_styles_mutation_response
    "delete single row from the table: \"topics\""
    delete_topic(id: uuid!): topics
    "delete data from the table: \"topics\""
    delete_topics("filter the rows which have to be deleted" where: topics_bool_exp!): topics_mutation_response
    "delete data from the table: \"update_entity_order_request\""
    delete_update_entity_order_request(
        "filter the rows which have to be deleted"
        where: update_entity_order_request_bool_exp!
    ): update_entity_order_request_mutation_response
    "delete single row from the table: \"update_entity_order_request\""
    delete_update_entity_order_request_by_pk(entityId: uuid!, order: Int!): update_entity_order_request
    "delete single row from the table: \"uploads\""
    delete_upload(id: uuid!): uploads
    "delete data from the table: \"uploads\""
    delete_uploads("filter the rows which have to be deleted" where: uploads_bool_exp!): uploads_mutation_response
    "delete single row from the table: \"user_class_preferences\""
    delete_use_class_preference(preferenceValue: class_tags_enum!, userId: uuid!): user_class_preferences
    "delete single row from the table: \"users\""
    delete_user(id: uuid!): users
    "delete data from the table: \"user_class_preferences\""
    delete_user_class_preferences(
        "filter the rows which have to be deleted"
        where: user_class_preferences_bool_exp!
    ): user_class_preferences_mutation_response
    "delete data from the table: \"user_details\""
    delete_user_details(
        "filter the rows which have to be deleted"
        where: user_details_bool_exp!
    ): user_details_mutation_response
    "delete data from the table: \"user_roles\""
    delete_user_roles(
        "filter the rows which have to be deleted"
        where: user_roles_bool_exp!
    ): user_roles_mutation_response
    "delete single row from the table: \"user_roles\""
    delete_user_roles_by_pk(value: String!): user_roles
    "delete single row from the table: \"user_teaching_style_preferences\""
    delete_user_teaching_style_preference(
        preferenceValue: teaching_styles_enum!
        userId: uuid!
    ): user_teaching_style_preferences
    "delete data from the table: \"user_teaching_style_preferences\""
    delete_user_teaching_style_preferences(
        "filter the rows which have to be deleted"
        where: user_teaching_style_preferences_bool_exp!
    ): user_teaching_style_preferences_mutation_response
    "delete data from the table: \"users\""
    delete_users("filter the rows which have to be deleted" where: users_bool_exp!): users_mutation_response
    "enroll"
    enroll(courseId: uuid!, paymentMethodId: String, productId: String, promoCode: String, seats: Int): EnrollOutput
    initiateUpload(contentType: String!, id: uuid, name: String!): SignedUpload
    "insert a single row into the table: \"class_tags\""
    insert_class_tag(
        "the row to be inserted"
        object: class_tags_insert_input!
        "on conflict condition"
        on_conflict: class_tags_on_conflict
    ): class_tags
    "insert data into the table: \"class_tags\""
    insert_class_tags(
        "the rows to be inserted"
        objects: [class_tags_insert_input!]!
        "on conflict condition"
        on_conflict: class_tags_on_conflict
    ): class_tags_mutation_response
    "insert a single row into the table: \"collections\""
    insert_collection(
        "the row to be inserted"
        object: collections_insert_input!
        "on conflict condition"
        on_conflict: collections_on_conflict
    ): collections
    "insert a single row into the table: \"collection_courses\""
    insert_collection_course(
        "the row to be inserted"
        object: collection_courses_insert_input!
        "on conflict condition"
        on_conflict: collection_courses_on_conflict
    ): collection_courses
    "insert data into the table: \"collection_courses\""
    insert_collection_courses(
        "the rows to be inserted"
        objects: [collection_courses_insert_input!]!
        "on conflict condition"
        on_conflict: collection_courses_on_conflict
    ): collection_courses_mutation_response
    "insert data into the table: \"collections\""
    insert_collections(
        "the rows to be inserted"
        objects: [collections_insert_input!]!
        "on conflict condition"
        on_conflict: collections_on_conflict
    ): collections_mutation_response
    "insert data into the table: \"config_types\""
    insert_config_types(
        "the rows to be inserted"
        objects: [config_types_insert_input!]!
        "on conflict condition"
        on_conflict: config_types_on_conflict
    ): config_types_mutation_response
    "insert a single row into the table: \"config_types\""
    insert_config_types_one(
        "the row to be inserted"
        object: config_types_insert_input!
        "on conflict condition"
        on_conflict: config_types_on_conflict
    ): config_types
    "insert a single row into the table: \"config_values\""
    insert_config_value(
        "the row to be inserted"
        object: config_values_insert_input!
        "on conflict condition"
        on_conflict: config_values_on_conflict
    ): config_values
    "insert data into the table: \"config_values\""
    insert_config_values(
        "the rows to be inserted"
        objects: [config_values_insert_input!]!
        "on conflict condition"
        on_conflict: config_values_on_conflict
    ): config_values_mutation_response
    "insert a single row into the table: \"coupons\""
    insert_coupon(
        "the row to be inserted"
        object: coupons_insert_input!
        "on conflict condition"
        on_conflict: coupons_on_conflict
    ): coupons
    "insert data into the table: \"coupons\""
    insert_coupons(
        "the rows to be inserted"
        objects: [coupons_insert_input!]!
        "on conflict condition"
        on_conflict: coupons_on_conflict
    ): coupons_mutation_response
    "insert a single row into the table: \"courses\""
    insert_course(
        "the row to be inserted"
        object: courses_insert_input!
        "on conflict condition"
        on_conflict: courses_on_conflict
    ): courses
    "insert a single row into the table: \"course_resources\""
    insert_course_resource(
        "the row to be inserted"
        object: course_resources_insert_input!
        "on conflict condition"
        on_conflict: course_resources_on_conflict
    ): course_resources
    "insert data into the table: \"course_resources\""
    insert_course_resources(
        "the rows to be inserted"
        objects: [course_resources_insert_input!]!
        "on conflict condition"
        on_conflict: course_resources_on_conflict
    ): course_resources_mutation_response
    "insert a single row into the table: \"course_tags\""
    insert_course_tag(
        "the row to be inserted"
        object: course_tags_insert_input!
        "on conflict condition"
        on_conflict: course_tags_on_conflict
    ): course_tags
    "insert data into the table: \"course_tags\""
    insert_course_tags(
        "the rows to be inserted"
        objects: [course_tags_insert_input!]!
        "on conflict condition"
        on_conflict: course_tags_on_conflict
    ): course_tags_mutation_response
    "insert data into the table: \"course_types\""
    insert_course_types(
        "the rows to be inserted"
        objects: [course_types_insert_input!]!
        "on conflict condition"
        on_conflict: course_types_on_conflict
    ): course_types_mutation_response
    "insert a single row into the table: \"course_types\""
    insert_course_types_one(
        "the row to be inserted"
        object: course_types_insert_input!
        "on conflict condition"
        on_conflict: course_types_on_conflict
    ): course_types
    "insert data into the table: \"courses\""
    insert_courses(
        "the rows to be inserted"
        objects: [courses_insert_input!]!
        "on conflict condition"
        on_conflict: courses_on_conflict
    ): courses_mutation_response
    "insert a single row into the table: \"educator_books\""
    insert_educator_book(
        "the row to be inserted"
        object: educator_books_insert_input!
        "on conflict condition"
        on_conflict: educator_books_on_conflict
    ): educator_books
    "insert data into the table: \"educator_books\""
    insert_educator_books(
        "the rows to be inserted"
        objects: [educator_books_insert_input!]!
        "on conflict condition"
        on_conflict: educator_books_on_conflict
    ): educator_books_mutation_response
    "insert a single row into the table: \"educator_educations\""
    insert_educator_education(
        "the row to be inserted"
        object: educator_educations_insert_input!
        "on conflict condition"
        on_conflict: educator_educations_on_conflict
    ): educator_educations
    "insert data into the table: \"educator_educations\""
    insert_educator_educations(
        "the rows to be inserted"
        objects: [educator_educations_insert_input!]!
        "on conflict condition"
        on_conflict: educator_educations_on_conflict
    ): educator_educations_mutation_response
    "insert a single row into the table: \"educator_profiles\""
    insert_educator_profile(
        "the row to be inserted"
        object: educator_profiles_insert_input!
        "on conflict condition"
        on_conflict: educator_profiles_on_conflict
    ): educator_profiles
    "insert data into the table: \"educator_profiles\""
    insert_educator_profiles(
        "the rows to be inserted"
        objects: [educator_profiles_insert_input!]!
        "on conflict condition"
        on_conflict: educator_profiles_on_conflict
    ): educator_profiles_mutation_response
    "insert a single row into the table: \"educator_publications\""
    insert_educator_publication(
        "the row to be inserted"
        object: educator_publications_insert_input!
        "on conflict condition"
        on_conflict: educator_publications_on_conflict
    ): educator_publications
    "insert data into the table: \"educator_publications\""
    insert_educator_publications(
        "the rows to be inserted"
        objects: [educator_publications_insert_input!]!
        "on conflict condition"
        on_conflict: educator_publications_on_conflict
    ): educator_publications_mutation_response
    "insert a single row into the table: \"educator_teaching_styles\""
    insert_educator_teaching_style(
        "the row to be inserted"
        object: educator_teaching_styles_insert_input!
        "on conflict condition"
        on_conflict: educator_teaching_styles_on_conflict
    ): educator_teaching_styles
    "insert data into the table: \"educator_teaching_styles\""
    insert_educator_teaching_styles(
        "the rows to be inserted"
        objects: [educator_teaching_styles_insert_input!]!
        "on conflict condition"
        on_conflict: educator_teaching_styles_on_conflict
    ): educator_teaching_styles_mutation_response
    "insert a single row into the table: \"educator_testimonials\""
    insert_educator_testimonial(
        "the row to be inserted"
        object: educator_testimonials_insert_input!
        "on conflict condition"
        on_conflict: educator_testimonials_on_conflict
    ): educator_testimonials
    "insert data into the table: \"educator_testimonials\""
    insert_educator_testimonials(
        "the rows to be inserted"
        objects: [educator_testimonials_insert_input!]!
        "on conflict condition"
        on_conflict: educator_testimonials_on_conflict
    ): educator_testimonials_mutation_response
    "insert data into the table: \"educator_topics\""
    insert_educator_topics(
        "the rows to be inserted"
        objects: [educator_topics_insert_input!]!
    ): educator_topics_mutation_response
    "insert a single row into the table: \"educator_topics\""
    insert_educator_topics_one("the row to be inserted" object: educator_topics_insert_input!): educator_topics
    "insert data into the table: \"educators\""
    insert_educators("the rows to be inserted" objects: [educators_insert_input!]!): educators_mutation_response
    "insert a single row into the table: \"educators\""
    insert_educators_one("the row to be inserted" object: educators_insert_input!): educators
    "insert a single row into the table: \"enrollments\""
    insert_enrollment(
        "the row to be inserted"
        object: enrollments_insert_input!
        "on conflict condition"
        on_conflict: enrollments_on_conflict
    ): enrollments
    "insert data into the table: \"enrollment_sessions\""
    insert_enrollment_sessions(
        "the rows to be inserted"
        objects: [enrollment_sessions_insert_input!]!
        "on conflict condition"
        on_conflict: enrollment_sessions_on_conflict
    ): enrollment_sessions_mutation_response
    "insert a single row into the table: \"enrollment_sessions\""
    insert_enrollment_sessions_one(
        "the row to be inserted"
        object: enrollment_sessions_insert_input!
        "on conflict condition"
        on_conflict: enrollment_sessions_on_conflict
    ): enrollment_sessions
    "insert data into the table: \"enrollments\""
    insert_enrollments(
        "the rows to be inserted"
        objects: [enrollments_insert_input!]!
        "on conflict condition"
        on_conflict: enrollments_on_conflict
    ): enrollments_mutation_response
    "insert a single row into the table: \"orders\""
    insert_order(
        "the row to be inserted"
        object: orders_insert_input!
        "on conflict condition"
        on_conflict: orders_on_conflict
    ): orders
    "insert data into the table: \"orderable_entities\""
    insert_orderable_entities(
        "the rows to be inserted"
        objects: [orderable_entities_insert_input!]!
        "on conflict condition"
        on_conflict: orderable_entities_on_conflict
    ): orderable_entities_mutation_response
    "insert a single row into the table: \"orderable_entities\""
    insert_orderable_entities_one(
        "the row to be inserted"
        object: orderable_entities_insert_input!
        "on conflict condition"
        on_conflict: orderable_entities_on_conflict
    ): orderable_entities
    "insert data into the table: \"orders\""
    insert_orders(
        "the rows to be inserted"
        objects: [orders_insert_input!]!
        "on conflict condition"
        on_conflict: orders_on_conflict
    ): orders_mutation_response
    "insert data into the table: \"organization\""
    insert_organization(
        "the rows to be inserted"
        objects: [organization_insert_input!]!
        "on conflict condition"
        on_conflict: organization_on_conflict
    ): organization_mutation_response
    "insert a single row into the table: \"organization\""
    insert_organization_one(
        "the row to be inserted"
        object: organization_insert_input!
        "on conflict condition"
        on_conflict: organization_on_conflict
    ): organization
    "insert a single row into the table: \"products\""
    insert_product(
        "the row to be inserted"
        object: products_insert_input!
        "on conflict condition"
        on_conflict: products_on_conflict
    ): products
    "insert a single row into the table: \"product_prices\""
    insert_product_price(
        "the row to be inserted"
        object: product_prices_insert_input!
        "on conflict condition"
        on_conflict: product_prices_on_conflict
    ): product_prices
    "insert data into the table: \"product_prices\""
    insert_product_prices(
        "the rows to be inserted"
        objects: [product_prices_insert_input!]!
        "on conflict condition"
        on_conflict: product_prices_on_conflict
    ): product_prices_mutation_response
    "insert data into the table: \"products\""
    insert_products(
        "the rows to be inserted"
        objects: [products_insert_input!]!
        "on conflict condition"
        on_conflict: products_on_conflict
    ): products_mutation_response
    "insert a single row into the table: \"promo_codes\""
    insert_promo_code(
        "the row to be inserted"
        object: promo_codes_insert_input!
        "on conflict condition"
        on_conflict: promo_codes_on_conflict
    ): promo_codes
    "insert data into the table: \"promo_codes\""
    insert_promo_codes(
        "the rows to be inserted"
        objects: [promo_codes_insert_input!]!
        "on conflict condition"
        on_conflict: promo_codes_on_conflict
    ): promo_codes_mutation_response
    "insert data into the table: \"redirect_mappings\""
    insert_redirect_mappings(
        "the rows to be inserted"
        objects: [redirect_mappings_insert_input!]!
        "on conflict condition"
        on_conflict: redirect_mappings_on_conflict
    ): redirect_mappings_mutation_response
    "insert a single row into the table: \"redirect_mappings\""
    insert_redirect_mappings_one(
        "the row to be inserted"
        object: redirect_mappings_insert_input!
        "on conflict condition"
        on_conflict: redirect_mappings_on_conflict
    ): redirect_mappings
    "insert data into the table: \"resource_types\""
    insert_resource_types(
        "the rows to be inserted"
        objects: [resource_types_insert_input!]!
        "on conflict condition"
        on_conflict: resource_types_on_conflict
    ): resource_types_mutation_response
    "insert a single row into the table: \"resource_types\""
    insert_resource_types_one(
        "the row to be inserted"
        object: resource_types_insert_input!
        "on conflict condition"
        on_conflict: resource_types_on_conflict
    ): resource_types
    "insert a single row into the table: \"sessions\""
    insert_session(
        "the row to be inserted"
        object: sessions_insert_input!
        "on conflict condition"
        on_conflict: sessions_on_conflict
    ): sessions
    "insert data into the table: \"sessions\""
    insert_sessions(
        "the rows to be inserted"
        objects: [sessions_insert_input!]!
        "on conflict condition"
        on_conflict: sessions_on_conflict
    ): sessions_mutation_response
    "insert a single row into the table: \"stripe_customers\""
    insert_stripe_customer(
        "the row to be inserted"
        object: stripe_customers_insert_input!
        "on conflict condition"
        on_conflict: stripe_customers_on_conflict
    ): stripe_customers
    "insert data into the table: \"stripe_customers\""
    insert_stripe_customers(
        "the rows to be inserted"
        objects: [stripe_customers_insert_input!]!
        "on conflict condition"
        on_conflict: stripe_customers_on_conflict
    ): stripe_customers_mutation_response
    "insert a single row into the table: \"subscriptions\""
    insert_subscription(
        "the row to be inserted"
        object: subscriptions_insert_input!
        "on conflict condition"
        on_conflict: subscriptions_on_conflict
    ): subscriptions
    "insert data into the table: \"subscription_status\""
    insert_subscription_status(
        "the rows to be inserted"
        objects: [subscription_status_insert_input!]!
        "on conflict condition"
        on_conflict: subscription_status_on_conflict
    ): subscription_status_mutation_response
    "insert a single row into the table: \"subscription_status\""
    insert_subscription_status_one(
        "the row to be inserted"
        object: subscription_status_insert_input!
        "on conflict condition"
        on_conflict: subscription_status_on_conflict
    ): subscription_status
    "insert data into the table: \"subscriptions\""
    insert_subscriptions(
        "the rows to be inserted"
        objects: [subscriptions_insert_input!]!
        "on conflict condition"
        on_conflict: subscriptions_on_conflict
    ): subscriptions_mutation_response
    "insert a single row into the table: \"teaching_styles\""
    insert_teaching_style(
        "the row to be inserted"
        object: teaching_styles_insert_input!
        "on conflict condition"
        on_conflict: teaching_styles_on_conflict
    ): teaching_styles
    "insert data into the table: \"teaching_styles\""
    insert_teaching_styles(
        "the rows to be inserted"
        objects: [teaching_styles_insert_input!]!
        "on conflict condition"
        on_conflict: teaching_styles_on_conflict
    ): teaching_styles_mutation_response
    "insert a single row into the table: \"topics\""
    insert_topic(
        "the row to be inserted"
        object: topics_insert_input!
        "on conflict condition"
        on_conflict: topics_on_conflict
    ): topics
    "insert data into the table: \"topics\""
    insert_topics(
        "the rows to be inserted"
        objects: [topics_insert_input!]!
        "on conflict condition"
        on_conflict: topics_on_conflict
    ): topics_mutation_response
    "insert data into the table: \"update_entity_order_request\""
    insert_update_entity_order_request(
        "the rows to be inserted"
        objects: [update_entity_order_request_insert_input!]!
        "on conflict condition"
        on_conflict: update_entity_order_request_on_conflict
    ): update_entity_order_request_mutation_response
    "insert a single row into the table: \"update_entity_order_request\""
    insert_update_entity_order_request_one(
        "the row to be inserted"
        object: update_entity_order_request_insert_input!
        "on conflict condition"
        on_conflict: update_entity_order_request_on_conflict
    ): update_entity_order_request
    "insert a single row into the table: \"uploads\""
    insert_upload(
        "the row to be inserted"
        object: uploads_insert_input!
        "on conflict condition"
        on_conflict: uploads_on_conflict
    ): uploads
    "insert data into the table: \"uploads\""
    insert_uploads(
        "the rows to be inserted"
        objects: [uploads_insert_input!]!
        "on conflict condition"
        on_conflict: uploads_on_conflict
    ): uploads_mutation_response
    "insert a single row into the table: \"user_class_preferences\""
    insert_use_class_preference(
        "the row to be inserted"
        object: user_class_preferences_insert_input!
        "on conflict condition"
        on_conflict: user_class_preferences_on_conflict
    ): user_class_preferences
    "insert a single row into the table: \"users\""
    insert_user(
        "the row to be inserted"
        object: users_insert_input!
        "on conflict condition"
        on_conflict: users_on_conflict
    ): users
    "insert data into the table: \"user_class_preferences\""
    insert_user_class_preferences(
        "the rows to be inserted"
        objects: [user_class_preferences_insert_input!]!
        "on conflict condition"
        on_conflict: user_class_preferences_on_conflict
    ): user_class_preferences_mutation_response
    "insert data into the table: \"user_details\""
    insert_user_details(
        "the rows to be inserted"
        objects: [user_details_insert_input!]!
    ): user_details_mutation_response
    "insert a single row into the table: \"user_details\""
    insert_user_details_one("the row to be inserted" object: user_details_insert_input!): user_details
    "insert data into the table: \"user_roles\""
    insert_user_roles(
        "the rows to be inserted"
        objects: [user_roles_insert_input!]!
        "on conflict condition"
        on_conflict: user_roles_on_conflict
    ): user_roles_mutation_response
    "insert a single row into the table: \"user_roles\""
    insert_user_roles_one(
        "the row to be inserted"
        object: user_roles_insert_input!
        "on conflict condition"
        on_conflict: user_roles_on_conflict
    ): user_roles
    "insert a single row into the table: \"user_teaching_style_preferences\""
    insert_user_teaching_style_preference(
        "the row to be inserted"
        object: user_teaching_style_preferences_insert_input!
        "on conflict condition"
        on_conflict: user_teaching_style_preferences_on_conflict
    ): user_teaching_style_preferences
    "insert data into the table: \"user_teaching_style_preferences\""
    insert_user_teaching_style_preferences(
        "the rows to be inserted"
        objects: [user_teaching_style_preferences_insert_input!]!
        "on conflict condition"
        on_conflict: user_teaching_style_preferences_on_conflict
    ): user_teaching_style_preferences_mutation_response
    "insert data into the table: \"users\""
    insert_users(
        "the rows to be inserted"
        objects: [users_insert_input!]!
        "on conflict condition"
        on_conflict: users_on_conflict
    ): users_mutation_response
    purchasePlan(planId: String!, promoCode: String): String!
    "retryPayment"
    retryPayment: RetryPaymentOutput
    "Allows a user to signup"
    signUp(input: SignupInput!): SignupOutput
    updatePaymentInfo(paymentMethodId: String, remove: Boolean): PaymentMethod
    "update single row of the table: \"class_tags\""
    update_class_tag(
        "sets the columns of the filtered rows to the given values"
        _set: class_tags_set_input
        pk_columns: class_tags_pk_columns_input!
    ): class_tags
    "update data of the table: \"class_tags\""
    update_class_tags(
        "sets the columns of the filtered rows to the given values"
        _set: class_tags_set_input
        "filter the rows which have to be updated"
        where: class_tags_bool_exp!
    ): class_tags_mutation_response
    "update single row of the table: \"collections\""
    update_collection(
        "sets the columns of the filtered rows to the given values"
        _set: collections_set_input
        pk_columns: collections_pk_columns_input!
    ): collections
    "update single row of the table: \"collection_courses\""
    update_collection_course(
        "increments the numeric columns with given value of the filtered values"
        _inc: collection_courses_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: collection_courses_set_input
        pk_columns: collection_courses_pk_columns_input!
    ): collection_courses
    "update data of the table: \"collection_courses\""
    update_collection_courses(
        "increments the numeric columns with given value of the filtered values"
        _inc: collection_courses_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: collection_courses_set_input
        "filter the rows which have to be updated"
        where: collection_courses_bool_exp!
    ): collection_courses_mutation_response
    "update data of the table: \"collections\""
    update_collections(
        "sets the columns of the filtered rows to the given values"
        _set: collections_set_input
        "filter the rows which have to be updated"
        where: collections_bool_exp!
    ): collections_mutation_response
    "update data of the table: \"config_types\""
    update_config_types(
        "sets the columns of the filtered rows to the given values"
        _set: config_types_set_input
        "filter the rows which have to be updated"
        where: config_types_bool_exp!
    ): config_types_mutation_response
    "update single row of the table: \"config_types\""
    update_config_types_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: config_types_set_input
        pk_columns: config_types_pk_columns_input!
    ): config_types
    "update single row of the table: \"config_values\""
    update_config_value(
        "sets the columns of the filtered rows to the given values"
        _set: config_values_set_input
        pk_columns: config_values_pk_columns_input!
    ): config_values
    "update data of the table: \"config_values\""
    update_config_values(
        "sets the columns of the filtered rows to the given values"
        _set: config_values_set_input
        "filter the rows which have to be updated"
        where: config_values_bool_exp!
    ): config_values_mutation_response
    "update single row of the table: \"coupons\""
    update_coupon(
        "increments the numeric columns with given value of the filtered values"
        _inc: coupons_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: coupons_set_input
        pk_columns: coupons_pk_columns_input!
    ): coupons
    "update data of the table: \"coupons\""
    update_coupons(
        "increments the numeric columns with given value of the filtered values"
        _inc: coupons_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: coupons_set_input
        "filter the rows which have to be updated"
        where: coupons_bool_exp!
    ): coupons_mutation_response
    "update single row of the table: \"courses\""
    update_course(
        "increments the numeric columns with given value of the filtered values"
        _inc: courses_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: courses_set_input
        pk_columns: courses_pk_columns_input!
    ): courses
    "update single row of the table: \"course_resources\""
    update_course_resource(
        "sets the columns of the filtered rows to the given values"
        _set: course_resources_set_input
        pk_columns: course_resources_pk_columns_input!
    ): course_resources
    "update data of the table: \"course_resources\""
    update_course_resources(
        "sets the columns of the filtered rows to the given values"
        _set: course_resources_set_input
        "filter the rows which have to be updated"
        where: course_resources_bool_exp!
    ): course_resources_mutation_response
    "update single row of the table: \"course_tags\""
    update_course_tag(
        "sets the columns of the filtered rows to the given values"
        _set: course_tags_set_input
        pk_columns: course_tags_pk_columns_input!
    ): course_tags
    "update data of the table: \"course_tags\""
    update_course_tags(
        "sets the columns of the filtered rows to the given values"
        _set: course_tags_set_input
        "filter the rows which have to be updated"
        where: course_tags_bool_exp!
    ): course_tags_mutation_response
    "update data of the table: \"course_types\""
    update_course_types(
        "sets the columns of the filtered rows to the given values"
        _set: course_types_set_input
        "filter the rows which have to be updated"
        where: course_types_bool_exp!
    ): course_types_mutation_response
    "update single row of the table: \"course_types\""
    update_course_types_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: course_types_set_input
        pk_columns: course_types_pk_columns_input!
    ): course_types
    "update data of the table: \"courses\""
    update_courses(
        "increments the numeric columns with given value of the filtered values"
        _inc: courses_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: courses_set_input
        "filter the rows which have to be updated"
        where: courses_bool_exp!
    ): courses_mutation_response
    "update single row of the table: \"educator_books\""
    update_educator_book(
        "increments the numeric columns with given value of the filtered values"
        _inc: educator_books_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: educator_books_set_input
        pk_columns: educator_books_pk_columns_input!
    ): educator_books
    "update data of the table: \"educator_books\""
    update_educator_books(
        "increments the numeric columns with given value of the filtered values"
        _inc: educator_books_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: educator_books_set_input
        "filter the rows which have to be updated"
        where: educator_books_bool_exp!
    ): educator_books_mutation_response
    "update single row of the table: \"educator_educations\""
    update_educator_education(
        "increments the numeric columns with given value of the filtered values"
        _inc: educator_educations_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: educator_educations_set_input
        pk_columns: educator_educations_pk_columns_input!
    ): educator_educations
    "update data of the table: \"educator_educations\""
    update_educator_educations(
        "increments the numeric columns with given value of the filtered values"
        _inc: educator_educations_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: educator_educations_set_input
        "filter the rows which have to be updated"
        where: educator_educations_bool_exp!
    ): educator_educations_mutation_response
    "update single row of the table: \"educator_profiles\""
    update_educator_profile(
        "sets the columns of the filtered rows to the given values"
        _set: educator_profiles_set_input
        pk_columns: educator_profiles_pk_columns_input!
    ): educator_profiles
    "update data of the table: \"educator_profiles\""
    update_educator_profiles(
        "sets the columns of the filtered rows to the given values"
        _set: educator_profiles_set_input
        "filter the rows which have to be updated"
        where: educator_profiles_bool_exp!
    ): educator_profiles_mutation_response
    "update single row of the table: \"educator_publications\""
    update_educator_publication(
        "increments the numeric columns with given value of the filtered values"
        _inc: educator_publications_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: educator_publications_set_input
        pk_columns: educator_publications_pk_columns_input!
    ): educator_publications
    "update data of the table: \"educator_publications\""
    update_educator_publications(
        "increments the numeric columns with given value of the filtered values"
        _inc: educator_publications_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: educator_publications_set_input
        "filter the rows which have to be updated"
        where: educator_publications_bool_exp!
    ): educator_publications_mutation_response
    "update single row of the table: \"educator_teaching_styles\""
    update_educator_teaching_style(
        "sets the columns of the filtered rows to the given values"
        _set: educator_teaching_styles_set_input
        pk_columns: educator_teaching_styles_pk_columns_input!
    ): educator_teaching_styles
    "update data of the table: \"educator_teaching_styles\""
    update_educator_teaching_styles(
        "sets the columns of the filtered rows to the given values"
        _set: educator_teaching_styles_set_input
        "filter the rows which have to be updated"
        where: educator_teaching_styles_bool_exp!
    ): educator_teaching_styles_mutation_response
    "update single row of the table: \"educator_testimonials\""
    update_educator_testimonial(
        "increments the numeric columns with given value of the filtered values"
        _inc: educator_testimonials_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: educator_testimonials_set_input
        pk_columns: educator_testimonials_pk_columns_input!
    ): educator_testimonials
    "update data of the table: \"educator_testimonials\""
    update_educator_testimonials(
        "increments the numeric columns with given value of the filtered values"
        _inc: educator_testimonials_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: educator_testimonials_set_input
        "filter the rows which have to be updated"
        where: educator_testimonials_bool_exp!
    ): educator_testimonials_mutation_response
    "update data of the table: \"educator_topics\""
    update_educator_topics(
        "increments the numeric columns with given value of the filtered values"
        _inc: educator_topics_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: educator_topics_set_input
        "filter the rows which have to be updated"
        where: educator_topics_bool_exp!
    ): educator_topics_mutation_response
    "update data of the table: \"educators\""
    update_educators(
        "sets the columns of the filtered rows to the given values"
        _set: educators_set_input
        "filter the rows which have to be updated"
        where: educators_bool_exp!
    ): educators_mutation_response
    "update single row of the table: \"enrollments\""
    update_enrollment(
        "sets the columns of the filtered rows to the given values"
        _set: enrollments_set_input
        pk_columns: enrollments_pk_columns_input!
    ): enrollments
    "update data of the table: \"enrollment_sessions\""
    update_enrollment_sessions(
        "sets the columns of the filtered rows to the given values"
        _set: enrollment_sessions_set_input
        "filter the rows which have to be updated"
        where: enrollment_sessions_bool_exp!
    ): enrollment_sessions_mutation_response
    "update single row of the table: \"enrollment_sessions\""
    update_enrollment_sessions_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: enrollment_sessions_set_input
        pk_columns: enrollment_sessions_pk_columns_input!
    ): enrollment_sessions
    "update data of the table: \"enrollments\""
    update_enrollments(
        "sets the columns of the filtered rows to the given values"
        _set: enrollments_set_input
        "filter the rows which have to be updated"
        where: enrollments_bool_exp!
    ): enrollments_mutation_response
    "execute VOLATILE function \"update_entity_order\" which returns \"update_entity_order_request\""
    update_entity_order(
        "input parameters for function \"update_entity_order\""
        args: update_entity_order_args!
        "distinct select on columns"
        distinct_on: [update_entity_order_request_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [update_entity_order_request_order_by!]
        "filter the rows returned"
        where: update_entity_order_request_bool_exp
    ): [update_entity_order_request!]!
    "update single row of the table: \"orders\""
    update_order(
        "increments the numeric columns with given value of the filtered values"
        _inc: orders_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: orders_set_input
        pk_columns: orders_pk_columns_input!
    ): orders
    "update data of the table: \"orderable_entities\""
    update_orderable_entities(
        "sets the columns of the filtered rows to the given values"
        _set: orderable_entities_set_input
        "filter the rows which have to be updated"
        where: orderable_entities_bool_exp!
    ): orderable_entities_mutation_response
    "update single row of the table: \"orderable_entities\""
    update_orderable_entities_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: orderable_entities_set_input
        pk_columns: orderable_entities_pk_columns_input!
    ): orderable_entities
    "update data of the table: \"orders\""
    update_orders(
        "increments the numeric columns with given value of the filtered values"
        _inc: orders_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: orders_set_input
        "filter the rows which have to be updated"
        where: orders_bool_exp!
    ): orders_mutation_response
    "update data of the table: \"organization\""
    update_organization(
        "sets the columns of the filtered rows to the given values"
        _set: organization_set_input
        "filter the rows which have to be updated"
        where: organization_bool_exp!
    ): organization_mutation_response
    "update single row of the table: \"organization\""
    update_organization_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: organization_set_input
        pk_columns: organization_pk_columns_input!
    ): organization
    "update single row of the table: \"products\""
    update_product(
        "sets the columns of the filtered rows to the given values"
        _set: products_set_input
        pk_columns: products_pk_columns_input!
    ): products
    "update single row of the table: \"product_prices\""
    update_product_price(
        "increments the numeric columns with given value of the filtered values"
        _inc: product_prices_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: product_prices_set_input
        pk_columns: product_prices_pk_columns_input!
    ): product_prices
    "update data of the table: \"product_prices\""
    update_product_prices(
        "increments the numeric columns with given value of the filtered values"
        _inc: product_prices_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: product_prices_set_input
        "filter the rows which have to be updated"
        where: product_prices_bool_exp!
    ): product_prices_mutation_response
    "update data of the table: \"products\""
    update_products(
        "sets the columns of the filtered rows to the given values"
        _set: products_set_input
        "filter the rows which have to be updated"
        where: products_bool_exp!
    ): products_mutation_response
    "update single row of the table: \"promo_codes\""
    update_promo_code(
        "sets the columns of the filtered rows to the given values"
        _set: promo_codes_set_input
        pk_columns: promo_codes_pk_columns_input!
    ): promo_codes
    "update data of the table: \"promo_codes\""
    update_promo_codes(
        "sets the columns of the filtered rows to the given values"
        _set: promo_codes_set_input
        "filter the rows which have to be updated"
        where: promo_codes_bool_exp!
    ): promo_codes_mutation_response
    "update data of the table: \"redirect_mappings\""
    update_redirect_mappings(
        "increments the numeric columns with given value of the filtered values"
        _inc: redirect_mappings_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: redirect_mappings_set_input
        "filter the rows which have to be updated"
        where: redirect_mappings_bool_exp!
    ): redirect_mappings_mutation_response
    "update single row of the table: \"redirect_mappings\""
    update_redirect_mappings_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: redirect_mappings_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: redirect_mappings_set_input
        pk_columns: redirect_mappings_pk_columns_input!
    ): redirect_mappings
    "update data of the table: \"resource_types\""
    update_resource_types(
        "sets the columns of the filtered rows to the given values"
        _set: resource_types_set_input
        "filter the rows which have to be updated"
        where: resource_types_bool_exp!
    ): resource_types_mutation_response
    "update single row of the table: \"resource_types\""
    update_resource_types_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: resource_types_set_input
        pk_columns: resource_types_pk_columns_input!
    ): resource_types
    "update single row of the table: \"sessions\""
    update_session(
        "sets the columns of the filtered rows to the given values"
        _set: sessions_set_input
        pk_columns: sessions_pk_columns_input!
    ): sessions
    "update data of the table: \"sessions\""
    update_sessions(
        "sets the columns of the filtered rows to the given values"
        _set: sessions_set_input
        "filter the rows which have to be updated"
        where: sessions_bool_exp!
    ): sessions_mutation_response
    "update single row of the table: \"stripe_customers\""
    update_stripe_customer(
        "sets the columns of the filtered rows to the given values"
        _set: stripe_customers_set_input
        pk_columns: stripe_customers_pk_columns_input!
    ): stripe_customers
    "update data of the table: \"stripe_customers\""
    update_stripe_customers(
        "sets the columns of the filtered rows to the given values"
        _set: stripe_customers_set_input
        "filter the rows which have to be updated"
        where: stripe_customers_bool_exp!
    ): stripe_customers_mutation_response
    "update single row of the table: \"subscriptions\""
    update_subscription(
        "sets the columns of the filtered rows to the given values"
        _set: subscriptions_set_input
        pk_columns: subscriptions_pk_columns_input!
    ): subscriptions
    "update data of the table: \"subscription_status\""
    update_subscription_status(
        "sets the columns of the filtered rows to the given values"
        _set: subscription_status_set_input
        "filter the rows which have to be updated"
        where: subscription_status_bool_exp!
    ): subscription_status_mutation_response
    "update single row of the table: \"subscription_status\""
    update_subscription_status_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: subscription_status_set_input
        pk_columns: subscription_status_pk_columns_input!
    ): subscription_status
    "update data of the table: \"subscriptions\""
    update_subscriptions(
        "sets the columns of the filtered rows to the given values"
        _set: subscriptions_set_input
        "filter the rows which have to be updated"
        where: subscriptions_bool_exp!
    ): subscriptions_mutation_response
    "update single row of the table: \"teaching_styles\""
    update_teaching_style(
        "sets the columns of the filtered rows to the given values"
        _set: teaching_styles_set_input
        pk_columns: teaching_styles_pk_columns_input!
    ): teaching_styles
    "update data of the table: \"teaching_styles\""
    update_teaching_styles(
        "sets the columns of the filtered rows to the given values"
        _set: teaching_styles_set_input
        "filter the rows which have to be updated"
        where: teaching_styles_bool_exp!
    ): teaching_styles_mutation_response
    "update single row of the table: \"topics\""
    update_topic(
        "increments the numeric columns with given value of the filtered values"
        _inc: topics_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: topics_set_input
        pk_columns: topics_pk_columns_input!
    ): topics
    "update data of the table: \"topics\""
    update_topics(
        "increments the numeric columns with given value of the filtered values"
        _inc: topics_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: topics_set_input
        "filter the rows which have to be updated"
        where: topics_bool_exp!
    ): topics_mutation_response
    "update data of the table: \"update_entity_order_request\""
    update_update_entity_order_request(
        "increments the numeric columns with given value of the filtered values"
        _inc: update_entity_order_request_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: update_entity_order_request_set_input
        "filter the rows which have to be updated"
        where: update_entity_order_request_bool_exp!
    ): update_entity_order_request_mutation_response
    "update single row of the table: \"update_entity_order_request\""
    update_update_entity_order_request_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: update_entity_order_request_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: update_entity_order_request_set_input
        pk_columns: update_entity_order_request_pk_columns_input!
    ): update_entity_order_request
    "update single row of the table: \"uploads\""
    update_upload(
        "increments the numeric columns with given value of the filtered values"
        _inc: uploads_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: uploads_set_input
        pk_columns: uploads_pk_columns_input!
    ): uploads
    "update data of the table: \"uploads\""
    update_uploads(
        "increments the numeric columns with given value of the filtered values"
        _inc: uploads_inc_input
        "sets the columns of the filtered rows to the given values"
        _set: uploads_set_input
        "filter the rows which have to be updated"
        where: uploads_bool_exp!
    ): uploads_mutation_response
    "update single row of the table: \"user_class_preferences\""
    update_use_class_preference(
        "sets the columns of the filtered rows to the given values"
        _set: user_class_preferences_set_input
        pk_columns: user_class_preferences_pk_columns_input!
    ): user_class_preferences
    "update single row of the table: \"users\""
    update_user(
        "sets the columns of the filtered rows to the given values"
        _set: users_set_input
        pk_columns: users_pk_columns_input!
    ): users
    "update data of the table: \"user_class_preferences\""
    update_user_class_preferences(
        "sets the columns of the filtered rows to the given values"
        _set: user_class_preferences_set_input
        "filter the rows which have to be updated"
        where: user_class_preferences_bool_exp!
    ): user_class_preferences_mutation_response
    "update data of the table: \"user_details\""
    update_user_details(
        "sets the columns of the filtered rows to the given values"
        _set: user_details_set_input
        "filter the rows which have to be updated"
        where: user_details_bool_exp!
    ): user_details_mutation_response
    "update data of the table: \"user_roles\""
    update_user_roles(
        "sets the columns of the filtered rows to the given values"
        _set: user_roles_set_input
        "filter the rows which have to be updated"
        where: user_roles_bool_exp!
    ): user_roles_mutation_response
    "update single row of the table: \"user_roles\""
    update_user_roles_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: user_roles_set_input
        pk_columns: user_roles_pk_columns_input!
    ): user_roles
    "update single row of the table: \"user_teaching_style_preferences\""
    update_user_teaching_style_preference(
        "sets the columns of the filtered rows to the given values"
        _set: user_teaching_style_preferences_set_input
        pk_columns: user_teaching_style_preferences_pk_columns_input!
    ): user_teaching_style_preferences
    "update data of the table: \"user_teaching_style_preferences\""
    update_user_teaching_style_preferences(
        "sets the columns of the filtered rows to the given values"
        _set: user_teaching_style_preferences_set_input
        "filter the rows which have to be updated"
        where: user_teaching_style_preferences_bool_exp!
    ): user_teaching_style_preferences_mutation_response
    "update data of the table: \"users\""
    update_users(
        "sets the columns of the filtered rows to the given values"
        _set: users_set_input
        "filter the rows which have to be updated"
        where: users_bool_exp!
    ): users_mutation_response
}

"columns and relationships of \"my_enrolled_sessions\""
type my_enrolled_sessions {
    enrollment_id: uuid
    session_id: uuid
    user_id: uuid
}

"aggregated selection of \"my_enrolled_sessions\""
type my_enrolled_sessions_aggregate {
    aggregate: my_enrolled_sessions_aggregate_fields
    nodes: [my_enrolled_sessions!]!
}

"aggregate fields of \"my_enrolled_sessions\""
type my_enrolled_sessions_aggregate_fields {
    count(columns: [my_enrolled_sessions_select_column!], distinct: Boolean): Int!
    max: my_enrolled_sessions_max_fields
    min: my_enrolled_sessions_min_fields
}

"aggregate max on columns"
type my_enrolled_sessions_max_fields {
    enrollment_id: uuid
    session_id: uuid
    user_id: uuid
}

"aggregate min on columns"
type my_enrolled_sessions_min_fields {
    enrollment_id: uuid
    session_id: uuid
    user_id: uuid
}

"columns and relationships of \"orderable_entities\""
type orderable_entities {
    description: String!
    value: String!
}

"aggregated selection of \"orderable_entities\""
type orderable_entities_aggregate {
    aggregate: orderable_entities_aggregate_fields
    nodes: [orderable_entities!]!
}

"aggregate fields of \"orderable_entities\""
type orderable_entities_aggregate_fields {
    count(columns: [orderable_entities_select_column!], distinct: Boolean): Int!
    max: orderable_entities_max_fields
    min: orderable_entities_min_fields
}

"aggregate max on columns"
type orderable_entities_max_fields {
    description: String
    value: String
}

"aggregate min on columns"
type orderable_entities_min_fields {
    description: String
    value: String
}

"response of any mutation on the table \"orderable_entities\""
type orderable_entities_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [orderable_entities!]!
}

"columns and relationships of \"orders\""
type orders {
    amount: numeric!
    createdAt: timestamptz!
    "An object relationship"
    enrollment: enrollments!
    enrollmentId: uuid!
    id: uuid!
    lastKnownEvent: String!
    "An object relationship"
    promoCode: promo_codes
    promoId: String
    stripeInvoiceId: String
    stripeUrl: String
    "An object relationship"
    user: users!
    userId: uuid!
    withSubscription: Boolean!
}

"aggregated selection of \"orders\""
type orders_aggregate {
    aggregate: orders_aggregate_fields
    nodes: [orders!]!
}

"aggregate fields of \"orders\""
type orders_aggregate_fields {
    avg: orders_avg_fields
    count(columns: [orders_select_column!], distinct: Boolean): Int!
    max: orders_max_fields
    min: orders_min_fields
    stddev: orders_stddev_fields
    stddev_pop: orders_stddev_pop_fields
    stddev_samp: orders_stddev_samp_fields
    sum: orders_sum_fields
    var_pop: orders_var_pop_fields
    var_samp: orders_var_samp_fields
    variance: orders_variance_fields
}

"aggregate avg on columns"
type orders_avg_fields {
    amount: Float
}

"aggregate max on columns"
type orders_max_fields {
    amount: numeric
    createdAt: timestamptz
    enrollmentId: uuid
    id: uuid
    lastKnownEvent: String
    promoId: String
    stripeInvoiceId: String
    stripeUrl: String
    userId: uuid
}

"aggregate min on columns"
type orders_min_fields {
    amount: numeric
    createdAt: timestamptz
    enrollmentId: uuid
    id: uuid
    lastKnownEvent: String
    promoId: String
    stripeInvoiceId: String
    stripeUrl: String
    userId: uuid
}

"response of any mutation on the table \"orders\""
type orders_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [orders!]!
}

"aggregate stddev on columns"
type orders_stddev_fields {
    amount: Float
}

"aggregate stddev_pop on columns"
type orders_stddev_pop_fields {
    amount: Float
}

"aggregate stddev_samp on columns"
type orders_stddev_samp_fields {
    amount: Float
}

"aggregate sum on columns"
type orders_sum_fields {
    amount: numeric
}

"aggregate var_pop on columns"
type orders_var_pop_fields {
    amount: Float
}

"aggregate var_samp on columns"
type orders_var_samp_fields {
    amount: Float
}

"aggregate variance on columns"
type orders_variance_fields {
    amount: Float
}

"columns and relationships of \"organization\""
type organization {
    id: uuid!
    name: String!
}

"aggregated selection of \"organization\""
type organization_aggregate {
    aggregate: organization_aggregate_fields
    nodes: [organization!]!
}

"aggregate fields of \"organization\""
type organization_aggregate_fields {
    count(columns: [organization_select_column!], distinct: Boolean): Int!
    max: organization_max_fields
    min: organization_min_fields
}

"aggregate max on columns"
type organization_max_fields {
    id: uuid
    name: String
}

"aggregate min on columns"
type organization_min_fields {
    id: uuid
    name: String
}

"response of any mutation on the table \"organization\""
type organization_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [organization!]!
}

"columns and relationships of \"product_prices\""
type product_prices {
    active: Boolean!
    amount: Int!
    id: String!
    "An object relationship"
    product: products!
    productId: String!
    stripeObject("JSON select path" path: String): json!
}

"aggregated selection of \"product_prices\""
type product_prices_aggregate {
    aggregate: product_prices_aggregate_fields
    nodes: [product_prices!]!
}

"aggregate fields of \"product_prices\""
type product_prices_aggregate_fields {
    avg: product_prices_avg_fields
    count(columns: [product_prices_select_column!], distinct: Boolean): Int!
    max: product_prices_max_fields
    min: product_prices_min_fields
    stddev: product_prices_stddev_fields
    stddev_pop: product_prices_stddev_pop_fields
    stddev_samp: product_prices_stddev_samp_fields
    sum: product_prices_sum_fields
    var_pop: product_prices_var_pop_fields
    var_samp: product_prices_var_samp_fields
    variance: product_prices_variance_fields
}

"aggregate avg on columns"
type product_prices_avg_fields {
    amount: Float
}

"aggregate max on columns"
type product_prices_max_fields {
    amount: Int
    id: String
    productId: String
}

"aggregate min on columns"
type product_prices_min_fields {
    amount: Int
    id: String
    productId: String
}

"response of any mutation on the table \"product_prices\""
type product_prices_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [product_prices!]!
}

"aggregate stddev on columns"
type product_prices_stddev_fields {
    amount: Float
}

"aggregate stddev_pop on columns"
type product_prices_stddev_pop_fields {
    amount: Float
}

"aggregate stddev_samp on columns"
type product_prices_stddev_samp_fields {
    amount: Float
}

"aggregate sum on columns"
type product_prices_sum_fields {
    amount: Int
}

"aggregate var_pop on columns"
type product_prices_var_pop_fields {
    amount: Float
}

"aggregate var_samp on columns"
type product_prices_var_samp_fields {
    amount: Float
}

"aggregate variance on columns"
type product_prices_variance_fields {
    amount: Float
}

"columns and relationships of \"products\""
type products {
    id: String!
    name: String!
    "An array relationship"
    prices(
        "distinct select on columns"
        distinct_on: [product_prices_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [product_prices_order_by!]
        "filter the rows returned"
        where: product_prices_bool_exp
    ): [product_prices!]!
    "An aggregate relationship"
    prices_aggregate(
        "distinct select on columns"
        distinct_on: [product_prices_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [product_prices_order_by!]
        "filter the rows returned"
        where: product_prices_bool_exp
    ): product_prices_aggregate!
    stripeObject("JSON select path" path: String): json!
}

"aggregated selection of \"products\""
type products_aggregate {
    aggregate: products_aggregate_fields
    nodes: [products!]!
}

"aggregate fields of \"products\""
type products_aggregate_fields {
    count(columns: [products_select_column!], distinct: Boolean): Int!
    max: products_max_fields
    min: products_min_fields
}

"aggregate max on columns"
type products_max_fields {
    id: String
    name: String
}

"aggregate min on columns"
type products_min_fields {
    id: String
    name: String
}

"response of any mutation on the table \"products\""
type products_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [products!]!
}

"columns and relationships of \"promo_codes\""
type promo_codes {
    active: Boolean!
    code: String!
    "An object relationship"
    coupon: coupons!
    couponId: String!
    id: String!
    stripeObject("JSON select path" path: String): json!
}

"aggregated selection of \"promo_codes\""
type promo_codes_aggregate {
    aggregate: promo_codes_aggregate_fields
    nodes: [promo_codes!]!
}

"aggregate fields of \"promo_codes\""
type promo_codes_aggregate_fields {
    count(columns: [promo_codes_select_column!], distinct: Boolean): Int!
    max: promo_codes_max_fields
    min: promo_codes_min_fields
}

"aggregate max on columns"
type promo_codes_max_fields {
    code: String
    couponId: String
    id: String
}

"aggregate min on columns"
type promo_codes_min_fields {
    code: String
    couponId: String
    id: String
}

"response of any mutation on the table \"promo_codes\""
type promo_codes_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [promo_codes!]!
}

type query_root {
    "fetch data from the table: \"class_tags\" using primary key columns"
    class_tag(value: String!): class_tags
    "fetch data from the table: \"class_tags\""
    class_tags(
        "distinct select on columns"
        distinct_on: [class_tags_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [class_tags_order_by!]
        "filter the rows returned"
        where: class_tags_bool_exp
    ): [class_tags!]!
    "fetch aggregated fields from the table: \"class_tags\""
    class_tags_aggregate(
        "distinct select on columns"
        distinct_on: [class_tags_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [class_tags_order_by!]
        "filter the rows returned"
        where: class_tags_bool_exp
    ): class_tags_aggregate!
    "fetch data from the table: \"collections\" using primary key columns"
    collection(id: uuid!): collections
    "execute function \"collection_by_slug\" which returns \"collections\""
    collection_by_slug(
        "input parameters for function \"collection_by_slug\""
        args: collection_by_slug_args!
        "distinct select on columns"
        distinct_on: [collections_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [collections_order_by!]
        "filter the rows returned"
        where: collections_bool_exp
    ): collections
    "execute function \"collection_by_slug\" and query aggregates on result of table type \"collections\""
    collection_by_slug_aggregate(
        "input parameters for function \"collection_by_slug_aggregate\""
        args: collection_by_slug_args!
        "distinct select on columns"
        distinct_on: [collections_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [collections_order_by!]
        "filter the rows returned"
        where: collections_bool_exp
    ): collections_aggregate!
    "fetch data from the table: \"collection_courses\" using primary key columns"
    collection_course(id: uuid!): collection_courses
    "An array relationship"
    collection_courses(
        "distinct select on columns"
        distinct_on: [collection_courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [collection_courses_order_by!]
        "filter the rows returned"
        where: collection_courses_bool_exp
    ): [collection_courses!]!
    "An aggregate relationship"
    collection_courses_aggregate(
        "distinct select on columns"
        distinct_on: [collection_courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [collection_courses_order_by!]
        "filter the rows returned"
        where: collection_courses_bool_exp
    ): collection_courses_aggregate!
    "fetch data from the table: \"collections\""
    collections(
        "distinct select on columns"
        distinct_on: [collections_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [collections_order_by!]
        "filter the rows returned"
        where: collections_bool_exp
    ): [collections!]!
    "fetch aggregated fields from the table: \"collections\""
    collections_aggregate(
        "distinct select on columns"
        distinct_on: [collections_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [collections_order_by!]
        "filter the rows returned"
        where: collections_bool_exp
    ): collections_aggregate!
    "fetch data from the table: \"config_types\""
    config_types(
        "distinct select on columns"
        distinct_on: [config_types_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [config_types_order_by!]
        "filter the rows returned"
        where: config_types_bool_exp
    ): [config_types!]!
    "fetch aggregated fields from the table: \"config_types\""
    config_types_aggregate(
        "distinct select on columns"
        distinct_on: [config_types_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [config_types_order_by!]
        "filter the rows returned"
        where: config_types_bool_exp
    ): config_types_aggregate!
    "fetch data from the table: \"config_types\" using primary key columns"
    config_types_by_pk(value: String!): config_types
    "fetch data from the table: \"config_values\" using primary key columns"
    config_value(configType: config_types_enum!): config_values
    "fetch data from the table: \"config_values\""
    config_values(
        "distinct select on columns"
        distinct_on: [config_values_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [config_values_order_by!]
        "filter the rows returned"
        where: config_values_bool_exp
    ): [config_values!]!
    "fetch aggregated fields from the table: \"config_values\""
    config_values_aggregate(
        "distinct select on columns"
        distinct_on: [config_values_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [config_values_order_by!]
        "filter the rows returned"
        where: config_values_bool_exp
    ): config_values_aggregate!
    "fetch data from the table: \"coupons\" using primary key columns"
    coupon(id: String!): coupons
    "fetch data from the table: \"coupons\""
    coupons(
        "distinct select on columns"
        distinct_on: [coupons_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [coupons_order_by!]
        "filter the rows returned"
        where: coupons_bool_exp
    ): [coupons!]!
    "fetch aggregated fields from the table: \"coupons\""
    coupons_aggregate(
        "distinct select on columns"
        distinct_on: [coupons_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [coupons_order_by!]
        "filter the rows returned"
        where: coupons_bool_exp
    ): coupons_aggregate!
    "fetch data from the table: \"courses\" using primary key columns"
    course(id: uuid!): courses
    "execute function \"course_by_slug\" which returns \"courses\""
    course_by_slug(
        "input parameters for function \"course_by_slug\""
        args: course_by_slug_args!
        "distinct select on columns"
        distinct_on: [courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_order_by!]
        "filter the rows returned"
        where: courses_bool_exp
    ): courses
    "execute function \"course_by_slug\" and query aggregates on result of table type \"courses\""
    course_by_slug_aggregate(
        "input parameters for function \"course_by_slug_aggregate\""
        args: course_by_slug_args!
        "distinct select on columns"
        distinct_on: [courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_order_by!]
        "filter the rows returned"
        where: courses_bool_exp
    ): courses_aggregate!
    "fetch data from the table: \"course_resources\" using primary key columns"
    course_resource(id: uuid!): course_resources
    "fetch data from the table: \"course_resources\""
    course_resources(
        "distinct select on columns"
        distinct_on: [course_resources_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [course_resources_order_by!]
        "filter the rows returned"
        where: course_resources_bool_exp
    ): [course_resources!]!
    "fetch aggregated fields from the table: \"course_resources\""
    course_resources_aggregate(
        "distinct select on columns"
        distinct_on: [course_resources_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [course_resources_order_by!]
        "filter the rows returned"
        where: course_resources_bool_exp
    ): course_resources_aggregate!
    "fetch data from the table: \"course_tags\" using primary key columns"
    course_tag(id: uuid!): course_tags
    "fetch data from the table: \"course_tags\""
    course_tags(
        "distinct select on columns"
        distinct_on: [course_tags_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [course_tags_order_by!]
        "filter the rows returned"
        where: course_tags_bool_exp
    ): [course_tags!]!
    "fetch aggregated fields from the table: \"course_tags\""
    course_tags_aggregate(
        "distinct select on columns"
        distinct_on: [course_tags_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [course_tags_order_by!]
        "filter the rows returned"
        where: course_tags_bool_exp
    ): course_tags_aggregate!
    "fetch data from the table: \"course_types\""
    course_types(
        "distinct select on columns"
        distinct_on: [course_types_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [course_types_order_by!]
        "filter the rows returned"
        where: course_types_bool_exp
    ): [course_types!]!
    "fetch aggregated fields from the table: \"course_types\""
    course_types_aggregate(
        "distinct select on columns"
        distinct_on: [course_types_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [course_types_order_by!]
        "filter the rows returned"
        where: course_types_bool_exp
    ): course_types_aggregate!
    "fetch data from the table: \"course_types\" using primary key columns"
    course_types_by_pk(value: String!): course_types
    "An array relationship"
    courses(
        "distinct select on columns"
        distinct_on: [courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_order_by!]
        "filter the rows returned"
        where: courses_bool_exp
    ): [courses!]!
    "An aggregate relationship"
    courses_aggregate(
        "distinct select on columns"
        distinct_on: [courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_order_by!]
        "filter the rows returned"
        where: courses_bool_exp
    ): courses_aggregate!
    "fetch data from the table: \"courses_for_collection_assignment\""
    courses_for_collection_assignment(
        "distinct select on columns"
        distinct_on: [courses_for_collection_assignment_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_for_collection_assignment_order_by!]
        "filter the rows returned"
        where: courses_for_collection_assignment_bool_exp
    ): [courses_for_collection_assignment!]!
    "fetch aggregated fields from the table: \"courses_for_collection_assignment\""
    courses_for_collection_assignment_aggregate(
        "distinct select on columns"
        distinct_on: [courses_for_collection_assignment_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_for_collection_assignment_order_by!]
        "filter the rows returned"
        where: courses_for_collection_assignment_bool_exp
    ): courses_for_collection_assignment_aggregate!
    "fetch data from the table: \"educator_books\" using primary key columns"
    educator_book(id: uuid!): educator_books
    "fetch data from the table: \"educator_books\""
    educator_books(
        "distinct select on columns"
        distinct_on: [educator_books_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_books_order_by!]
        "filter the rows returned"
        where: educator_books_bool_exp
    ): [educator_books!]!
    "fetch aggregated fields from the table: \"educator_books\""
    educator_books_aggregate(
        "distinct select on columns"
        distinct_on: [educator_books_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_books_order_by!]
        "filter the rows returned"
        where: educator_books_bool_exp
    ): educator_books_aggregate!
    "execute function \"educator_by_slug\" which returns \"educators\""
    educator_by_slug(
        "input parameters for function \"educator_by_slug\""
        args: educator_by_slug_args!
        "distinct select on columns"
        distinct_on: [educators_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educators_order_by!]
        "filter the rows returned"
        where: educators_bool_exp
    ): educators
    "execute function \"educator_by_slug\" and query aggregates on result of table type \"educators\""
    educator_by_slug_aggregate(
        "input parameters for function \"educator_by_slug_aggregate\""
        args: educator_by_slug_args!
        "distinct select on columns"
        distinct_on: [educators_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educators_order_by!]
        "filter the rows returned"
        where: educators_bool_exp
    ): educators_aggregate!
    "fetch data from the table: \"educator_educations\" using primary key columns"
    educator_education(id: uuid!): educator_educations
    "fetch data from the table: \"educator_educations\""
    educator_educations(
        "distinct select on columns"
        distinct_on: [educator_educations_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_educations_order_by!]
        "filter the rows returned"
        where: educator_educations_bool_exp
    ): [educator_educations!]!
    "fetch aggregated fields from the table: \"educator_educations\""
    educator_educations_aggregate(
        "distinct select on columns"
        distinct_on: [educator_educations_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_educations_order_by!]
        "filter the rows returned"
        where: educator_educations_bool_exp
    ): educator_educations_aggregate!
    "fetch data from the table: \"educator_profiles\" using primary key columns"
    educator_profile(educatorId: uuid!): educator_profiles
    "fetch data from the table: \"educator_profiles\""
    educator_profiles(
        "distinct select on columns"
        distinct_on: [educator_profiles_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_profiles_order_by!]
        "filter the rows returned"
        where: educator_profiles_bool_exp
    ): [educator_profiles!]!
    "fetch aggregated fields from the table: \"educator_profiles\""
    educator_profiles_aggregate(
        "distinct select on columns"
        distinct_on: [educator_profiles_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_profiles_order_by!]
        "filter the rows returned"
        where: educator_profiles_bool_exp
    ): educator_profiles_aggregate!
    "fetch data from the table: \"educator_publications\" using primary key columns"
    educator_publication(id: uuid!): educator_publications
    "fetch data from the table: \"educator_publications\""
    educator_publications(
        "distinct select on columns"
        distinct_on: [educator_publications_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_publications_order_by!]
        "filter the rows returned"
        where: educator_publications_bool_exp
    ): [educator_publications!]!
    "fetch aggregated fields from the table: \"educator_publications\""
    educator_publications_aggregate(
        "distinct select on columns"
        distinct_on: [educator_publications_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_publications_order_by!]
        "filter the rows returned"
        where: educator_publications_bool_exp
    ): educator_publications_aggregate!
    "fetch data from the table: \"educator_teaching_styles\" using primary key columns"
    educator_teaching_style(educatorId: uuid!, style: teaching_styles_enum!): educator_teaching_styles
    "fetch data from the table: \"educator_teaching_styles\""
    educator_teaching_styles(
        "distinct select on columns"
        distinct_on: [educator_teaching_styles_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_teaching_styles_order_by!]
        "filter the rows returned"
        where: educator_teaching_styles_bool_exp
    ): [educator_teaching_styles!]!
    "fetch aggregated fields from the table: \"educator_teaching_styles\""
    educator_teaching_styles_aggregate(
        "distinct select on columns"
        distinct_on: [educator_teaching_styles_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_teaching_styles_order_by!]
        "filter the rows returned"
        where: educator_teaching_styles_bool_exp
    ): educator_teaching_styles_aggregate!
    "fetch data from the table: \"educator_testimonials\" using primary key columns"
    educator_testimonial(id: uuid!): educator_testimonials
    "fetch data from the table: \"educator_testimonials\""
    educator_testimonials(
        "distinct select on columns"
        distinct_on: [educator_testimonials_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_testimonials_order_by!]
        "filter the rows returned"
        where: educator_testimonials_bool_exp
    ): [educator_testimonials!]!
    "fetch aggregated fields from the table: \"educator_testimonials\""
    educator_testimonials_aggregate(
        "distinct select on columns"
        distinct_on: [educator_testimonials_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_testimonials_order_by!]
        "filter the rows returned"
        where: educator_testimonials_bool_exp
    ): educator_testimonials_aggregate!
    "fetch data from the table: \"educator_topics\""
    educator_topics(
        "distinct select on columns"
        distinct_on: [educator_topics_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_topics_order_by!]
        "filter the rows returned"
        where: educator_topics_bool_exp
    ): [educator_topics!]!
    "fetch aggregated fields from the table: \"educator_topics\""
    educator_topics_aggregate(
        "distinct select on columns"
        distinct_on: [educator_topics_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_topics_order_by!]
        "filter the rows returned"
        where: educator_topics_bool_exp
    ): educator_topics_aggregate!
    "fetch data from the table: \"educators\""
    educators(
        "distinct select on columns"
        distinct_on: [educators_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educators_order_by!]
        "filter the rows returned"
        where: educators_bool_exp
    ): [educators!]!
    "fetch aggregated fields from the table: \"educators\""
    educators_aggregate(
        "distinct select on columns"
        distinct_on: [educators_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educators_order_by!]
        "filter the rows returned"
        where: educators_bool_exp
    ): educators_aggregate!
    "fetch data from the table: \"enrollments\" using primary key columns"
    enrollment(id: uuid!): enrollments
    "fetch data from the table: \"enrollment_sessions\""
    enrollment_sessions(
        "distinct select on columns"
        distinct_on: [enrollment_sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollment_sessions_order_by!]
        "filter the rows returned"
        where: enrollment_sessions_bool_exp
    ): [enrollment_sessions!]!
    "fetch aggregated fields from the table: \"enrollment_sessions\""
    enrollment_sessions_aggregate(
        "distinct select on columns"
        distinct_on: [enrollment_sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollment_sessions_order_by!]
        "filter the rows returned"
        where: enrollment_sessions_bool_exp
    ): enrollment_sessions_aggregate!
    "fetch data from the table: \"enrollment_sessions\" using primary key columns"
    enrollment_sessions_by_pk(id: uuid!): enrollment_sessions
    "An array relationship"
    enrollments(
        "distinct select on columns"
        distinct_on: [enrollments_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollments_order_by!]
        "filter the rows returned"
        where: enrollments_bool_exp
    ): [enrollments!]!
    "An aggregate relationship"
    enrollments_aggregate(
        "distinct select on columns"
        distinct_on: [enrollments_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollments_order_by!]
        "filter the rows returned"
        where: enrollments_bool_exp
    ): enrollments_aggregate!
    "execute function \"featured_collection\" which returns \"collections\""
    featured_collection(
        "distinct select on columns"
        distinct_on: [collections_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [collections_order_by!]
        "filter the rows returned"
        where: collections_bool_exp
    ): collections
    "execute function \"featured_collection\" and query aggregates on result of table type \"collections\""
    featured_collection_aggregate(
        "distinct select on columns"
        distinct_on: [collections_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [collections_order_by!]
        "filter the rows returned"
        where: collections_bool_exp
    ): collections_aggregate!
    "execute function \"featured_course\" which returns \"courses\""
    featured_course(
        "distinct select on columns"
        distinct_on: [courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_order_by!]
        "filter the rows returned"
        where: courses_bool_exp
    ): courses
    "execute function \"featured_course\" and query aggregates on result of table type \"courses\""
    featured_course_aggregate(
        "distinct select on columns"
        distinct_on: [courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_order_by!]
        "filter the rows returned"
        where: courses_bool_exp
    ): courses_aggregate!
    "execute function \"featured_courses\" which returns \"courses\""
    featured_courses(
        "distinct select on columns"
        distinct_on: [courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_order_by!]
        "filter the rows returned"
        where: courses_bool_exp
    ): [courses!]!
    "execute function \"featured_courses\" and query aggregates on result of table type \"courses\""
    featured_courses_aggregate(
        "distinct select on columns"
        distinct_on: [courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_order_by!]
        "filter the rows returned"
        where: courses_bool_exp
    ): courses_aggregate!
    "execute function \"featured_educators\" which returns \"educators\""
    featured_educators(
        "distinct select on columns"
        distinct_on: [educators_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educators_order_by!]
        "filter the rows returned"
        where: educators_bool_exp
    ): [educators!]!
    "execute function \"featured_educators\" and query aggregates on result of table type \"educators\""
    featured_educators_aggregate(
        "distinct select on columns"
        distinct_on: [educators_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educators_order_by!]
        "filter the rows returned"
        where: educators_bool_exp
    ): educators_aggregate!
    listPaymentMethods: [PaymentMethod]!
    "fetch data from the table: \"my_enrolled_sessions\""
    my_enrolled_sessions(
        "distinct select on columns"
        distinct_on: [my_enrolled_sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [my_enrolled_sessions_order_by!]
        "filter the rows returned"
        where: my_enrolled_sessions_bool_exp
    ): [my_enrolled_sessions!]!
    "fetch aggregated fields from the table: \"my_enrolled_sessions\""
    my_enrolled_sessions_aggregate(
        "distinct select on columns"
        distinct_on: [my_enrolled_sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [my_enrolled_sessions_order_by!]
        "filter the rows returned"
        where: my_enrolled_sessions_bool_exp
    ): my_enrolled_sessions_aggregate!
    "fetch data from the table: \"orders\" using primary key columns"
    order(id: uuid!): orders
    "fetch data from the table: \"orderable_entities\""
    orderable_entities(
        "distinct select on columns"
        distinct_on: [orderable_entities_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [orderable_entities_order_by!]
        "filter the rows returned"
        where: orderable_entities_bool_exp
    ): [orderable_entities!]!
    "fetch aggregated fields from the table: \"orderable_entities\""
    orderable_entities_aggregate(
        "distinct select on columns"
        distinct_on: [orderable_entities_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [orderable_entities_order_by!]
        "filter the rows returned"
        where: orderable_entities_bool_exp
    ): orderable_entities_aggregate!
    "fetch data from the table: \"orderable_entities\" using primary key columns"
    orderable_entities_by_pk(value: String!): orderable_entities
    "fetch data from the table: \"orders\""
    orders(
        "distinct select on columns"
        distinct_on: [orders_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [orders_order_by!]
        "filter the rows returned"
        where: orders_bool_exp
    ): [orders!]!
    "fetch aggregated fields from the table: \"orders\""
    orders_aggregate(
        "distinct select on columns"
        distinct_on: [orders_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [orders_order_by!]
        "filter the rows returned"
        where: orders_bool_exp
    ): orders_aggregate!
    "fetch data from the table: \"organization\""
    organization(
        "distinct select on columns"
        distinct_on: [organization_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [organization_order_by!]
        "filter the rows returned"
        where: organization_bool_exp
    ): [organization!]!
    "fetch aggregated fields from the table: \"organization\""
    organization_aggregate(
        "distinct select on columns"
        distinct_on: [organization_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [organization_order_by!]
        "filter the rows returned"
        where: organization_bool_exp
    ): organization_aggregate!
    "fetch data from the table: \"organization\" using primary key columns"
    organization_by_pk(id: uuid!): organization
    "execute function \"pastClasses\" which returns \"enrollment_sessions\""
    pastClasses(
        "input parameters for function \"pastClasses\""
        args: pastClasses_args!
        "distinct select on columns"
        distinct_on: [enrollment_sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollment_sessions_order_by!]
        "filter the rows returned"
        where: enrollment_sessions_bool_exp
    ): [enrollment_sessions!]!
    "execute function \"pastClasses\" and query aggregates on result of table type \"enrollment_sessions\""
    pastClasses_aggregate(
        "input parameters for function \"pastClasses_aggregate\""
        args: pastClasses_args!
        "distinct select on columns"
        distinct_on: [enrollment_sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollment_sessions_order_by!]
        "filter the rows returned"
        where: enrollment_sessions_bool_exp
    ): enrollment_sessions_aggregate!
    ping: String
    plans: [SubscriptionPlans]!
    "fetch data from the table: \"products\" using primary key columns"
    product(id: String!): products
    "fetch data from the table: \"product_prices\" using primary key columns"
    product_price(id: String!): product_prices
    "fetch data from the table: \"product_prices\""
    product_prices(
        "distinct select on columns"
        distinct_on: [product_prices_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [product_prices_order_by!]
        "filter the rows returned"
        where: product_prices_bool_exp
    ): [product_prices!]!
    "fetch aggregated fields from the table: \"product_prices\""
    product_prices_aggregate(
        "distinct select on columns"
        distinct_on: [product_prices_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [product_prices_order_by!]
        "filter the rows returned"
        where: product_prices_bool_exp
    ): product_prices_aggregate!
    "fetch data from the table: \"products\""
    products(
        "distinct select on columns"
        distinct_on: [products_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [products_order_by!]
        "filter the rows returned"
        where: products_bool_exp
    ): [products!]!
    "fetch aggregated fields from the table: \"products\""
    products_aggregate(
        "distinct select on columns"
        distinct_on: [products_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [products_order_by!]
        "filter the rows returned"
        where: products_bool_exp
    ): products_aggregate!
    "fetch data from the table: \"promo_codes\" using primary key columns"
    promo_code(id: String!): promo_codes
    "fetch data from the table: \"promo_codes\""
    promo_codes(
        "distinct select on columns"
        distinct_on: [promo_codes_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [promo_codes_order_by!]
        "filter the rows returned"
        where: promo_codes_bool_exp
    ): [promo_codes!]!
    "fetch aggregated fields from the table: \"promo_codes\""
    promo_codes_aggregate(
        "distinct select on columns"
        distinct_on: [promo_codes_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [promo_codes_order_by!]
        "filter the rows returned"
        where: promo_codes_bool_exp
    ): promo_codes_aggregate!
    "fetch data from the table: \"redirect_mappings\""
    redirect_mappings(
        "distinct select on columns"
        distinct_on: [redirect_mappings_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [redirect_mappings_order_by!]
        "filter the rows returned"
        where: redirect_mappings_bool_exp
    ): [redirect_mappings!]!
    "fetch aggregated fields from the table: \"redirect_mappings\""
    redirect_mappings_aggregate(
        "distinct select on columns"
        distinct_on: [redirect_mappings_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [redirect_mappings_order_by!]
        "filter the rows returned"
        where: redirect_mappings_bool_exp
    ): redirect_mappings_aggregate!
    "fetch data from the table: \"redirect_mappings\" using primary key columns"
    redirect_mappings_by_pk(from_slug: String!, kind: String!, to_slug: String!): redirect_mappings
    "fetch data from the table: \"resource_types\""
    resource_types(
        "distinct select on columns"
        distinct_on: [resource_types_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [resource_types_order_by!]
        "filter the rows returned"
        where: resource_types_bool_exp
    ): [resource_types!]!
    "fetch aggregated fields from the table: \"resource_types\""
    resource_types_aggregate(
        "distinct select on columns"
        distinct_on: [resource_types_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [resource_types_order_by!]
        "filter the rows returned"
        where: resource_types_bool_exp
    ): resource_types_aggregate!
    "fetch data from the table: \"resource_types\" using primary key columns"
    resource_types_by_pk(value: String!): resource_types
    "fetch data from the table: \"sessions\" using primary key columns"
    session(id: uuid!): sessions
    "An array relationship"
    sessions(
        "distinct select on columns"
        distinct_on: [sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [sessions_order_by!]
        "filter the rows returned"
        where: sessions_bool_exp
    ): [sessions!]!
    "An aggregate relationship"
    sessions_aggregate(
        "distinct select on columns"
        distinct_on: [sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [sessions_order_by!]
        "filter the rows returned"
        where: sessions_bool_exp
    ): sessions_aggregate!
    "fetch data from the table: \"stripe_customers\" using primary key columns"
    stripe_customer(userId: uuid!): stripe_customers
    "fetch data from the table: \"stripe_customers\""
    stripe_customers(
        "distinct select on columns"
        distinct_on: [stripe_customers_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [stripe_customers_order_by!]
        "filter the rows returned"
        where: stripe_customers_bool_exp
    ): [stripe_customers!]!
    "fetch aggregated fields from the table: \"stripe_customers\""
    stripe_customers_aggregate(
        "distinct select on columns"
        distinct_on: [stripe_customers_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [stripe_customers_order_by!]
        "filter the rows returned"
        where: stripe_customers_bool_exp
    ): stripe_customers_aggregate!
    "fetch data from the table: \"subscriptions\" using primary key columns"
    subscription(id: uuid!): subscriptions
    subscriptionOverview: SubscriptionOverviewOutput
    "fetch data from the table: \"subscription_status\""
    subscription_status(
        "distinct select on columns"
        distinct_on: [subscription_status_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [subscription_status_order_by!]
        "filter the rows returned"
        where: subscription_status_bool_exp
    ): [subscription_status!]!
    "fetch aggregated fields from the table: \"subscription_status\""
    subscription_status_aggregate(
        "distinct select on columns"
        distinct_on: [subscription_status_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [subscription_status_order_by!]
        "filter the rows returned"
        where: subscription_status_bool_exp
    ): subscription_status_aggregate!
    "fetch data from the table: \"subscription_status\" using primary key columns"
    subscription_status_by_pk(value: String!): subscription_status
    "fetch data from the table: \"subscriptions\""
    subscriptions(
        "distinct select on columns"
        distinct_on: [subscriptions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [subscriptions_order_by!]
        "filter the rows returned"
        where: subscriptions_bool_exp
    ): [subscriptions!]!
    "fetch aggregated fields from the table: \"subscriptions\""
    subscriptions_aggregate(
        "distinct select on columns"
        distinct_on: [subscriptions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [subscriptions_order_by!]
        "filter the rows returned"
        where: subscriptions_bool_exp
    ): subscriptions_aggregate!
    "fetch data from the table: \"teaching_styles\" using primary key columns"
    teaching_style(value: String!): teaching_styles
    "fetch data from the table: \"teaching_styles\""
    teaching_styles(
        "distinct select on columns"
        distinct_on: [teaching_styles_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [teaching_styles_order_by!]
        "filter the rows returned"
        where: teaching_styles_bool_exp
    ): [teaching_styles!]!
    "fetch aggregated fields from the table: \"teaching_styles\""
    teaching_styles_aggregate(
        "distinct select on columns"
        distinct_on: [teaching_styles_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [teaching_styles_order_by!]
        "filter the rows returned"
        where: teaching_styles_bool_exp
    ): teaching_styles_aggregate!
    "fetch data from the table: \"topics\" using primary key columns"
    topic(id: uuid!): topics
    "fetch data from the table: \"topics\""
    topics(
        "distinct select on columns"
        distinct_on: [topics_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [topics_order_by!]
        "filter the rows returned"
        where: topics_bool_exp
    ): [topics!]!
    "fetch aggregated fields from the table: \"topics\""
    topics_aggregate(
        "distinct select on columns"
        distinct_on: [topics_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [topics_order_by!]
        "filter the rows returned"
        where: topics_bool_exp
    ): topics_aggregate!
    "execute function \"upcomingClasses\" which returns \"enrollment_sessions\""
    upcomingClasses(
        "input parameters for function \"upcomingClasses\""
        args: upcomingClasses_args!
        "distinct select on columns"
        distinct_on: [enrollment_sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollment_sessions_order_by!]
        "filter the rows returned"
        where: enrollment_sessions_bool_exp
    ): [enrollment_sessions!]!
    "execute function \"upcomingClasses\" and query aggregates on result of table type \"enrollment_sessions\""
    upcomingClasses_aggregate(
        "input parameters for function \"upcomingClasses_aggregate\""
        args: upcomingClasses_args!
        "distinct select on columns"
        distinct_on: [enrollment_sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollment_sessions_order_by!]
        "filter the rows returned"
        where: enrollment_sessions_bool_exp
    ): enrollment_sessions_aggregate!
    "fetch data from the table: \"update_entity_order_request\""
    update_entity_order_request(
        "distinct select on columns"
        distinct_on: [update_entity_order_request_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [update_entity_order_request_order_by!]
        "filter the rows returned"
        where: update_entity_order_request_bool_exp
    ): [update_entity_order_request!]!
    "fetch aggregated fields from the table: \"update_entity_order_request\""
    update_entity_order_request_aggregate(
        "distinct select on columns"
        distinct_on: [update_entity_order_request_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [update_entity_order_request_order_by!]
        "filter the rows returned"
        where: update_entity_order_request_bool_exp
    ): update_entity_order_request_aggregate!
    "fetch data from the table: \"update_entity_order_request\" using primary key columns"
    update_entity_order_request_by_pk(entityId: uuid!, order: Int!): update_entity_order_request
    "fetch data from the table: \"uploads\" using primary key columns"
    upload(id: uuid!): uploads
    "fetch data from the table: \"uploads\""
    uploads(
        "distinct select on columns"
        distinct_on: [uploads_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [uploads_order_by!]
        "filter the rows returned"
        where: uploads_bool_exp
    ): [uploads!]!
    "fetch aggregated fields from the table: \"uploads\""
    uploads_aggregate(
        "distinct select on columns"
        distinct_on: [uploads_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [uploads_order_by!]
        "filter the rows returned"
        where: uploads_bool_exp
    ): uploads_aggregate!
    "fetch data from the table: \"user_class_preferences\" using primary key columns"
    use_class_preference(preferenceValue: class_tags_enum!, userId: uuid!): user_class_preferences
    "fetch data from the table: \"users\" using primary key columns"
    user(id: uuid!): users
    "fetch data from the table: \"user_details\""
    userDetails(
        "distinct select on columns"
        distinct_on: [user_details_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [user_details_order_by!]
        "filter the rows returned"
        where: user_details_bool_exp
    ): [user_details!]!
    "fetch data from the table: \"user_class_preferences\""
    user_class_preferences(
        "distinct select on columns"
        distinct_on: [user_class_preferences_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [user_class_preferences_order_by!]
        "filter the rows returned"
        where: user_class_preferences_bool_exp
    ): [user_class_preferences!]!
    "fetch aggregated fields from the table: \"user_class_preferences\""
    user_class_preferences_aggregate(
        "distinct select on columns"
        distinct_on: [user_class_preferences_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [user_class_preferences_order_by!]
        "filter the rows returned"
        where: user_class_preferences_bool_exp
    ): user_class_preferences_aggregate!
    "fetch aggregated fields from the table: \"user_details\""
    user_details_aggregate(
        "distinct select on columns"
        distinct_on: [user_details_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [user_details_order_by!]
        "filter the rows returned"
        where: user_details_bool_exp
    ): user_details_aggregate!
    "fetch data from the table: \"user_roles\""
    user_roles(
        "distinct select on columns"
        distinct_on: [user_roles_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [user_roles_order_by!]
        "filter the rows returned"
        where: user_roles_bool_exp
    ): [user_roles!]!
    "fetch aggregated fields from the table: \"user_roles\""
    user_roles_aggregate(
        "distinct select on columns"
        distinct_on: [user_roles_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [user_roles_order_by!]
        "filter the rows returned"
        where: user_roles_bool_exp
    ): user_roles_aggregate!
    "fetch data from the table: \"user_roles\" using primary key columns"
    user_roles_by_pk(value: String!): user_roles
    "fetch data from the table: \"user_teaching_style_preferences\" using primary key columns"
    user_teaching_style_preference(
        preferenceValue: teaching_styles_enum!
        userId: uuid!
    ): user_teaching_style_preferences
    "fetch data from the table: \"user_teaching_style_preferences\""
    user_teaching_style_preferences(
        "distinct select on columns"
        distinct_on: [user_teaching_style_preferences_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [user_teaching_style_preferences_order_by!]
        "filter the rows returned"
        where: user_teaching_style_preferences_bool_exp
    ): [user_teaching_style_preferences!]!
    "fetch aggregated fields from the table: \"user_teaching_style_preferences\""
    user_teaching_style_preferences_aggregate(
        "distinct select on columns"
        distinct_on: [user_teaching_style_preferences_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [user_teaching_style_preferences_order_by!]
        "filter the rows returned"
        where: user_teaching_style_preferences_bool_exp
    ): user_teaching_style_preferences_aggregate!
    "fetch data from the table: \"users\""
    users(
        "distinct select on columns"
        distinct_on: [users_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [users_order_by!]
        "filter the rows returned"
        where: users_bool_exp
    ): [users!]!
    "fetch aggregated fields from the table: \"users\""
    users_aggregate(
        "distinct select on columns"
        distinct_on: [users_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [users_order_by!]
        "filter the rows returned"
        where: users_bool_exp
    ): users_aggregate!
    validateCoupon(code: String!): ValidateCouponResponse!
}

"columns and relationships of \"redirect_mappings\""
type redirect_mappings {
    code: Int!
    from_slug: String!
    kind: String!
    to_slug: String!
}

"aggregated selection of \"redirect_mappings\""
type redirect_mappings_aggregate {
    aggregate: redirect_mappings_aggregate_fields
    nodes: [redirect_mappings!]!
}

"aggregate fields of \"redirect_mappings\""
type redirect_mappings_aggregate_fields {
    avg: redirect_mappings_avg_fields
    count(columns: [redirect_mappings_select_column!], distinct: Boolean): Int!
    max: redirect_mappings_max_fields
    min: redirect_mappings_min_fields
    stddev: redirect_mappings_stddev_fields
    stddev_pop: redirect_mappings_stddev_pop_fields
    stddev_samp: redirect_mappings_stddev_samp_fields
    sum: redirect_mappings_sum_fields
    var_pop: redirect_mappings_var_pop_fields
    var_samp: redirect_mappings_var_samp_fields
    variance: redirect_mappings_variance_fields
}

"aggregate avg on columns"
type redirect_mappings_avg_fields {
    code: Float
}

"aggregate max on columns"
type redirect_mappings_max_fields {
    code: Int
    from_slug: String
    kind: String
    to_slug: String
}

"aggregate min on columns"
type redirect_mappings_min_fields {
    code: Int
    from_slug: String
    kind: String
    to_slug: String
}

"response of any mutation on the table \"redirect_mappings\""
type redirect_mappings_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [redirect_mappings!]!
}

"aggregate stddev on columns"
type redirect_mappings_stddev_fields {
    code: Float
}

"aggregate stddev_pop on columns"
type redirect_mappings_stddev_pop_fields {
    code: Float
}

"aggregate stddev_samp on columns"
type redirect_mappings_stddev_samp_fields {
    code: Float
}

"aggregate sum on columns"
type redirect_mappings_sum_fields {
    code: Int
}

"aggregate var_pop on columns"
type redirect_mappings_var_pop_fields {
    code: Float
}

"aggregate var_samp on columns"
type redirect_mappings_var_samp_fields {
    code: Float
}

"aggregate variance on columns"
type redirect_mappings_variance_fields {
    code: Float
}

"columns and relationships of \"resource_types\""
type resource_types {
    description: String!
    value: String!
}

"aggregated selection of \"resource_types\""
type resource_types_aggregate {
    aggregate: resource_types_aggregate_fields
    nodes: [resource_types!]!
}

"aggregate fields of \"resource_types\""
type resource_types_aggregate_fields {
    count(columns: [resource_types_select_column!], distinct: Boolean): Int!
    max: resource_types_max_fields
    min: resource_types_min_fields
}

"aggregate max on columns"
type resource_types_max_fields {
    description: String
    value: String
}

"aggregate min on columns"
type resource_types_min_fields {
    description: String
    value: String
}

"response of any mutation on the table \"resource_types\""
type resource_types_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [resource_types!]!
}

"columns and relationships of \"sessions\""
type sessions {
    cancelled: Boolean!
    "An object relationship"
    course: courses!
    courseId: uuid!
    createdAt: timestamptz
    endTime: timestamptz!
    id: uuid!
    mailchimpCampaignId: String
    "A computed field, executes function \"get_sessions_meeting_link\""
    meetingLink: String
    protectedMeetingLink: String!
    protectedRecordingLink: String
    "A computed field, executes function \"get_sessions_recording_link\""
    recordingLink: String
    startTime: timestamptz!
    title: String!
    updatedAt: timestamptz
}

"aggregated selection of \"sessions\""
type sessions_aggregate {
    aggregate: sessions_aggregate_fields
    nodes: [sessions!]!
}

"aggregate fields of \"sessions\""
type sessions_aggregate_fields {
    count(columns: [sessions_select_column!], distinct: Boolean): Int!
    max: sessions_max_fields
    min: sessions_min_fields
}

"aggregate max on columns"
type sessions_max_fields {
    courseId: uuid
    createdAt: timestamptz
    endTime: timestamptz
    id: uuid
    mailchimpCampaignId: String
    protectedMeetingLink: String
    protectedRecordingLink: String
    startTime: timestamptz
    title: String
    updatedAt: timestamptz
}

"aggregate min on columns"
type sessions_min_fields {
    courseId: uuid
    createdAt: timestamptz
    endTime: timestamptz
    id: uuid
    mailchimpCampaignId: String
    protectedMeetingLink: String
    protectedRecordingLink: String
    startTime: timestamptz
    title: String
    updatedAt: timestamptz
}

"response of any mutation on the table \"sessions\""
type sessions_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [sessions!]!
}

"columns and relationships of \"stripe_customers\""
type stripe_customers {
    customerId: String!
    "An object relationship"
    subscription: subscriptions
    "An object relationship"
    user: users!
    userId: uuid!
}

"aggregated selection of \"stripe_customers\""
type stripe_customers_aggregate {
    aggregate: stripe_customers_aggregate_fields
    nodes: [stripe_customers!]!
}

"aggregate fields of \"stripe_customers\""
type stripe_customers_aggregate_fields {
    count(columns: [stripe_customers_select_column!], distinct: Boolean): Int!
    max: stripe_customers_max_fields
    min: stripe_customers_min_fields
}

"aggregate max on columns"
type stripe_customers_max_fields {
    customerId: String
    userId: uuid
}

"aggregate min on columns"
type stripe_customers_min_fields {
    customerId: String
    userId: uuid
}

"response of any mutation on the table \"stripe_customers\""
type stripe_customers_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [stripe_customers!]!
}

type subscription_root {
    "fetch data from the table: \"class_tags\" using primary key columns"
    class_tag(value: String!): class_tags
    "fetch data from the table: \"class_tags\""
    class_tags(
        "distinct select on columns"
        distinct_on: [class_tags_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [class_tags_order_by!]
        "filter the rows returned"
        where: class_tags_bool_exp
    ): [class_tags!]!
    "fetch aggregated fields from the table: \"class_tags\""
    class_tags_aggregate(
        "distinct select on columns"
        distinct_on: [class_tags_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [class_tags_order_by!]
        "filter the rows returned"
        where: class_tags_bool_exp
    ): class_tags_aggregate!
    "fetch data from the table: \"collections\" using primary key columns"
    collection(id: uuid!): collections
    "execute function \"collection_by_slug\" which returns \"collections\""
    collection_by_slug(
        "input parameters for function \"collection_by_slug\""
        args: collection_by_slug_args!
        "distinct select on columns"
        distinct_on: [collections_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [collections_order_by!]
        "filter the rows returned"
        where: collections_bool_exp
    ): collections
    "execute function \"collection_by_slug\" and query aggregates on result of table type \"collections\""
    collection_by_slug_aggregate(
        "input parameters for function \"collection_by_slug_aggregate\""
        args: collection_by_slug_args!
        "distinct select on columns"
        distinct_on: [collections_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [collections_order_by!]
        "filter the rows returned"
        where: collections_bool_exp
    ): collections_aggregate!
    "fetch data from the table: \"collection_courses\" using primary key columns"
    collection_course(id: uuid!): collection_courses
    "An array relationship"
    collection_courses(
        "distinct select on columns"
        distinct_on: [collection_courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [collection_courses_order_by!]
        "filter the rows returned"
        where: collection_courses_bool_exp
    ): [collection_courses!]!
    "An aggregate relationship"
    collection_courses_aggregate(
        "distinct select on columns"
        distinct_on: [collection_courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [collection_courses_order_by!]
        "filter the rows returned"
        where: collection_courses_bool_exp
    ): collection_courses_aggregate!
    "fetch data from the table: \"collections\""
    collections(
        "distinct select on columns"
        distinct_on: [collections_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [collections_order_by!]
        "filter the rows returned"
        where: collections_bool_exp
    ): [collections!]!
    "fetch aggregated fields from the table: \"collections\""
    collections_aggregate(
        "distinct select on columns"
        distinct_on: [collections_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [collections_order_by!]
        "filter the rows returned"
        where: collections_bool_exp
    ): collections_aggregate!
    "fetch data from the table: \"config_types\""
    config_types(
        "distinct select on columns"
        distinct_on: [config_types_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [config_types_order_by!]
        "filter the rows returned"
        where: config_types_bool_exp
    ): [config_types!]!
    "fetch aggregated fields from the table: \"config_types\""
    config_types_aggregate(
        "distinct select on columns"
        distinct_on: [config_types_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [config_types_order_by!]
        "filter the rows returned"
        where: config_types_bool_exp
    ): config_types_aggregate!
    "fetch data from the table: \"config_types\" using primary key columns"
    config_types_by_pk(value: String!): config_types
    "fetch data from the table: \"config_values\" using primary key columns"
    config_value(configType: config_types_enum!): config_values
    "fetch data from the table: \"config_values\""
    config_values(
        "distinct select on columns"
        distinct_on: [config_values_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [config_values_order_by!]
        "filter the rows returned"
        where: config_values_bool_exp
    ): [config_values!]!
    "fetch aggregated fields from the table: \"config_values\""
    config_values_aggregate(
        "distinct select on columns"
        distinct_on: [config_values_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [config_values_order_by!]
        "filter the rows returned"
        where: config_values_bool_exp
    ): config_values_aggregate!
    "fetch data from the table: \"coupons\" using primary key columns"
    coupon(id: String!): coupons
    "fetch data from the table: \"coupons\""
    coupons(
        "distinct select on columns"
        distinct_on: [coupons_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [coupons_order_by!]
        "filter the rows returned"
        where: coupons_bool_exp
    ): [coupons!]!
    "fetch aggregated fields from the table: \"coupons\""
    coupons_aggregate(
        "distinct select on columns"
        distinct_on: [coupons_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [coupons_order_by!]
        "filter the rows returned"
        where: coupons_bool_exp
    ): coupons_aggregate!
    "fetch data from the table: \"courses\" using primary key columns"
    course(id: uuid!): courses
    "execute function \"course_by_slug\" which returns \"courses\""
    course_by_slug(
        "input parameters for function \"course_by_slug\""
        args: course_by_slug_args!
        "distinct select on columns"
        distinct_on: [courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_order_by!]
        "filter the rows returned"
        where: courses_bool_exp
    ): courses
    "execute function \"course_by_slug\" and query aggregates on result of table type \"courses\""
    course_by_slug_aggregate(
        "input parameters for function \"course_by_slug_aggregate\""
        args: course_by_slug_args!
        "distinct select on columns"
        distinct_on: [courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_order_by!]
        "filter the rows returned"
        where: courses_bool_exp
    ): courses_aggregate!
    "fetch data from the table: \"course_resources\" using primary key columns"
    course_resource(id: uuid!): course_resources
    "fetch data from the table: \"course_resources\""
    course_resources(
        "distinct select on columns"
        distinct_on: [course_resources_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [course_resources_order_by!]
        "filter the rows returned"
        where: course_resources_bool_exp
    ): [course_resources!]!
    "fetch aggregated fields from the table: \"course_resources\""
    course_resources_aggregate(
        "distinct select on columns"
        distinct_on: [course_resources_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [course_resources_order_by!]
        "filter the rows returned"
        where: course_resources_bool_exp
    ): course_resources_aggregate!
    "fetch data from the table: \"course_tags\" using primary key columns"
    course_tag(id: uuid!): course_tags
    "fetch data from the table: \"course_tags\""
    course_tags(
        "distinct select on columns"
        distinct_on: [course_tags_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [course_tags_order_by!]
        "filter the rows returned"
        where: course_tags_bool_exp
    ): [course_tags!]!
    "fetch aggregated fields from the table: \"course_tags\""
    course_tags_aggregate(
        "distinct select on columns"
        distinct_on: [course_tags_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [course_tags_order_by!]
        "filter the rows returned"
        where: course_tags_bool_exp
    ): course_tags_aggregate!
    "fetch data from the table: \"course_types\""
    course_types(
        "distinct select on columns"
        distinct_on: [course_types_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [course_types_order_by!]
        "filter the rows returned"
        where: course_types_bool_exp
    ): [course_types!]!
    "fetch aggregated fields from the table: \"course_types\""
    course_types_aggregate(
        "distinct select on columns"
        distinct_on: [course_types_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [course_types_order_by!]
        "filter the rows returned"
        where: course_types_bool_exp
    ): course_types_aggregate!
    "fetch data from the table: \"course_types\" using primary key columns"
    course_types_by_pk(value: String!): course_types
    "An array relationship"
    courses(
        "distinct select on columns"
        distinct_on: [courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_order_by!]
        "filter the rows returned"
        where: courses_bool_exp
    ): [courses!]!
    "An aggregate relationship"
    courses_aggregate(
        "distinct select on columns"
        distinct_on: [courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_order_by!]
        "filter the rows returned"
        where: courses_bool_exp
    ): courses_aggregate!
    "fetch data from the table: \"courses_for_collection_assignment\""
    courses_for_collection_assignment(
        "distinct select on columns"
        distinct_on: [courses_for_collection_assignment_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_for_collection_assignment_order_by!]
        "filter the rows returned"
        where: courses_for_collection_assignment_bool_exp
    ): [courses_for_collection_assignment!]!
    "fetch aggregated fields from the table: \"courses_for_collection_assignment\""
    courses_for_collection_assignment_aggregate(
        "distinct select on columns"
        distinct_on: [courses_for_collection_assignment_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_for_collection_assignment_order_by!]
        "filter the rows returned"
        where: courses_for_collection_assignment_bool_exp
    ): courses_for_collection_assignment_aggregate!
    "fetch data from the table: \"educator_books\" using primary key columns"
    educator_book(id: uuid!): educator_books
    "fetch data from the table: \"educator_books\""
    educator_books(
        "distinct select on columns"
        distinct_on: [educator_books_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_books_order_by!]
        "filter the rows returned"
        where: educator_books_bool_exp
    ): [educator_books!]!
    "fetch aggregated fields from the table: \"educator_books\""
    educator_books_aggregate(
        "distinct select on columns"
        distinct_on: [educator_books_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_books_order_by!]
        "filter the rows returned"
        where: educator_books_bool_exp
    ): educator_books_aggregate!
    "execute function \"educator_by_slug\" which returns \"educators\""
    educator_by_slug(
        "input parameters for function \"educator_by_slug\""
        args: educator_by_slug_args!
        "distinct select on columns"
        distinct_on: [educators_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educators_order_by!]
        "filter the rows returned"
        where: educators_bool_exp
    ): educators
    "execute function \"educator_by_slug\" and query aggregates on result of table type \"educators\""
    educator_by_slug_aggregate(
        "input parameters for function \"educator_by_slug_aggregate\""
        args: educator_by_slug_args!
        "distinct select on columns"
        distinct_on: [educators_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educators_order_by!]
        "filter the rows returned"
        where: educators_bool_exp
    ): educators_aggregate!
    "fetch data from the table: \"educator_educations\" using primary key columns"
    educator_education(id: uuid!): educator_educations
    "fetch data from the table: \"educator_educations\""
    educator_educations(
        "distinct select on columns"
        distinct_on: [educator_educations_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_educations_order_by!]
        "filter the rows returned"
        where: educator_educations_bool_exp
    ): [educator_educations!]!
    "fetch aggregated fields from the table: \"educator_educations\""
    educator_educations_aggregate(
        "distinct select on columns"
        distinct_on: [educator_educations_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_educations_order_by!]
        "filter the rows returned"
        where: educator_educations_bool_exp
    ): educator_educations_aggregate!
    "fetch data from the table: \"educator_profiles\" using primary key columns"
    educator_profile(educatorId: uuid!): educator_profiles
    "fetch data from the table: \"educator_profiles\""
    educator_profiles(
        "distinct select on columns"
        distinct_on: [educator_profiles_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_profiles_order_by!]
        "filter the rows returned"
        where: educator_profiles_bool_exp
    ): [educator_profiles!]!
    "fetch aggregated fields from the table: \"educator_profiles\""
    educator_profiles_aggregate(
        "distinct select on columns"
        distinct_on: [educator_profiles_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_profiles_order_by!]
        "filter the rows returned"
        where: educator_profiles_bool_exp
    ): educator_profiles_aggregate!
    "fetch data from the table: \"educator_publications\" using primary key columns"
    educator_publication(id: uuid!): educator_publications
    "fetch data from the table: \"educator_publications\""
    educator_publications(
        "distinct select on columns"
        distinct_on: [educator_publications_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_publications_order_by!]
        "filter the rows returned"
        where: educator_publications_bool_exp
    ): [educator_publications!]!
    "fetch aggregated fields from the table: \"educator_publications\""
    educator_publications_aggregate(
        "distinct select on columns"
        distinct_on: [educator_publications_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_publications_order_by!]
        "filter the rows returned"
        where: educator_publications_bool_exp
    ): educator_publications_aggregate!
    "fetch data from the table: \"educator_teaching_styles\" using primary key columns"
    educator_teaching_style(educatorId: uuid!, style: teaching_styles_enum!): educator_teaching_styles
    "fetch data from the table: \"educator_teaching_styles\""
    educator_teaching_styles(
        "distinct select on columns"
        distinct_on: [educator_teaching_styles_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_teaching_styles_order_by!]
        "filter the rows returned"
        where: educator_teaching_styles_bool_exp
    ): [educator_teaching_styles!]!
    "fetch aggregated fields from the table: \"educator_teaching_styles\""
    educator_teaching_styles_aggregate(
        "distinct select on columns"
        distinct_on: [educator_teaching_styles_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_teaching_styles_order_by!]
        "filter the rows returned"
        where: educator_teaching_styles_bool_exp
    ): educator_teaching_styles_aggregate!
    "fetch data from the table: \"educator_testimonials\" using primary key columns"
    educator_testimonial(id: uuid!): educator_testimonials
    "fetch data from the table: \"educator_testimonials\""
    educator_testimonials(
        "distinct select on columns"
        distinct_on: [educator_testimonials_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_testimonials_order_by!]
        "filter the rows returned"
        where: educator_testimonials_bool_exp
    ): [educator_testimonials!]!
    "fetch aggregated fields from the table: \"educator_testimonials\""
    educator_testimonials_aggregate(
        "distinct select on columns"
        distinct_on: [educator_testimonials_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_testimonials_order_by!]
        "filter the rows returned"
        where: educator_testimonials_bool_exp
    ): educator_testimonials_aggregate!
    "fetch data from the table: \"educator_topics\""
    educator_topics(
        "distinct select on columns"
        distinct_on: [educator_topics_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_topics_order_by!]
        "filter the rows returned"
        where: educator_topics_bool_exp
    ): [educator_topics!]!
    "fetch aggregated fields from the table: \"educator_topics\""
    educator_topics_aggregate(
        "distinct select on columns"
        distinct_on: [educator_topics_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_topics_order_by!]
        "filter the rows returned"
        where: educator_topics_bool_exp
    ): educator_topics_aggregate!
    "fetch data from the table: \"educators\""
    educators(
        "distinct select on columns"
        distinct_on: [educators_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educators_order_by!]
        "filter the rows returned"
        where: educators_bool_exp
    ): [educators!]!
    "fetch aggregated fields from the table: \"educators\""
    educators_aggregate(
        "distinct select on columns"
        distinct_on: [educators_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educators_order_by!]
        "filter the rows returned"
        where: educators_bool_exp
    ): educators_aggregate!
    "fetch data from the table: \"enrollments\" using primary key columns"
    enrollment(id: uuid!): enrollments
    "fetch data from the table: \"enrollment_sessions\""
    enrollment_sessions(
        "distinct select on columns"
        distinct_on: [enrollment_sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollment_sessions_order_by!]
        "filter the rows returned"
        where: enrollment_sessions_bool_exp
    ): [enrollment_sessions!]!
    "fetch aggregated fields from the table: \"enrollment_sessions\""
    enrollment_sessions_aggregate(
        "distinct select on columns"
        distinct_on: [enrollment_sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollment_sessions_order_by!]
        "filter the rows returned"
        where: enrollment_sessions_bool_exp
    ): enrollment_sessions_aggregate!
    "fetch data from the table: \"enrollment_sessions\" using primary key columns"
    enrollment_sessions_by_pk(id: uuid!): enrollment_sessions
    "An array relationship"
    enrollments(
        "distinct select on columns"
        distinct_on: [enrollments_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollments_order_by!]
        "filter the rows returned"
        where: enrollments_bool_exp
    ): [enrollments!]!
    "An aggregate relationship"
    enrollments_aggregate(
        "distinct select on columns"
        distinct_on: [enrollments_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollments_order_by!]
        "filter the rows returned"
        where: enrollments_bool_exp
    ): enrollments_aggregate!
    "execute function \"featured_collection\" which returns \"collections\""
    featured_collection(
        "distinct select on columns"
        distinct_on: [collections_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [collections_order_by!]
        "filter the rows returned"
        where: collections_bool_exp
    ): collections
    "execute function \"featured_collection\" and query aggregates on result of table type \"collections\""
    featured_collection_aggregate(
        "distinct select on columns"
        distinct_on: [collections_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [collections_order_by!]
        "filter the rows returned"
        where: collections_bool_exp
    ): collections_aggregate!
    "execute function \"featured_course\" which returns \"courses\""
    featured_course(
        "distinct select on columns"
        distinct_on: [courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_order_by!]
        "filter the rows returned"
        where: courses_bool_exp
    ): courses
    "execute function \"featured_course\" and query aggregates on result of table type \"courses\""
    featured_course_aggregate(
        "distinct select on columns"
        distinct_on: [courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_order_by!]
        "filter the rows returned"
        where: courses_bool_exp
    ): courses_aggregate!
    "execute function \"featured_courses\" which returns \"courses\""
    featured_courses(
        "distinct select on columns"
        distinct_on: [courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_order_by!]
        "filter the rows returned"
        where: courses_bool_exp
    ): [courses!]!
    "execute function \"featured_courses\" and query aggregates on result of table type \"courses\""
    featured_courses_aggregate(
        "distinct select on columns"
        distinct_on: [courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_order_by!]
        "filter the rows returned"
        where: courses_bool_exp
    ): courses_aggregate!
    "execute function \"featured_educators\" which returns \"educators\""
    featured_educators(
        "distinct select on columns"
        distinct_on: [educators_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educators_order_by!]
        "filter the rows returned"
        where: educators_bool_exp
    ): [educators!]!
    "execute function \"featured_educators\" and query aggregates on result of table type \"educators\""
    featured_educators_aggregate(
        "distinct select on columns"
        distinct_on: [educators_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educators_order_by!]
        "filter the rows returned"
        where: educators_bool_exp
    ): educators_aggregate!
    "fetch data from the table: \"my_enrolled_sessions\""
    my_enrolled_sessions(
        "distinct select on columns"
        distinct_on: [my_enrolled_sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [my_enrolled_sessions_order_by!]
        "filter the rows returned"
        where: my_enrolled_sessions_bool_exp
    ): [my_enrolled_sessions!]!
    "fetch aggregated fields from the table: \"my_enrolled_sessions\""
    my_enrolled_sessions_aggregate(
        "distinct select on columns"
        distinct_on: [my_enrolled_sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [my_enrolled_sessions_order_by!]
        "filter the rows returned"
        where: my_enrolled_sessions_bool_exp
    ): my_enrolled_sessions_aggregate!
    "fetch data from the table: \"orders\" using primary key columns"
    order(id: uuid!): orders
    "fetch data from the table: \"orderable_entities\""
    orderable_entities(
        "distinct select on columns"
        distinct_on: [orderable_entities_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [orderable_entities_order_by!]
        "filter the rows returned"
        where: orderable_entities_bool_exp
    ): [orderable_entities!]!
    "fetch aggregated fields from the table: \"orderable_entities\""
    orderable_entities_aggregate(
        "distinct select on columns"
        distinct_on: [orderable_entities_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [orderable_entities_order_by!]
        "filter the rows returned"
        where: orderable_entities_bool_exp
    ): orderable_entities_aggregate!
    "fetch data from the table: \"orderable_entities\" using primary key columns"
    orderable_entities_by_pk(value: String!): orderable_entities
    "fetch data from the table: \"orders\""
    orders(
        "distinct select on columns"
        distinct_on: [orders_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [orders_order_by!]
        "filter the rows returned"
        where: orders_bool_exp
    ): [orders!]!
    "fetch aggregated fields from the table: \"orders\""
    orders_aggregate(
        "distinct select on columns"
        distinct_on: [orders_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [orders_order_by!]
        "filter the rows returned"
        where: orders_bool_exp
    ): orders_aggregate!
    "fetch data from the table: \"organization\""
    organization(
        "distinct select on columns"
        distinct_on: [organization_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [organization_order_by!]
        "filter the rows returned"
        where: organization_bool_exp
    ): [organization!]!
    "fetch aggregated fields from the table: \"organization\""
    organization_aggregate(
        "distinct select on columns"
        distinct_on: [organization_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [organization_order_by!]
        "filter the rows returned"
        where: organization_bool_exp
    ): organization_aggregate!
    "fetch data from the table: \"organization\" using primary key columns"
    organization_by_pk(id: uuid!): organization
    "execute function \"pastClasses\" which returns \"enrollment_sessions\""
    pastClasses(
        "input parameters for function \"pastClasses\""
        args: pastClasses_args!
        "distinct select on columns"
        distinct_on: [enrollment_sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollment_sessions_order_by!]
        "filter the rows returned"
        where: enrollment_sessions_bool_exp
    ): [enrollment_sessions!]!
    "execute function \"pastClasses\" and query aggregates on result of table type \"enrollment_sessions\""
    pastClasses_aggregate(
        "input parameters for function \"pastClasses_aggregate\""
        args: pastClasses_args!
        "distinct select on columns"
        distinct_on: [enrollment_sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollment_sessions_order_by!]
        "filter the rows returned"
        where: enrollment_sessions_bool_exp
    ): enrollment_sessions_aggregate!
    "fetch data from the table: \"products\" using primary key columns"
    product(id: String!): products
    "fetch data from the table: \"product_prices\" using primary key columns"
    product_price(id: String!): product_prices
    "fetch data from the table: \"product_prices\""
    product_prices(
        "distinct select on columns"
        distinct_on: [product_prices_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [product_prices_order_by!]
        "filter the rows returned"
        where: product_prices_bool_exp
    ): [product_prices!]!
    "fetch aggregated fields from the table: \"product_prices\""
    product_prices_aggregate(
        "distinct select on columns"
        distinct_on: [product_prices_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [product_prices_order_by!]
        "filter the rows returned"
        where: product_prices_bool_exp
    ): product_prices_aggregate!
    "fetch data from the table: \"products\""
    products(
        "distinct select on columns"
        distinct_on: [products_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [products_order_by!]
        "filter the rows returned"
        where: products_bool_exp
    ): [products!]!
    "fetch aggregated fields from the table: \"products\""
    products_aggregate(
        "distinct select on columns"
        distinct_on: [products_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [products_order_by!]
        "filter the rows returned"
        where: products_bool_exp
    ): products_aggregate!
    "fetch data from the table: \"promo_codes\" using primary key columns"
    promo_code(id: String!): promo_codes
    "fetch data from the table: \"promo_codes\""
    promo_codes(
        "distinct select on columns"
        distinct_on: [promo_codes_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [promo_codes_order_by!]
        "filter the rows returned"
        where: promo_codes_bool_exp
    ): [promo_codes!]!
    "fetch aggregated fields from the table: \"promo_codes\""
    promo_codes_aggregate(
        "distinct select on columns"
        distinct_on: [promo_codes_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [promo_codes_order_by!]
        "filter the rows returned"
        where: promo_codes_bool_exp
    ): promo_codes_aggregate!
    "fetch data from the table: \"redirect_mappings\""
    redirect_mappings(
        "distinct select on columns"
        distinct_on: [redirect_mappings_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [redirect_mappings_order_by!]
        "filter the rows returned"
        where: redirect_mappings_bool_exp
    ): [redirect_mappings!]!
    "fetch aggregated fields from the table: \"redirect_mappings\""
    redirect_mappings_aggregate(
        "distinct select on columns"
        distinct_on: [redirect_mappings_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [redirect_mappings_order_by!]
        "filter the rows returned"
        where: redirect_mappings_bool_exp
    ): redirect_mappings_aggregate!
    "fetch data from the table: \"redirect_mappings\" using primary key columns"
    redirect_mappings_by_pk(from_slug: String!, kind: String!, to_slug: String!): redirect_mappings
    "fetch data from the table: \"resource_types\""
    resource_types(
        "distinct select on columns"
        distinct_on: [resource_types_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [resource_types_order_by!]
        "filter the rows returned"
        where: resource_types_bool_exp
    ): [resource_types!]!
    "fetch aggregated fields from the table: \"resource_types\""
    resource_types_aggregate(
        "distinct select on columns"
        distinct_on: [resource_types_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [resource_types_order_by!]
        "filter the rows returned"
        where: resource_types_bool_exp
    ): resource_types_aggregate!
    "fetch data from the table: \"resource_types\" using primary key columns"
    resource_types_by_pk(value: String!): resource_types
    "fetch data from the table: \"sessions\" using primary key columns"
    session(id: uuid!): sessions
    "An array relationship"
    sessions(
        "distinct select on columns"
        distinct_on: [sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [sessions_order_by!]
        "filter the rows returned"
        where: sessions_bool_exp
    ): [sessions!]!
    "An aggregate relationship"
    sessions_aggregate(
        "distinct select on columns"
        distinct_on: [sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [sessions_order_by!]
        "filter the rows returned"
        where: sessions_bool_exp
    ): sessions_aggregate!
    "fetch data from the table: \"stripe_customers\" using primary key columns"
    stripe_customer(userId: uuid!): stripe_customers
    "fetch data from the table: \"stripe_customers\""
    stripe_customers(
        "distinct select on columns"
        distinct_on: [stripe_customers_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [stripe_customers_order_by!]
        "filter the rows returned"
        where: stripe_customers_bool_exp
    ): [stripe_customers!]!
    "fetch aggregated fields from the table: \"stripe_customers\""
    stripe_customers_aggregate(
        "distinct select on columns"
        distinct_on: [stripe_customers_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [stripe_customers_order_by!]
        "filter the rows returned"
        where: stripe_customers_bool_exp
    ): stripe_customers_aggregate!
    "fetch data from the table: \"subscriptions\" using primary key columns"
    subscription(id: uuid!): subscriptions
    "fetch data from the table: \"subscription_status\""
    subscription_status(
        "distinct select on columns"
        distinct_on: [subscription_status_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [subscription_status_order_by!]
        "filter the rows returned"
        where: subscription_status_bool_exp
    ): [subscription_status!]!
    "fetch aggregated fields from the table: \"subscription_status\""
    subscription_status_aggregate(
        "distinct select on columns"
        distinct_on: [subscription_status_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [subscription_status_order_by!]
        "filter the rows returned"
        where: subscription_status_bool_exp
    ): subscription_status_aggregate!
    "fetch data from the table: \"subscription_status\" using primary key columns"
    subscription_status_by_pk(value: String!): subscription_status
    "fetch data from the table: \"subscriptions\""
    subscriptions(
        "distinct select on columns"
        distinct_on: [subscriptions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [subscriptions_order_by!]
        "filter the rows returned"
        where: subscriptions_bool_exp
    ): [subscriptions!]!
    "fetch aggregated fields from the table: \"subscriptions\""
    subscriptions_aggregate(
        "distinct select on columns"
        distinct_on: [subscriptions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [subscriptions_order_by!]
        "filter the rows returned"
        where: subscriptions_bool_exp
    ): subscriptions_aggregate!
    "fetch data from the table: \"teaching_styles\" using primary key columns"
    teaching_style(value: String!): teaching_styles
    "fetch data from the table: \"teaching_styles\""
    teaching_styles(
        "distinct select on columns"
        distinct_on: [teaching_styles_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [teaching_styles_order_by!]
        "filter the rows returned"
        where: teaching_styles_bool_exp
    ): [teaching_styles!]!
    "fetch aggregated fields from the table: \"teaching_styles\""
    teaching_styles_aggregate(
        "distinct select on columns"
        distinct_on: [teaching_styles_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [teaching_styles_order_by!]
        "filter the rows returned"
        where: teaching_styles_bool_exp
    ): teaching_styles_aggregate!
    "fetch data from the table: \"topics\" using primary key columns"
    topic(id: uuid!): topics
    "fetch data from the table: \"topics\""
    topics(
        "distinct select on columns"
        distinct_on: [topics_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [topics_order_by!]
        "filter the rows returned"
        where: topics_bool_exp
    ): [topics!]!
    "fetch aggregated fields from the table: \"topics\""
    topics_aggregate(
        "distinct select on columns"
        distinct_on: [topics_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [topics_order_by!]
        "filter the rows returned"
        where: topics_bool_exp
    ): topics_aggregate!
    "execute function \"upcomingClasses\" which returns \"enrollment_sessions\""
    upcomingClasses(
        "input parameters for function \"upcomingClasses\""
        args: upcomingClasses_args!
        "distinct select on columns"
        distinct_on: [enrollment_sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollment_sessions_order_by!]
        "filter the rows returned"
        where: enrollment_sessions_bool_exp
    ): [enrollment_sessions!]!
    "execute function \"upcomingClasses\" and query aggregates on result of table type \"enrollment_sessions\""
    upcomingClasses_aggregate(
        "input parameters for function \"upcomingClasses_aggregate\""
        args: upcomingClasses_args!
        "distinct select on columns"
        distinct_on: [enrollment_sessions_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollment_sessions_order_by!]
        "filter the rows returned"
        where: enrollment_sessions_bool_exp
    ): enrollment_sessions_aggregate!
    "fetch data from the table: \"update_entity_order_request\""
    update_entity_order_request(
        "distinct select on columns"
        distinct_on: [update_entity_order_request_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [update_entity_order_request_order_by!]
        "filter the rows returned"
        where: update_entity_order_request_bool_exp
    ): [update_entity_order_request!]!
    "fetch aggregated fields from the table: \"update_entity_order_request\""
    update_entity_order_request_aggregate(
        "distinct select on columns"
        distinct_on: [update_entity_order_request_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [update_entity_order_request_order_by!]
        "filter the rows returned"
        where: update_entity_order_request_bool_exp
    ): update_entity_order_request_aggregate!
    "fetch data from the table: \"update_entity_order_request\" using primary key columns"
    update_entity_order_request_by_pk(entityId: uuid!, order: Int!): update_entity_order_request
    "fetch data from the table: \"uploads\" using primary key columns"
    upload(id: uuid!): uploads
    "fetch data from the table: \"uploads\""
    uploads(
        "distinct select on columns"
        distinct_on: [uploads_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [uploads_order_by!]
        "filter the rows returned"
        where: uploads_bool_exp
    ): [uploads!]!
    "fetch aggregated fields from the table: \"uploads\""
    uploads_aggregate(
        "distinct select on columns"
        distinct_on: [uploads_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [uploads_order_by!]
        "filter the rows returned"
        where: uploads_bool_exp
    ): uploads_aggregate!
    "fetch data from the table: \"user_class_preferences\" using primary key columns"
    use_class_preference(preferenceValue: class_tags_enum!, userId: uuid!): user_class_preferences
    "fetch data from the table: \"users\" using primary key columns"
    user(id: uuid!): users
    "fetch data from the table: \"user_details\""
    userDetails(
        "distinct select on columns"
        distinct_on: [user_details_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [user_details_order_by!]
        "filter the rows returned"
        where: user_details_bool_exp
    ): [user_details!]!
    "fetch data from the table: \"user_class_preferences\""
    user_class_preferences(
        "distinct select on columns"
        distinct_on: [user_class_preferences_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [user_class_preferences_order_by!]
        "filter the rows returned"
        where: user_class_preferences_bool_exp
    ): [user_class_preferences!]!
    "fetch aggregated fields from the table: \"user_class_preferences\""
    user_class_preferences_aggregate(
        "distinct select on columns"
        distinct_on: [user_class_preferences_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [user_class_preferences_order_by!]
        "filter the rows returned"
        where: user_class_preferences_bool_exp
    ): user_class_preferences_aggregate!
    "fetch aggregated fields from the table: \"user_details\""
    user_details_aggregate(
        "distinct select on columns"
        distinct_on: [user_details_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [user_details_order_by!]
        "filter the rows returned"
        where: user_details_bool_exp
    ): user_details_aggregate!
    "fetch data from the table: \"user_roles\""
    user_roles(
        "distinct select on columns"
        distinct_on: [user_roles_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [user_roles_order_by!]
        "filter the rows returned"
        where: user_roles_bool_exp
    ): [user_roles!]!
    "fetch aggregated fields from the table: \"user_roles\""
    user_roles_aggregate(
        "distinct select on columns"
        distinct_on: [user_roles_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [user_roles_order_by!]
        "filter the rows returned"
        where: user_roles_bool_exp
    ): user_roles_aggregate!
    "fetch data from the table: \"user_roles\" using primary key columns"
    user_roles_by_pk(value: String!): user_roles
    "fetch data from the table: \"user_teaching_style_preferences\" using primary key columns"
    user_teaching_style_preference(
        preferenceValue: teaching_styles_enum!
        userId: uuid!
    ): user_teaching_style_preferences
    "fetch data from the table: \"user_teaching_style_preferences\""
    user_teaching_style_preferences(
        "distinct select on columns"
        distinct_on: [user_teaching_style_preferences_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [user_teaching_style_preferences_order_by!]
        "filter the rows returned"
        where: user_teaching_style_preferences_bool_exp
    ): [user_teaching_style_preferences!]!
    "fetch aggregated fields from the table: \"user_teaching_style_preferences\""
    user_teaching_style_preferences_aggregate(
        "distinct select on columns"
        distinct_on: [user_teaching_style_preferences_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [user_teaching_style_preferences_order_by!]
        "filter the rows returned"
        where: user_teaching_style_preferences_bool_exp
    ): user_teaching_style_preferences_aggregate!
    "fetch data from the table: \"users\""
    users(
        "distinct select on columns"
        distinct_on: [users_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [users_order_by!]
        "filter the rows returned"
        where: users_bool_exp
    ): [users!]!
    "fetch aggregated fields from the table: \"users\""
    users_aggregate(
        "distinct select on columns"
        distinct_on: [users_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [users_order_by!]
        "filter the rows returned"
        where: users_bool_exp
    ): users_aggregate!
}

"columns and relationships of \"subscription_status\""
type subscription_status {
    description: String!
    value: String!
}

"aggregated selection of \"subscription_status\""
type subscription_status_aggregate {
    aggregate: subscription_status_aggregate_fields
    nodes: [subscription_status!]!
}

"aggregate fields of \"subscription_status\""
type subscription_status_aggregate_fields {
    count(columns: [subscription_status_select_column!], distinct: Boolean): Int!
    max: subscription_status_max_fields
    min: subscription_status_min_fields
}

"aggregate max on columns"
type subscription_status_max_fields {
    description: String
    value: String
}

"aggregate min on columns"
type subscription_status_min_fields {
    description: String
    value: String
}

"response of any mutation on the table \"subscription_status\""
type subscription_status_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [subscription_status!]!
}

"columns and relationships of \"subscriptions\""
type subscriptions {
    cancelAt: timestamptz
    createdAt: timestamptz!
    id: uuid!
    "An object relationship"
    price: product_prices!
    productPriceId: String!
    status: subscription_status_enum!
    stripeObject("JSON select path" path: String): json!
    stripePendingInvoiceId: String
    stripeSubscriptionId: String!
    stripeSubscriptionItemId: String
    updatedAt: timestamptz!
    "An object relationship"
    user: users!
    userId: uuid!
}

"aggregated selection of \"subscriptions\""
type subscriptions_aggregate {
    aggregate: subscriptions_aggregate_fields
    nodes: [subscriptions!]!
}

"aggregate fields of \"subscriptions\""
type subscriptions_aggregate_fields {
    count(columns: [subscriptions_select_column!], distinct: Boolean): Int!
    max: subscriptions_max_fields
    min: subscriptions_min_fields
}

"aggregate max on columns"
type subscriptions_max_fields {
    cancelAt: timestamptz
    createdAt: timestamptz
    id: uuid
    productPriceId: String
    stripePendingInvoiceId: String
    stripeSubscriptionId: String
    stripeSubscriptionItemId: String
    updatedAt: timestamptz
    userId: uuid
}

"aggregate min on columns"
type subscriptions_min_fields {
    cancelAt: timestamptz
    createdAt: timestamptz
    id: uuid
    productPriceId: String
    stripePendingInvoiceId: String
    stripeSubscriptionId: String
    stripeSubscriptionItemId: String
    updatedAt: timestamptz
    userId: uuid
}

"response of any mutation on the table \"subscriptions\""
type subscriptions_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [subscriptions!]!
}

"columns and relationships of \"teaching_styles\""
type teaching_styles {
    description: String!
    value: String!
}

"aggregated selection of \"teaching_styles\""
type teaching_styles_aggregate {
    aggregate: teaching_styles_aggregate_fields
    nodes: [teaching_styles!]!
}

"aggregate fields of \"teaching_styles\""
type teaching_styles_aggregate_fields {
    count(columns: [teaching_styles_select_column!], distinct: Boolean): Int!
    max: teaching_styles_max_fields
    min: teaching_styles_min_fields
}

"aggregate max on columns"
type teaching_styles_max_fields {
    description: String
    value: String
}

"aggregate min on columns"
type teaching_styles_min_fields {
    description: String
    value: String
}

"response of any mutation on the table \"teaching_styles\""
type teaching_styles_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [teaching_styles!]!
}

"columns and relationships of \"topics\""
type topics {
    id: uuid!
    "An object relationship"
    mask: uploads
    maskUploadId: uuid
    name: String!
    order: Int
    primaryColor: String!
    secondaryColor: String!
    shapeType: String
    slug: String!
}

"aggregated selection of \"topics\""
type topics_aggregate {
    aggregate: topics_aggregate_fields
    nodes: [topics!]!
}

"aggregate fields of \"topics\""
type topics_aggregate_fields {
    avg: topics_avg_fields
    count(columns: [topics_select_column!], distinct: Boolean): Int!
    max: topics_max_fields
    min: topics_min_fields
    stddev: topics_stddev_fields
    stddev_pop: topics_stddev_pop_fields
    stddev_samp: topics_stddev_samp_fields
    sum: topics_sum_fields
    var_pop: topics_var_pop_fields
    var_samp: topics_var_samp_fields
    variance: topics_variance_fields
}

"aggregate avg on columns"
type topics_avg_fields {
    order: Float
}

"aggregate max on columns"
type topics_max_fields {
    id: uuid
    maskUploadId: uuid
    name: String
    order: Int
    primaryColor: String
    secondaryColor: String
    shapeType: String
    slug: String
}

"aggregate min on columns"
type topics_min_fields {
    id: uuid
    maskUploadId: uuid
    name: String
    order: Int
    primaryColor: String
    secondaryColor: String
    shapeType: String
    slug: String
}

"response of any mutation on the table \"topics\""
type topics_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [topics!]!
}

"aggregate stddev on columns"
type topics_stddev_fields {
    order: Float
}

"aggregate stddev_pop on columns"
type topics_stddev_pop_fields {
    order: Float
}

"aggregate stddev_samp on columns"
type topics_stddev_samp_fields {
    order: Float
}

"aggregate sum on columns"
type topics_sum_fields {
    order: Int
}

"aggregate var_pop on columns"
type topics_var_pop_fields {
    order: Float
}

"aggregate var_samp on columns"
type topics_var_samp_fields {
    order: Float
}

"aggregate variance on columns"
type topics_variance_fields {
    order: Float
}

"columns and relationships of \"update_entity_order_request\""
type update_entity_order_request {
    entityId: uuid!
    entityTable: orderable_entities_enum!
    order: Int!
}

"aggregated selection of \"update_entity_order_request\""
type update_entity_order_request_aggregate {
    aggregate: update_entity_order_request_aggregate_fields
    nodes: [update_entity_order_request!]!
}

"aggregate fields of \"update_entity_order_request\""
type update_entity_order_request_aggregate_fields {
    avg: update_entity_order_request_avg_fields
    count(columns: [update_entity_order_request_select_column!], distinct: Boolean): Int!
    max: update_entity_order_request_max_fields
    min: update_entity_order_request_min_fields
    stddev: update_entity_order_request_stddev_fields
    stddev_pop: update_entity_order_request_stddev_pop_fields
    stddev_samp: update_entity_order_request_stddev_samp_fields
    sum: update_entity_order_request_sum_fields
    var_pop: update_entity_order_request_var_pop_fields
    var_samp: update_entity_order_request_var_samp_fields
    variance: update_entity_order_request_variance_fields
}

"aggregate avg on columns"
type update_entity_order_request_avg_fields {
    order: Float
}

"aggregate max on columns"
type update_entity_order_request_max_fields {
    entityId: uuid
    order: Int
}

"aggregate min on columns"
type update_entity_order_request_min_fields {
    entityId: uuid
    order: Int
}

"response of any mutation on the table \"update_entity_order_request\""
type update_entity_order_request_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [update_entity_order_request!]!
}

"aggregate stddev on columns"
type update_entity_order_request_stddev_fields {
    order: Float
}

"aggregate stddev_pop on columns"
type update_entity_order_request_stddev_pop_fields {
    order: Float
}

"aggregate stddev_samp on columns"
type update_entity_order_request_stddev_samp_fields {
    order: Float
}

"aggregate sum on columns"
type update_entity_order_request_sum_fields {
    order: Int
}

"aggregate var_pop on columns"
type update_entity_order_request_var_pop_fields {
    order: Float
}

"aggregate var_samp on columns"
type update_entity_order_request_var_samp_fields {
    order: Float
}

"aggregate variance on columns"
type update_entity_order_request_variance_fields {
    order: Float
}

"columns and relationships of \"uploads\""
type uploads {
    bucket: String
    createdAt: timestamptz!
    deletedAt: timestamptz
    id: uuid!
    mediaType: String
    name: String
    size: Int
    updatedAt: timestamptz!
    "A computed field, executes function \"get_upload_url\""
    url: String
}

"aggregated selection of \"uploads\""
type uploads_aggregate {
    aggregate: uploads_aggregate_fields
    nodes: [uploads!]!
}

"aggregate fields of \"uploads\""
type uploads_aggregate_fields {
    avg: uploads_avg_fields
    count(columns: [uploads_select_column!], distinct: Boolean): Int!
    max: uploads_max_fields
    min: uploads_min_fields
    stddev: uploads_stddev_fields
    stddev_pop: uploads_stddev_pop_fields
    stddev_samp: uploads_stddev_samp_fields
    sum: uploads_sum_fields
    var_pop: uploads_var_pop_fields
    var_samp: uploads_var_samp_fields
    variance: uploads_variance_fields
}

"aggregate avg on columns"
type uploads_avg_fields {
    size: Float
}

"aggregate max on columns"
type uploads_max_fields {
    bucket: String
    createdAt: timestamptz
    deletedAt: timestamptz
    id: uuid
    mediaType: String
    name: String
    size: Int
    updatedAt: timestamptz
}

"aggregate min on columns"
type uploads_min_fields {
    bucket: String
    createdAt: timestamptz
    deletedAt: timestamptz
    id: uuid
    mediaType: String
    name: String
    size: Int
    updatedAt: timestamptz
}

"response of any mutation on the table \"uploads\""
type uploads_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [uploads!]!
}

"aggregate stddev on columns"
type uploads_stddev_fields {
    size: Float
}

"aggregate stddev_pop on columns"
type uploads_stddev_pop_fields {
    size: Float
}

"aggregate stddev_samp on columns"
type uploads_stddev_samp_fields {
    size: Float
}

"aggregate sum on columns"
type uploads_sum_fields {
    size: Int
}

"aggregate var_pop on columns"
type uploads_var_pop_fields {
    size: Float
}

"aggregate var_samp on columns"
type uploads_var_samp_fields {
    size: Float
}

"aggregate variance on columns"
type uploads_variance_fields {
    size: Float
}

"columns and relationships of \"user_class_preferences\""
type user_class_preferences {
    "An object relationship"
    preference: class_tags!
    preferenceValue: class_tags_enum!
    "An object relationship"
    user: users!
    userId: uuid!
}

"aggregated selection of \"user_class_preferences\""
type user_class_preferences_aggregate {
    aggregate: user_class_preferences_aggregate_fields
    nodes: [user_class_preferences!]!
}

"aggregate fields of \"user_class_preferences\""
type user_class_preferences_aggregate_fields {
    count(columns: [user_class_preferences_select_column!], distinct: Boolean): Int!
    max: user_class_preferences_max_fields
    min: user_class_preferences_min_fields
}

"aggregate max on columns"
type user_class_preferences_max_fields {
    userId: uuid
}

"aggregate min on columns"
type user_class_preferences_min_fields {
    userId: uuid
}

"response of any mutation on the table \"user_class_preferences\""
type user_class_preferences_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [user_class_preferences!]!
}

"columns and relationships of \"user_details\""
type user_details {
    avatarId: uuid
    createdAt: timestamptz
    email: citext
    firstName: String
    fullName: citext
    hasConfirmed: Boolean
    id: uuid
    lastName: String
    role: String
    "An object relationship"
    subscription: subscriptions
    updatedAt: timestamptz
}

"aggregated selection of \"user_details\""
type user_details_aggregate {
    aggregate: user_details_aggregate_fields
    nodes: [user_details!]!
}

"aggregate fields of \"user_details\""
type user_details_aggregate_fields {
    count(columns: [user_details_select_column!], distinct: Boolean): Int!
    max: user_details_max_fields
    min: user_details_min_fields
}

"aggregate max on columns"
type user_details_max_fields {
    avatarId: uuid
    createdAt: timestamptz
    email: citext
    firstName: String
    fullName: citext
    id: uuid
    lastName: String
    role: String
    updatedAt: timestamptz
}

"aggregate min on columns"
type user_details_min_fields {
    avatarId: uuid
    createdAt: timestamptz
    email: citext
    firstName: String
    fullName: citext
    id: uuid
    lastName: String
    role: String
    updatedAt: timestamptz
}

"response of any mutation on the table \"user_details\""
type user_details_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [user_details!]!
}

"columns and relationships of \"user_roles\""
type user_roles {
    description: String!
    value: String!
}

"aggregated selection of \"user_roles\""
type user_roles_aggregate {
    aggregate: user_roles_aggregate_fields
    nodes: [user_roles!]!
}

"aggregate fields of \"user_roles\""
type user_roles_aggregate_fields {
    count(columns: [user_roles_select_column!], distinct: Boolean): Int!
    max: user_roles_max_fields
    min: user_roles_min_fields
}

"aggregate max on columns"
type user_roles_max_fields {
    description: String
    value: String
}

"aggregate min on columns"
type user_roles_min_fields {
    description: String
    value: String
}

"response of any mutation on the table \"user_roles\""
type user_roles_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [user_roles!]!
}

"columns and relationships of \"user_teaching_style_preferences\""
type user_teaching_style_preferences {
    "An object relationship"
    preference: teaching_styles!
    preferenceValue: teaching_styles_enum!
    "An object relationship"
    user: users!
    userId: uuid!
}

"aggregated selection of \"user_teaching_style_preferences\""
type user_teaching_style_preferences_aggregate {
    aggregate: user_teaching_style_preferences_aggregate_fields
    nodes: [user_teaching_style_preferences!]!
}

"aggregate fields of \"user_teaching_style_preferences\""
type user_teaching_style_preferences_aggregate_fields {
    count(columns: [user_teaching_style_preferences_select_column!], distinct: Boolean): Int!
    max: user_teaching_style_preferences_max_fields
    min: user_teaching_style_preferences_min_fields
}

"aggregate max on columns"
type user_teaching_style_preferences_max_fields {
    userId: uuid
}

"aggregate min on columns"
type user_teaching_style_preferences_min_fields {
    userId: uuid
}

"response of any mutation on the table \"user_teaching_style_preferences\""
type user_teaching_style_preferences_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [user_teaching_style_preferences!]!
}

"columns and relationships of \"users\""
type users {
    "An object relationship"
    avatar: uploads
    avatarId: uuid
    "An array relationship"
    books(
        "distinct select on columns"
        distinct_on: [educator_books_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_books_order_by!]
        "filter the rows returned"
        where: educator_books_bool_exp
    ): [educator_books!]!
    "An aggregate relationship"
    books_aggregate(
        "distinct select on columns"
        distinct_on: [educator_books_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_books_order_by!]
        "filter the rows returned"
        where: educator_books_bool_exp
    ): educator_books_aggregate!
    "An array relationship"
    courses(
        "distinct select on columns"
        distinct_on: [courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_order_by!]
        "filter the rows returned"
        where: courses_bool_exp
    ): [courses!]!
    "An aggregate relationship"
    courses_aggregate(
        "distinct select on columns"
        distinct_on: [courses_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [courses_order_by!]
        "filter the rows returned"
        where: courses_bool_exp
    ): courses_aggregate!
    createdAt: timestamptz!
    "An array relationship"
    educations(
        "distinct select on columns"
        distinct_on: [educator_educations_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_educations_order_by!]
        "filter the rows returned"
        where: educator_educations_bool_exp
    ): [educator_educations!]!
    "An aggregate relationship"
    educations_aggregate(
        "distinct select on columns"
        distinct_on: [educator_educations_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_educations_order_by!]
        "filter the rows returned"
        where: educator_educations_bool_exp
    ): educator_educations_aggregate!
    email: citext!
    "An array relationship"
    enrollments(
        "distinct select on columns"
        distinct_on: [enrollments_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollments_order_by!]
        "filter the rows returned"
        where: enrollments_bool_exp
    ): [enrollments!]!
    "An aggregate relationship"
    enrollments_aggregate(
        "distinct select on columns"
        distinct_on: [enrollments_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [enrollments_order_by!]
        "filter the rows returned"
        where: enrollments_bool_exp
    ): enrollments_aggregate!
    firstName: String!
    fullName: citext!
    hasConfirmed: Boolean!
    id: uuid!
    isMailchimpRegistered: Boolean
    lastName: String!
    "An object relationship"
    profile: educator_profiles
    "An array relationship"
    publications(
        "distinct select on columns"
        distinct_on: [educator_publications_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_publications_order_by!]
        "filter the rows returned"
        where: educator_publications_bool_exp
    ): [educator_publications!]!
    "An aggregate relationship"
    publications_aggregate(
        "distinct select on columns"
        distinct_on: [educator_publications_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_publications_order_by!]
        "filter the rows returned"
        where: educator_publications_bool_exp
    ): educator_publications_aggregate!
    role: user_roles_enum!
    "An object relationship"
    stripe: stripe_customers
    "An object relationship"
    subscription: subscriptions
    "An array relationship"
    teachingStyles(
        "distinct select on columns"
        distinct_on: [educator_teaching_styles_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_teaching_styles_order_by!]
        "filter the rows returned"
        where: educator_teaching_styles_bool_exp
    ): [educator_teaching_styles!]!
    "An aggregate relationship"
    teachingStyles_aggregate(
        "distinct select on columns"
        distinct_on: [educator_teaching_styles_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_teaching_styles_order_by!]
        "filter the rows returned"
        where: educator_teaching_styles_bool_exp
    ): educator_teaching_styles_aggregate!
    "An array relationship"
    testimonials(
        "distinct select on columns"
        distinct_on: [educator_testimonials_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_testimonials_order_by!]
        "filter the rows returned"
        where: educator_testimonials_bool_exp
    ): [educator_testimonials!]!
    "An aggregate relationship"
    testimonials_aggregate(
        "distinct select on columns"
        distinct_on: [educator_testimonials_select_column!]
        "limit the number of rows returned"
        limit: Int
        "skip the first n rows. Use only with order_by"
        offset: Int
        "sort the rows by one or more columns"
        order_by: [educator_testimonials_order_by!]
        "filter the rows returned"
        where: educator_testimonials_bool_exp
    ): educator_testimonials_aggregate!
    updatedAt: timestamptz
}

"aggregated selection of \"users\""
type users_aggregate {
    aggregate: users_aggregate_fields
    nodes: [users!]!
}

"aggregate fields of \"users\""
type users_aggregate_fields {
    count(columns: [users_select_column!], distinct: Boolean): Int!
    max: users_max_fields
    min: users_min_fields
}

"aggregate max on columns"
type users_max_fields {
    avatarId: uuid
    createdAt: timestamptz
    email: citext
    firstName: String
    fullName: citext
    id: uuid
    lastName: String
    updatedAt: timestamptz
}

"aggregate min on columns"
type users_min_fields {
    avatarId: uuid
    createdAt: timestamptz
    email: citext
    firstName: String
    fullName: citext
    id: uuid
    lastName: String
    updatedAt: timestamptz
}

"response of any mutation on the table \"users\""
type users_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [users!]!
}

"unique or primary key constraints on table \"class_tags\""
enum class_tags_constraint {
    "unique or primary key constraint"
    class_tags_pkey
}

enum class_tags_enum {
    "A Totally new Take"
    a_totally_new_take
    "Dynamic"
    dynamic
    "Highly Interactive"
    highly_interactive
    "Informal"
    informal
    "Intimate"
    intimate
    "Lively"
    lively
    "Multimedia"
    multimedia
    "Radical"
    radical
    "Rigorous"
    rigorous
    "Structured"
    structured
    "Surprising"
    surprising
    "Thought Provoking"
    thought_provoking
}

"select columns of table \"class_tags\""
enum class_tags_select_column {
    "column name"
    description
    "column name"
    value
}

"update columns of table \"class_tags\""
enum class_tags_update_column {
    "column name"
    description
    "column name"
    value
}

"unique or primary key constraints on table \"collection_courses\""
enum collection_courses_constraint {
    "unique or primary key constraint"
    collection_courses_collection_id_course_id_key
    "unique or primary key constraint"
    collection_courses_pkey
}

"select columns of table \"collection_courses\""
enum collection_courses_select_column {
    "column name"
    collectionId
    "column name"
    courseId
    "column name"
    id
    "column name"
    order
}

"update columns of table \"collection_courses\""
enum collection_courses_update_column {
    "column name"
    collectionId
    "column name"
    courseId
    "column name"
    id
    "column name"
    order
}

"unique or primary key constraints on table \"collections\""
enum collections_constraint {
    "unique or primary key constraint"
    collections_pkey
    "unique or primary key constraint"
    collections_slug_key
}

"select columns of table \"collections\""
enum collections_select_column {
    "column name"
    headline
    "column name"
    id
    "column name"
    imageId
    "column name"
    name
    "column name"
    slug
    "column name"
    topicId
}

"update columns of table \"collections\""
enum collections_update_column {
    "column name"
    headline
    "column name"
    id
    "column name"
    imageId
    "column name"
    name
    "column name"
    slug
    "column name"
    topicId
}

"unique or primary key constraints on table \"config_types\""
enum config_types_constraint {
    "unique or primary key constraint"
    config_types_pkey
}

enum config_types_enum {
    "Select collection to feature."
    featured_collection
    "Select the course to feature."
    featured_course
    "Select 4 courses for Curator's Pick section."
    featured_courses
    "Select up to 3 educators to featured."
    featured_educators
    "The max amount of featured educators to display."
    featured_max_educators
    "Address to Assets url"
    general_assets_url
    "Promo banner text. Wrap text with * to bold"
    general_promotion_text
    "Default al-a-carte price"
    pricing_default
    "Subscription Price"
    pricing_subscription
}

"select columns of table \"config_types\""
enum config_types_select_column {
    "column name"
    description
    "column name"
    value
}

"update columns of table \"config_types\""
enum config_types_update_column {
    "column name"
    description
    "column name"
    value
}

"unique or primary key constraints on table \"config_values\""
enum config_values_constraint {
    "unique or primary key constraint"
    config_values_pkey
}

"select columns of table \"config_values\""
enum config_values_select_column {
    "column name"
    configType
    "column name"
    format
    "column name"
    options
    "column name"
    value
}

"update columns of table \"config_values\""
enum config_values_update_column {
    "column name"
    configType
    "column name"
    format
    "column name"
    options
    "column name"
    value
}

"unique or primary key constraints on table \"coupons\""
enum coupons_constraint {
    "unique or primary key constraint"
    coupons_pkey
}

"select columns of table \"coupons\""
enum coupons_select_column {
    "column name"
    amount
    "column name"
    discount
    "column name"
    id
    "column name"
    name
    "column name"
    stripeObject
}

"update columns of table \"coupons\""
enum coupons_update_column {
    "column name"
    amount
    "column name"
    discount
    "column name"
    id
    "column name"
    name
    "column name"
    stripeObject
}

"unique or primary key constraints on table \"course_resources\""
enum course_resources_constraint {
    "unique or primary key constraint"
    course_resources_pkey
}

"select columns of table \"course_resources\""
enum course_resources_select_column {
    "column name"
    courseId
    "column name"
    createdAt
    "column name"
    id
    "column name"
    link
    "column name"
    name
    "column name"
    resourceType
    "column name"
    uploadId
}

"update columns of table \"course_resources\""
enum course_resources_update_column {
    "column name"
    courseId
    "column name"
    createdAt
    "column name"
    id
    "column name"
    link
    "column name"
    name
    "column name"
    resourceType
    "column name"
    uploadId
}

"unique or primary key constraints on table \"course_tags\""
enum course_tags_constraint {
    "unique or primary key constraint"
    course_tags_course_id_class_tag_key
    "unique or primary key constraint"
    course_tags_pkey
}

"select columns of table \"course_tags\""
enum course_tags_select_column {
    "column name"
    classTag
    "column name"
    courseId
    "column name"
    id
}

"update columns of table \"course_tags\""
enum course_tags_update_column {
    "column name"
    classTag
    "column name"
    courseId
    "column name"
    id
}

"unique or primary key constraints on table \"course_types\""
enum course_types_constraint {
    "unique or primary key constraint"
    course_types_pkey
}

enum course_types_enum {
    "Live Lecture"
    live
}

"select columns of table \"course_types\""
enum course_types_select_column {
    "column name"
    description
    "column name"
    value
}

"update columns of table \"course_types\""
enum course_types_update_column {
    "column name"
    description
    "column name"
    value
}

"unique or primary key constraints on table \"courses\""
enum courses_constraint {
    "unique or primary key constraint"
    courses_pkey
    "unique or primary key constraint"
    courses_slug_key
}

"select columns of table \"courses_for_collection_assignment\""
enum courses_for_collection_assignment_select_column {
    "column name"
    course_type
    "column name"
    created_at
    "column name"
    day_of_week
    "column name"
    educator_id
    "column name"
    end_time
    "column name"
    headline
    "column name"
    id
    "column name"
    image_id
    "column name"
    max_session_ends_at
    "column name"
    max_session_starts_at
    "column name"
    min_session_ends_at
    "column name"
    min_session_starts_at
    "column name"
    name
    "column name"
    overview
    "column name"
    price_per_session
    "column name"
    published
    "column name"
    published_at
    "column name"
    slug
    "column name"
    start_time
    "column name"
    topic_id
    "column name"
    updated_at
}

"select columns of table \"courses\""
enum courses_select_column {
    "column name"
    courseType
    "column name"
    createdAt
    "column name"
    dayOfWeek
    "column name"
    educatorId
    "column name"
    endTime
    "column name"
    headline
    "column name"
    id
    "column name"
    imageId
    "column name"
    includeInSubscription
    "column name"
    mailchimpSegmentId
    "column name"
    maxSessionEndsAt
    "column name"
    maxSessionStartsAt
    "column name"
    minSessionEndsAt
    "column name"
    minSessionStartsAt
    "column name"
    name
    "column name"
    overview
    "column name"
    price
    "column name"
    published
    "column name"
    publishedAt
    "column name"
    slug
    "column name"
    startTime
    "column name"
    topicId
    "column name"
    updatedAt
}

"update columns of table \"courses\""
enum courses_update_column {
    "column name"
    courseType
    "column name"
    createdAt
    "column name"
    dayOfWeek
    "column name"
    educatorId
    "column name"
    endTime
    "column name"
    headline
    "column name"
    id
    "column name"
    imageId
    "column name"
    includeInSubscription
    "column name"
    mailchimpSegmentId
    "column name"
    maxSessionEndsAt
    "column name"
    maxSessionStartsAt
    "column name"
    minSessionEndsAt
    "column name"
    minSessionStartsAt
    "column name"
    name
    "column name"
    overview
    "column name"
    price
    "column name"
    published
    "column name"
    publishedAt
    "column name"
    slug
    "column name"
    startTime
    "column name"
    topicId
    "column name"
    updatedAt
}

"unique or primary key constraints on table \"educator_books\""
enum educator_books_constraint {
    "unique or primary key constraint"
    educator_books_pkey
}

"select columns of table \"educator_books\""
enum educator_books_select_column {
    "column name"
    educatorId
    "column name"
    id
    "column name"
    imageId
    "column name"
    link
    "column name"
    name
    "column name"
    order
    "column name"
    year
}

"update columns of table \"educator_books\""
enum educator_books_update_column {
    "column name"
    educatorId
    "column name"
    id
    "column name"
    imageId
    "column name"
    link
    "column name"
    name
    "column name"
    order
    "column name"
    year
}

"unique or primary key constraints on table \"educator_educations\""
enum educator_educations_constraint {
    "unique or primary key constraint"
    educator_educations_pkey
}

"select columns of table \"educator_educations\""
enum educator_educations_select_column {
    "column name"
    educatorId
    "column name"
    id
    "column name"
    imageId
    "column name"
    order
    "column name"
    title
}

"update columns of table \"educator_educations\""
enum educator_educations_update_column {
    "column name"
    educatorId
    "column name"
    id
    "column name"
    imageId
    "column name"
    order
    "column name"
    title
}

"unique or primary key constraints on table \"educator_profiles\""
enum educator_profiles_constraint {
    "unique or primary key constraint"
    educator_profiles_pkey
}

"select columns of table \"educator_profiles\""
enum educator_profiles_select_column {
    "column name"
    awardsAndFeatures
    "column name"
    bio
    "column name"
    educatorId
    "column name"
    prefix
    "column name"
    primaryTopicId
    "column name"
    tagline
}

"update columns of table \"educator_profiles\""
enum educator_profiles_update_column {
    "column name"
    awardsAndFeatures
    "column name"
    bio
    "column name"
    educatorId
    "column name"
    prefix
    "column name"
    primaryTopicId
    "column name"
    tagline
}

"unique or primary key constraints on table \"educator_publications\""
enum educator_publications_constraint {
    "unique or primary key constraint"
    educator_publications_pkey
}

"select columns of table \"educator_publications\""
enum educator_publications_select_column {
    "column name"
    createdAt
    "column name"
    educatorId
    "column name"
    id
    "column name"
    imageId
    "column name"
    link
    "column name"
    order
    "column name"
    title
    "column name"
    updatedAt
    "column name"
    year
}

"update columns of table \"educator_publications\""
enum educator_publications_update_column {
    "column name"
    createdAt
    "column name"
    educatorId
    "column name"
    id
    "column name"
    imageId
    "column name"
    link
    "column name"
    order
    "column name"
    title
    "column name"
    updatedAt
    "column name"
    year
}

"unique or primary key constraints on table \"educator_teaching_styles\""
enum educator_teaching_styles_constraint {
    "unique or primary key constraint"
    educator_teaching_styles_educator_id_style_key
    "unique or primary key constraint"
    educator_teaching_styles_pkey
}

"select columns of table \"educator_teaching_styles\""
enum educator_teaching_styles_select_column {
    "column name"
    educatorId
    "column name"
    style
}

"update columns of table \"educator_teaching_styles\""
enum educator_teaching_styles_update_column {
    "column name"
    educatorId
    "column name"
    style
}

"unique or primary key constraints on table \"educator_testimonials\""
enum educator_testimonials_constraint {
    "unique or primary key constraint"
    educator_testimonials_pkey
}

"select columns of table \"educator_testimonials\""
enum educator_testimonials_select_column {
    "column name"
    content
    "column name"
    educatorId
    "column name"
    id
    "column name"
    order
    "column name"
    subTitle
    "column name"
    title
}

"update columns of table \"educator_testimonials\""
enum educator_testimonials_update_column {
    "column name"
    content
    "column name"
    educatorId
    "column name"
    id
    "column name"
    order
    "column name"
    subTitle
    "column name"
    title
}

"select columns of table \"educator_topics\""
enum educator_topics_select_column {
    "column name"
    id
    "column name"
    mask_upload_id
    "column name"
    name
    "column name"
    order
    "column name"
    primary_color
    "column name"
    secondary_color
    "column name"
    slug
}

"select columns of table \"educators\""
enum educators_select_column {
    "column name"
    avatarId
    "column name"
    created_at
    "column name"
    email
    "column name"
    firstName
    "column name"
    fullName
    "column name"
    has_confirmed
    "column name"
    id
    "column name"
    is_mailchimp_registered
    "column name"
    lastName
    "column name"
    role
    "column name"
    slug
    "column name"
    updated_at
}

"unique or primary key constraints on table \"enrollment_sessions\""
enum enrollment_sessions_constraint {
    "unique or primary key constraint"
    enrollment_sessions_pkey
}

"select columns of table \"enrollment_sessions\""
enum enrollment_sessions_select_column {
    "column name"
    courseId
    "column name"
    enrollmentId
    "column name"
    id
    "column name"
    sessionId
    "column name"
    userId
}

"update columns of table \"enrollment_sessions\""
enum enrollment_sessions_update_column {
    "column name"
    courseId
    "column name"
    enrollmentId
    "column name"
    id
    "column name"
    sessionId
    "column name"
    userId
}

"unique or primary key constraints on table \"enrollments\""
enum enrollments_constraint {
    "unique or primary key constraint"
    enrollments_pkey
    "unique or primary key constraint"
    enrollments_user_id_course_id_key
}

"select columns of table \"enrollments\""
enum enrollments_select_column {
    "column name"
    courseId
    "column name"
    createdAt
    "column name"
    id
    "column name"
    userId
    "column name"
    withSubscription
}

"update columns of table \"enrollments\""
enum enrollments_update_column {
    "column name"
    courseId
    "column name"
    createdAt
    "column name"
    id
    "column name"
    userId
    "column name"
    withSubscription
}

"select columns of table \"my_enrolled_sessions\""
enum my_enrolled_sessions_select_column {
    "column name"
    enrollment_id
    "column name"
    session_id
    "column name"
    user_id
}

"column ordering options"
enum order_by {
    "in ascending order, nulls last"
    asc
    "in ascending order, nulls first"
    asc_nulls_first
    "in ascending order, nulls last"
    asc_nulls_last
    "in descending order, nulls first"
    desc
    "in descending order, nulls first"
    desc_nulls_first
    "in descending order, nulls last"
    desc_nulls_last
}

"unique or primary key constraints on table \"orderable_entities\""
enum orderable_entities_constraint {
    "unique or primary key constraint"
    orderable_entities_pkey
}

enum orderable_entities_enum {
    "Collection Courses"
    collection_courses
    "Educator Books"
    educator_books
    "Educator Educations"
    educator_educations
    "Educator Testimonial"
    educator_testimonials
    "Topcis"
    topics
}

"select columns of table \"orderable_entities\""
enum orderable_entities_select_column {
    "column name"
    description
    "column name"
    value
}

"update columns of table \"orderable_entities\""
enum orderable_entities_update_column {
    "column name"
    description
    "column name"
    value
}

"unique or primary key constraints on table \"orders\""
enum orders_constraint {
    "unique or primary key constraint"
    orders_pkey
}

"select columns of table \"orders\""
enum orders_select_column {
    "column name"
    amount
    "column name"
    createdAt
    "column name"
    enrollmentId
    "column name"
    id
    "column name"
    lastKnownEvent
    "column name"
    promoId
    "column name"
    stripeInvoiceId
    "column name"
    stripeUrl
    "column name"
    userId
    "column name"
    withSubscription
}

"update columns of table \"orders\""
enum orders_update_column {
    "column name"
    amount
    "column name"
    createdAt
    "column name"
    enrollmentId
    "column name"
    id
    "column name"
    lastKnownEvent
    "column name"
    promoId
    "column name"
    stripeInvoiceId
    "column name"
    stripeUrl
    "column name"
    userId
    "column name"
    withSubscription
}

"unique or primary key constraints on table \"organization\""
enum organization_constraint {
    "unique or primary key constraint"
    organization_pkey
}

"select columns of table \"organization\""
enum organization_select_column {
    "column name"
    id
    "column name"
    name
}

"update columns of table \"organization\""
enum organization_update_column {
    "column name"
    id
    "column name"
    name
}

enum plan_interval_types {
    mo
    yr
}

"unique or primary key constraints on table \"product_prices\""
enum product_prices_constraint {
    "unique or primary key constraint"
    product_prices_pkey
}

"select columns of table \"product_prices\""
enum product_prices_select_column {
    "column name"
    active
    "column name"
    amount
    "column name"
    id
    "column name"
    productId
    "column name"
    stripeObject
}

"update columns of table \"product_prices\""
enum product_prices_update_column {
    "column name"
    active
    "column name"
    amount
    "column name"
    id
    "column name"
    productId
    "column name"
    stripeObject
}

"unique or primary key constraints on table \"products\""
enum products_constraint {
    "unique or primary key constraint"
    products_pkey
}

"select columns of table \"products\""
enum products_select_column {
    "column name"
    id
    "column name"
    name
    "column name"
    stripeObject
}

"update columns of table \"products\""
enum products_update_column {
    "column name"
    id
    "column name"
    name
    "column name"
    stripeObject
}

"unique or primary key constraints on table \"promo_codes\""
enum promo_codes_constraint {
    "unique or primary key constraint"
    promo_codes_pkey
}

"select columns of table \"promo_codes\""
enum promo_codes_select_column {
    "column name"
    active
    "column name"
    code
    "column name"
    couponId
    "column name"
    id
    "column name"
    stripeObject
}

"update columns of table \"promo_codes\""
enum promo_codes_update_column {
    "column name"
    active
    "column name"
    code
    "column name"
    couponId
    "column name"
    id
    "column name"
    stripeObject
}

"unique or primary key constraints on table \"redirect_mappings\""
enum redirect_mappings_constraint {
    "unique or primary key constraint"
    redirect_mappings_pkey
}

"select columns of table \"redirect_mappings\""
enum redirect_mappings_select_column {
    "column name"
    code
    "column name"
    from_slug
    "column name"
    kind
    "column name"
    to_slug
}

"update columns of table \"redirect_mappings\""
enum redirect_mappings_update_column {
    "column name"
    code
    "column name"
    from_slug
    "column name"
    kind
    "column name"
    to_slug
}

"unique or primary key constraints on table \"resource_types\""
enum resource_types_constraint {
    "unique or primary key constraint"
    resource_types_pkey
}

enum resource_types_enum {
    "Describes that the resource is a file"
    FILE
    "Describes that the resource is a link"
    LINK
}

"select columns of table \"resource_types\""
enum resource_types_select_column {
    "column name"
    description
    "column name"
    value
}

"update columns of table \"resource_types\""
enum resource_types_update_column {
    "column name"
    description
    "column name"
    value
}

"unique or primary key constraints on table \"sessions\""
enum sessions_constraint {
    "unique or primary key constraint"
    sessions_pkey
}

"select columns of table \"sessions\""
enum sessions_select_column {
    "column name"
    cancelled
    "column name"
    courseId
    "column name"
    createdAt
    "column name"
    endTime
    "column name"
    id
    "column name"
    mailchimpCampaignId
    "column name"
    protectedMeetingLink
    "column name"
    protectedRecordingLink
    "column name"
    startTime
    "column name"
    title
    "column name"
    updatedAt
}

"update columns of table \"sessions\""
enum sessions_update_column {
    "column name"
    cancelled
    "column name"
    courseId
    "column name"
    createdAt
    "column name"
    endTime
    "column name"
    id
    "column name"
    mailchimpCampaignId
    "column name"
    protectedMeetingLink
    "column name"
    protectedRecordingLink
    "column name"
    startTime
    "column name"
    title
    "column name"
    updatedAt
}

"unique or primary key constraints on table \"stripe_customers\""
enum stripe_customers_constraint {
    "unique or primary key constraint"
    stripe_customers_pkey
}

"select columns of table \"stripe_customers\""
enum stripe_customers_select_column {
    "column name"
    customerId
    "column name"
    userId
}

"update columns of table \"stripe_customers\""
enum stripe_customers_update_column {
    "column name"
    customerId
    "column name"
    userId
}

"unique or primary key constraints on table \"subscription_status\""
enum subscription_status_constraint {
    "unique or primary key constraint"
    subscription_status_pkey
}

enum subscription_status_enum {
    "Subscription is active and up to date."
    active
    "Subscription has been cancelled."
    canceled
    "Initial payment attempt failed"
    incomplete
    "First invoice is not paid within 23 hours"
    incomplete_expired
    "Subscription is passed due."
    past_due
    "Currently in trial mode."
    trialing
    "Subscription is active but needs payment."
    unpaid
}

"select columns of table \"subscription_status\""
enum subscription_status_select_column {
    "column name"
    description
    "column name"
    value
}

"update columns of table \"subscription_status\""
enum subscription_status_update_column {
    "column name"
    description
    "column name"
    value
}

"unique or primary key constraints on table \"subscriptions\""
enum subscriptions_constraint {
    "unique or primary key constraint"
    subscriptions_pkey
    "unique or primary key constraint"
    subscriptions_user_id_key
}

"select columns of table \"subscriptions\""
enum subscriptions_select_column {
    "column name"
    cancelAt
    "column name"
    createdAt
    "column name"
    id
    "column name"
    productPriceId
    "column name"
    status
    "column name"
    stripeObject
    "column name"
    stripePendingInvoiceId
    "column name"
    stripeSubscriptionId
    "column name"
    stripeSubscriptionItemId
    "column name"
    updatedAt
    "column name"
    userId
}

"update columns of table \"subscriptions\""
enum subscriptions_update_column {
    "column name"
    cancelAt
    "column name"
    createdAt
    "column name"
    id
    "column name"
    productPriceId
    "column name"
    status
    "column name"
    stripeObject
    "column name"
    stripePendingInvoiceId
    "column name"
    stripeSubscriptionId
    "column name"
    stripeSubscriptionItemId
    "column name"
    updatedAt
    "column name"
    userId
}

"unique or primary key constraints on table \"teaching_styles\""
enum teaching_styles_constraint {
    "unique or primary key constraint"
    teaching_styles_pkey
}

enum teaching_styles_enum {
    "Accessible"
    accessible
    "Beloved"
    beloved
    "Creative"
    creative
    "Engaging"
    engaging
    "Funny"
    funny
    "Innovative"
    innovative
    "Passionate"
    passionate
    "Rigorous"
    rigorous
}

"select columns of table \"teaching_styles\""
enum teaching_styles_select_column {
    "column name"
    description
    "column name"
    value
}

"update columns of table \"teaching_styles\""
enum teaching_styles_update_column {
    "column name"
    description
    "column name"
    value
}

"unique or primary key constraints on table \"topics\""
enum topics_constraint {
    "unique or primary key constraint"
    topics_pkey
    "unique or primary key constraint"
    topics_slug_key
}

"select columns of table \"topics\""
enum topics_select_column {
    "column name"
    id
    "column name"
    maskUploadId
    "column name"
    name
    "column name"
    order
    "column name"
    primaryColor
    "column name"
    secondaryColor
    "column name"
    shapeType
    "column name"
    slug
}

"update columns of table \"topics\""
enum topics_update_column {
    "column name"
    id
    "column name"
    maskUploadId
    "column name"
    name
    "column name"
    order
    "column name"
    primaryColor
    "column name"
    secondaryColor
    "column name"
    shapeType
    "column name"
    slug
}

"unique or primary key constraints on table \"update_entity_order_request\""
enum update_entity_order_request_constraint {
    "unique or primary key constraint"
    update_entity_order_request_pkey
}

"select columns of table \"update_entity_order_request\""
enum update_entity_order_request_select_column {
    "column name"
    entityId
    "column name"
    entityTable
    "column name"
    order
}

"update columns of table \"update_entity_order_request\""
enum update_entity_order_request_update_column {
    "column name"
    entityId
    "column name"
    entityTable
    "column name"
    order
}

"unique or primary key constraints on table \"uploads\""
enum uploads_constraint {
    "unique or primary key constraint"
    uploads_pkey
}

"select columns of table \"uploads\""
enum uploads_select_column {
    "column name"
    bucket
    "column name"
    createdAt
    "column name"
    deletedAt
    "column name"
    id
    "column name"
    mediaType
    "column name"
    name
    "column name"
    size
    "column name"
    updatedAt
}

"update columns of table \"uploads\""
enum uploads_update_column {
    "column name"
    bucket
    "column name"
    createdAt
    "column name"
    deletedAt
    "column name"
    id
    "column name"
    mediaType
    "column name"
    name
    "column name"
    size
    "column name"
    updatedAt
}

"unique or primary key constraints on table \"user_class_preferences\""
enum user_class_preferences_constraint {
    "unique or primary key constraint"
    user_class_preferences_pkey
}

"select columns of table \"user_class_preferences\""
enum user_class_preferences_select_column {
    "column name"
    preferenceValue
    "column name"
    userId
}

"update columns of table \"user_class_preferences\""
enum user_class_preferences_update_column {
    "column name"
    preferenceValue
    "column name"
    userId
}

"select columns of table \"user_details\""
enum user_details_select_column {
    "column name"
    avatarId
    "column name"
    createdAt
    "column name"
    email
    "column name"
    firstName
    "column name"
    fullName
    "column name"
    hasConfirmed
    "column name"
    id
    "column name"
    lastName
    "column name"
    role
    "column name"
    updatedAt
}

"unique or primary key constraints on table \"user_roles\""
enum user_roles_constraint {
    "unique or primary key constraint"
    user_roles_pkey
}

enum user_roles_enum {
    "Dashboard Admin"
    dashboard
    "Educator"
    educator
    "Partner"
    partner
    "User role"
    user
}

"select columns of table \"user_roles\""
enum user_roles_select_column {
    "column name"
    description
    "column name"
    value
}

"update columns of table \"user_roles\""
enum user_roles_update_column {
    "column name"
    description
    "column name"
    value
}

"unique or primary key constraints on table \"user_teaching_style_preferences\""
enum user_teaching_style_preferences_constraint {
    "unique or primary key constraint"
    user_teaching_style_preferences_pkey
}

"select columns of table \"user_teaching_style_preferences\""
enum user_teaching_style_preferences_select_column {
    "column name"
    preferenceValue
    "column name"
    userId
}

"update columns of table \"user_teaching_style_preferences\""
enum user_teaching_style_preferences_update_column {
    "column name"
    preferenceValue
    "column name"
    userId
}

"unique or primary key constraints on table \"users\""
enum users_constraint {
    "unique or primary key constraint"
    users_pkey
}

"select columns of table \"users\""
enum users_select_column {
    "column name"
    avatarId
    "column name"
    createdAt
    "column name"
    email
    "column name"
    firstName
    "column name"
    fullName
    "column name"
    hasConfirmed
    "column name"
    id
    "column name"
    isMailchimpRegistered
    "column name"
    lastName
    "column name"
    role
    "column name"
    updatedAt
}

"update columns of table \"users\""
enum users_update_column {
    "column name"
    avatarId
    "column name"
    createdAt
    "column name"
    email
    "column name"
    firstName
    "column name"
    fullName
    "column name"
    hasConfirmed
    "column name"
    id
    "column name"
    isMailchimpRegistered
    "column name"
    lastName
    "column name"
    role
    "column name"
    updatedAt
}

scalar _update_entity_order_request

scalar citext

scalar json

scalar numeric

scalar timestamptz

scalar timetz

scalar uuid

"Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'."
input Boolean_comparison_exp {
    _eq: Boolean
    _gt: Boolean
    _gte: Boolean
    _in: [Boolean!]
    _is_null: Boolean
    _lt: Boolean
    _lte: Boolean
    _neq: Boolean
    _nin: [Boolean!]
}

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input Int_comparison_exp {
    _eq: Int
    _gt: Int
    _gte: Int
    _in: [Int!]
    _is_null: Boolean
    _lt: Int
    _lte: Int
    _neq: Int
    _nin: [Int!]
}

input Preferences {
    courses: [String!]
    teachingStyles: [String!]
}

input SignupInput {
    avatarId: String
    email: String!
    firstName: String!
    lastName: String!
    password: String
    preferences: Preferences
    role: String
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_comparison_exp {
    _eq: String
    _gt: String
    _gte: String
    "does the column match the given case-insensitive pattern"
    _ilike: String
    _in: [String!]
    "does the column match the given POSIX regular expression, case insensitive"
    _iregex: String
    _is_null: Boolean
    "does the column match the given pattern"
    _like: String
    _lt: String
    _lte: String
    _neq: String
    "does the column NOT match the given case-insensitive pattern"
    _nilike: String
    _nin: [String!]
    "does the column NOT match the given POSIX regular expression, case insensitive"
    _niregex: String
    "does the column NOT match the given pattern"
    _nlike: String
    "does the column NOT match the given POSIX regular expression, case sensitive"
    _nregex: String
    "does the column NOT match the given SQL regular expression"
    _nsimilar: String
    "does the column match the given POSIX regular expression, case sensitive"
    _regex: String
    "does the column match the given SQL regular expression"
    _similar: String
}

"Boolean expression to compare columns of type \"citext\". All fields are combined with logical 'AND'."
input citext_comparison_exp {
    _eq: citext
    _gt: citext
    _gte: citext
    "does the column match the given case-insensitive pattern"
    _ilike: citext
    _in: [citext!]
    "does the column match the given POSIX regular expression, case insensitive"
    _iregex: citext
    _is_null: Boolean
    "does the column match the given pattern"
    _like: citext
    _lt: citext
    _lte: citext
    _neq: citext
    "does the column NOT match the given case-insensitive pattern"
    _nilike: citext
    _nin: [citext!]
    "does the column NOT match the given POSIX regular expression, case insensitive"
    _niregex: citext
    "does the column NOT match the given pattern"
    _nlike: citext
    "does the column NOT match the given POSIX regular expression, case sensitive"
    _nregex: citext
    "does the column NOT match the given SQL regular expression"
    _nsimilar: citext
    "does the column match the given POSIX regular expression, case sensitive"
    _regex: citext
    "does the column match the given SQL regular expression"
    _similar: citext
}

"Boolean expression to filter rows from the table \"class_tags\". All fields are combined with a logical 'AND'."
input class_tags_bool_exp {
    _and: [class_tags_bool_exp!]
    _not: class_tags_bool_exp
    _or: [class_tags_bool_exp!]
    description: String_comparison_exp
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"class_tags_enum\". All fields are combined with logical 'AND'."
input class_tags_enum_comparison_exp {
    _eq: class_tags_enum
    _in: [class_tags_enum!]
    _is_null: Boolean
    _neq: class_tags_enum
    _nin: [class_tags_enum!]
}

"input type for inserting data into table \"class_tags\""
input class_tags_insert_input {
    description: String
    value: String
}

"input type for inserting object relation for remote table \"class_tags\""
input class_tags_obj_rel_insert_input {
    data: class_tags_insert_input!
    "on conflict condition"
    on_conflict: class_tags_on_conflict
}

"on conflict condition type for table \"class_tags\""
input class_tags_on_conflict {
    constraint: class_tags_constraint!
    update_columns: [class_tags_update_column!]! = []
    where: class_tags_bool_exp
}

"Ordering options when selecting data from \"class_tags\"."
input class_tags_order_by {
    description: order_by
    value: order_by
}

"primary key columns input for table: class_tags"
input class_tags_pk_columns_input {
    value: String!
}

"input type for updating data in table \"class_tags\""
input class_tags_set_input {
    description: String
    value: String
}

input collection_by_slug_args {
    _slug: String
}

"order by aggregate values of table \"collection_courses\""
input collection_courses_aggregate_order_by {
    avg: collection_courses_avg_order_by
    count: order_by
    max: collection_courses_max_order_by
    min: collection_courses_min_order_by
    stddev: collection_courses_stddev_order_by
    stddev_pop: collection_courses_stddev_pop_order_by
    stddev_samp: collection_courses_stddev_samp_order_by
    sum: collection_courses_sum_order_by
    var_pop: collection_courses_var_pop_order_by
    var_samp: collection_courses_var_samp_order_by
    variance: collection_courses_variance_order_by
}

"input type for inserting array relation for remote table \"collection_courses\""
input collection_courses_arr_rel_insert_input {
    data: [collection_courses_insert_input!]!
    "on conflict condition"
    on_conflict: collection_courses_on_conflict
}

"order by avg() on columns of table \"collection_courses\""
input collection_courses_avg_order_by {
    order: order_by
}

"Boolean expression to filter rows from the table \"collection_courses\". All fields are combined with a logical 'AND'."
input collection_courses_bool_exp {
    _and: [collection_courses_bool_exp!]
    _not: collection_courses_bool_exp
    _or: [collection_courses_bool_exp!]
    collection: collections_bool_exp
    collectionId: uuid_comparison_exp
    course: courses_bool_exp
    courseId: uuid_comparison_exp
    id: uuid_comparison_exp
    order: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"collection_courses\""
input collection_courses_inc_input {
    order: Int
}

"input type for inserting data into table \"collection_courses\""
input collection_courses_insert_input {
    collection: collections_obj_rel_insert_input
    collectionId: uuid
    course: courses_obj_rel_insert_input
    courseId: uuid
    id: uuid
    order: Int
}

"order by max() on columns of table \"collection_courses\""
input collection_courses_max_order_by {
    collectionId: order_by
    courseId: order_by
    id: order_by
    order: order_by
}

"order by min() on columns of table \"collection_courses\""
input collection_courses_min_order_by {
    collectionId: order_by
    courseId: order_by
    id: order_by
    order: order_by
}

"on conflict condition type for table \"collection_courses\""
input collection_courses_on_conflict {
    constraint: collection_courses_constraint!
    update_columns: [collection_courses_update_column!]! = []
    where: collection_courses_bool_exp
}

"Ordering options when selecting data from \"collection_courses\"."
input collection_courses_order_by {
    collection: collections_order_by
    collectionId: order_by
    course: courses_order_by
    courseId: order_by
    id: order_by
    order: order_by
}

"primary key columns input for table: collection_courses"
input collection_courses_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"collection_courses\""
input collection_courses_set_input {
    collectionId: uuid
    courseId: uuid
    id: uuid
    order: Int
}

"order by stddev() on columns of table \"collection_courses\""
input collection_courses_stddev_order_by {
    order: order_by
}

"order by stddev_pop() on columns of table \"collection_courses\""
input collection_courses_stddev_pop_order_by {
    order: order_by
}

"order by stddev_samp() on columns of table \"collection_courses\""
input collection_courses_stddev_samp_order_by {
    order: order_by
}

"order by sum() on columns of table \"collection_courses\""
input collection_courses_sum_order_by {
    order: order_by
}

"order by var_pop() on columns of table \"collection_courses\""
input collection_courses_var_pop_order_by {
    order: order_by
}

"order by var_samp() on columns of table \"collection_courses\""
input collection_courses_var_samp_order_by {
    order: order_by
}

"order by variance() on columns of table \"collection_courses\""
input collection_courses_variance_order_by {
    order: order_by
}

"order by aggregate values of table \"collections\""
input collections_aggregate_order_by {
    count: order_by
    max: collections_max_order_by
    min: collections_min_order_by
}

"Boolean expression to filter rows from the table \"collections\". All fields are combined with a logical 'AND'."
input collections_bool_exp {
    _and: [collections_bool_exp!]
    _not: collections_bool_exp
    _or: [collections_bool_exp!]
    collection_courses: collection_courses_bool_exp
    headline: String_comparison_exp
    id: uuid_comparison_exp
    image: uploads_bool_exp
    imageId: uuid_comparison_exp
    name: String_comparison_exp
    slug: String_comparison_exp
    topic: topics_bool_exp
    topicId: uuid_comparison_exp
}

"input type for inserting data into table \"collections\""
input collections_insert_input {
    collection_courses: collection_courses_arr_rel_insert_input
    headline: String
    id: uuid
    image: uploads_obj_rel_insert_input
    imageId: uuid
    name: String
    slug: String
    topic: topics_obj_rel_insert_input
    topicId: uuid
}

"order by max() on columns of table \"collections\""
input collections_max_order_by {
    headline: order_by
    id: order_by
    imageId: order_by
    name: order_by
    slug: order_by
    topicId: order_by
}

"order by min() on columns of table \"collections\""
input collections_min_order_by {
    headline: order_by
    id: order_by
    imageId: order_by
    name: order_by
    slug: order_by
    topicId: order_by
}

"input type for inserting object relation for remote table \"collections\""
input collections_obj_rel_insert_input {
    data: collections_insert_input!
    "on conflict condition"
    on_conflict: collections_on_conflict
}

"on conflict condition type for table \"collections\""
input collections_on_conflict {
    constraint: collections_constraint!
    update_columns: [collections_update_column!]! = []
    where: collections_bool_exp
}

"Ordering options when selecting data from \"collections\"."
input collections_order_by {
    collection_courses_aggregate: collection_courses_aggregate_order_by
    headline: order_by
    id: order_by
    image: uploads_order_by
    imageId: order_by
    name: order_by
    slug: order_by
    topic: topics_order_by
    topicId: order_by
}

"primary key columns input for table: collections"
input collections_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"collections\""
input collections_set_input {
    headline: String
    id: uuid
    imageId: uuid
    name: String
    slug: String
    topicId: uuid
}

"Boolean expression to filter rows from the table \"config_types\". All fields are combined with a logical 'AND'."
input config_types_bool_exp {
    _and: [config_types_bool_exp!]
    _not: config_types_bool_exp
    _or: [config_types_bool_exp!]
    description: String_comparison_exp
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"config_types_enum\". All fields are combined with logical 'AND'."
input config_types_enum_comparison_exp {
    _eq: config_types_enum
    _in: [config_types_enum!]
    _is_null: Boolean
    _neq: config_types_enum
    _nin: [config_types_enum!]
}

"input type for inserting data into table \"config_types\""
input config_types_insert_input {
    description: String
    value: String
}

"input type for inserting object relation for remote table \"config_types\""
input config_types_obj_rel_insert_input {
    data: config_types_insert_input!
    "on conflict condition"
    on_conflict: config_types_on_conflict
}

"on conflict condition type for table \"config_types\""
input config_types_on_conflict {
    constraint: config_types_constraint!
    update_columns: [config_types_update_column!]! = []
    where: config_types_bool_exp
}

"Ordering options when selecting data from \"config_types\"."
input config_types_order_by {
    description: order_by
    value: order_by
}

"primary key columns input for table: config_types"
input config_types_pk_columns_input {
    value: String!
}

"input type for updating data in table \"config_types\""
input config_types_set_input {
    description: String
    value: String
}

"Boolean expression to filter rows from the table \"config_values\". All fields are combined with a logical 'AND'."
input config_values_bool_exp {
    _and: [config_values_bool_exp!]
    _not: config_values_bool_exp
    _or: [config_values_bool_exp!]
    configType: config_types_enum_comparison_exp
    descriptor: config_types_bool_exp
    format: String_comparison_exp
    options: json_comparison_exp
    relationships: json_comparison_exp
    value: json_comparison_exp
}

"input type for inserting data into table \"config_values\""
input config_values_insert_input {
    configType: config_types_enum
    descriptor: config_types_obj_rel_insert_input
    format: String
    options: json
    value: json
}

"on conflict condition type for table \"config_values\""
input config_values_on_conflict {
    constraint: config_values_constraint!
    update_columns: [config_values_update_column!]! = []
    where: config_values_bool_exp
}

"Ordering options when selecting data from \"config_values\"."
input config_values_order_by {
    configType: order_by
    descriptor: config_types_order_by
    format: order_by
    options: order_by
    relationships: order_by
    value: order_by
}

"primary key columns input for table: config_values"
input config_values_pk_columns_input {
    configType: config_types_enum!
}

"input type for updating data in table \"config_values\""
input config_values_set_input {
    configType: config_types_enum
    format: String
    options: json
    value: json
}

"Boolean expression to filter rows from the table \"coupons\". All fields are combined with a logical 'AND'."
input coupons_bool_exp {
    _and: [coupons_bool_exp!]
    _not: coupons_bool_exp
    _or: [coupons_bool_exp!]
    amount: Int_comparison_exp
    discount: String_comparison_exp
    id: String_comparison_exp
    name: String_comparison_exp
    stripeObject: json_comparison_exp
}

"input type for incrementing numeric columns in table \"coupons\""
input coupons_inc_input {
    amount: Int
}

"input type for inserting data into table \"coupons\""
input coupons_insert_input {
    amount: Int
    discount: String
    id: String
    name: String
    stripeObject: json
}

"input type for inserting object relation for remote table \"coupons\""
input coupons_obj_rel_insert_input {
    data: coupons_insert_input!
    "on conflict condition"
    on_conflict: coupons_on_conflict
}

"on conflict condition type for table \"coupons\""
input coupons_on_conflict {
    constraint: coupons_constraint!
    update_columns: [coupons_update_column!]! = []
    where: coupons_bool_exp
}

"Ordering options when selecting data from \"coupons\"."
input coupons_order_by {
    amount: order_by
    discount: order_by
    id: order_by
    name: order_by
    stripeObject: order_by
}

"primary key columns input for table: coupons"
input coupons_pk_columns_input {
    id: String!
}

"input type for updating data in table \"coupons\""
input coupons_set_input {
    amount: Int
    discount: String
    id: String
    name: String
    stripeObject: json
}

input course_by_slug_args {
    _slug: String
}

"order by aggregate values of table \"course_resources\""
input course_resources_aggregate_order_by {
    count: order_by
    max: course_resources_max_order_by
    min: course_resources_min_order_by
}

"input type for inserting array relation for remote table \"course_resources\""
input course_resources_arr_rel_insert_input {
    data: [course_resources_insert_input!]!
    "on conflict condition"
    on_conflict: course_resources_on_conflict
}

"Boolean expression to filter rows from the table \"course_resources\". All fields are combined with a logical 'AND'."
input course_resources_bool_exp {
    _and: [course_resources_bool_exp!]
    _not: course_resources_bool_exp
    _or: [course_resources_bool_exp!]
    course: courses_bool_exp
    courseId: uuid_comparison_exp
    createdAt: timestamptz_comparison_exp
    id: uuid_comparison_exp
    link: String_comparison_exp
    name: String_comparison_exp
    resourceType: resource_types_enum_comparison_exp
    upload: uploads_bool_exp
    uploadId: uuid_comparison_exp
}

"input type for inserting data into table \"course_resources\""
input course_resources_insert_input {
    course: courses_obj_rel_insert_input
    courseId: uuid
    createdAt: timestamptz
    id: uuid
    link: String
    name: String
    resourceType: resource_types_enum
    upload: uploads_obj_rel_insert_input
    uploadId: uuid
}

"order by max() on columns of table \"course_resources\""
input course_resources_max_order_by {
    courseId: order_by
    createdAt: order_by
    id: order_by
    link: order_by
    name: order_by
    uploadId: order_by
}

"order by min() on columns of table \"course_resources\""
input course_resources_min_order_by {
    courseId: order_by
    createdAt: order_by
    id: order_by
    link: order_by
    name: order_by
    uploadId: order_by
}

"on conflict condition type for table \"course_resources\""
input course_resources_on_conflict {
    constraint: course_resources_constraint!
    update_columns: [course_resources_update_column!]! = []
    where: course_resources_bool_exp
}

"Ordering options when selecting data from \"course_resources\"."
input course_resources_order_by {
    course: courses_order_by
    courseId: order_by
    createdAt: order_by
    id: order_by
    link: order_by
    name: order_by
    resourceType: order_by
    upload: uploads_order_by
    uploadId: order_by
}

"primary key columns input for table: course_resources"
input course_resources_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"course_resources\""
input course_resources_set_input {
    courseId: uuid
    createdAt: timestamptz
    id: uuid
    link: String
    name: String
    resourceType: resource_types_enum
    uploadId: uuid
}

"order by aggregate values of table \"course_tags\""
input course_tags_aggregate_order_by {
    count: order_by
    max: course_tags_max_order_by
    min: course_tags_min_order_by
}

"input type for inserting array relation for remote table \"course_tags\""
input course_tags_arr_rel_insert_input {
    data: [course_tags_insert_input!]!
    "on conflict condition"
    on_conflict: course_tags_on_conflict
}

"Boolean expression to filter rows from the table \"course_tags\". All fields are combined with a logical 'AND'."
input course_tags_bool_exp {
    _and: [course_tags_bool_exp!]
    _not: course_tags_bool_exp
    _or: [course_tags_bool_exp!]
    classTag: class_tags_enum_comparison_exp
    course: courses_bool_exp
    courseId: uuid_comparison_exp
    id: uuid_comparison_exp
    tag: class_tags_bool_exp
}

"input type for inserting data into table \"course_tags\""
input course_tags_insert_input {
    classTag: class_tags_enum
    course: courses_obj_rel_insert_input
    courseId: uuid
    id: uuid
    tag: class_tags_obj_rel_insert_input
}

"order by max() on columns of table \"course_tags\""
input course_tags_max_order_by {
    courseId: order_by
    id: order_by
}

"order by min() on columns of table \"course_tags\""
input course_tags_min_order_by {
    courseId: order_by
    id: order_by
}

"on conflict condition type for table \"course_tags\""
input course_tags_on_conflict {
    constraint: course_tags_constraint!
    update_columns: [course_tags_update_column!]! = []
    where: course_tags_bool_exp
}

"Ordering options when selecting data from \"course_tags\"."
input course_tags_order_by {
    classTag: order_by
    course: courses_order_by
    courseId: order_by
    id: order_by
    tag: class_tags_order_by
}

"primary key columns input for table: course_tags"
input course_tags_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"course_tags\""
input course_tags_set_input {
    classTag: class_tags_enum
    courseId: uuid
    id: uuid
}

"Boolean expression to filter rows from the table \"course_types\". All fields are combined with a logical 'AND'."
input course_types_bool_exp {
    _and: [course_types_bool_exp!]
    _not: course_types_bool_exp
    _or: [course_types_bool_exp!]
    description: String_comparison_exp
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"course_types_enum\". All fields are combined with logical 'AND'."
input course_types_enum_comparison_exp {
    _eq: course_types_enum
    _in: [course_types_enum!]
    _is_null: Boolean
    _neq: course_types_enum
    _nin: [course_types_enum!]
}

"input type for inserting data into table \"course_types\""
input course_types_insert_input {
    description: String
    value: String
}

"input type for inserting object relation for remote table \"course_types\""
input course_types_obj_rel_insert_input {
    data: course_types_insert_input!
    "on conflict condition"
    on_conflict: course_types_on_conflict
}

"on conflict condition type for table \"course_types\""
input course_types_on_conflict {
    constraint: course_types_constraint!
    update_columns: [course_types_update_column!]! = []
    where: course_types_bool_exp
}

"Ordering options when selecting data from \"course_types\"."
input course_types_order_by {
    description: order_by
    value: order_by
}

"primary key columns input for table: course_types"
input course_types_pk_columns_input {
    value: String!
}

"input type for updating data in table \"course_types\""
input course_types_set_input {
    description: String
    value: String
}

"order by aggregate values of table \"courses\""
input courses_aggregate_order_by {
    avg: courses_avg_order_by
    count: order_by
    max: courses_max_order_by
    min: courses_min_order_by
    stddev: courses_stddev_order_by
    stddev_pop: courses_stddev_pop_order_by
    stddev_samp: courses_stddev_samp_order_by
    sum: courses_sum_order_by
    var_pop: courses_var_pop_order_by
    var_samp: courses_var_samp_order_by
    variance: courses_variance_order_by
}

"input type for inserting array relation for remote table \"courses\""
input courses_arr_rel_insert_input {
    data: [courses_insert_input!]!
    "on conflict condition"
    on_conflict: courses_on_conflict
}

"order by avg() on columns of table \"courses\""
input courses_avg_order_by {
    dayOfWeek: order_by
    price: order_by
}

"Boolean expression to filter rows from the table \"courses\". All fields are combined with a logical 'AND'."
input courses_bool_exp {
    _and: [courses_bool_exp!]
    _not: courses_bool_exp
    _or: [courses_bool_exp!]
    collection: collections_bool_exp
    collections: collection_courses_bool_exp
    courseType: course_types_enum_comparison_exp
    courseTypeDescriptor: course_types_bool_exp
    createdAt: timestamptz_comparison_exp
    currentTotalPrice: numeric_comparison_exp
    dayOfWeek: Int_comparison_exp
    educator: educators_bool_exp
    educatorId: uuid_comparison_exp
    endTime: timetz_comparison_exp
    enrolled: Boolean_comparison_exp
    enrollments: enrollments_bool_exp
    headline: String_comparison_exp
    id: uuid_comparison_exp
    image: uploads_bool_exp
    imageId: uuid_comparison_exp
    includeInSubscription: Boolean_comparison_exp
    mailchimpSegmentId: String_comparison_exp
    maxSessionEndsAt: timestamptz_comparison_exp
    maxSessionStartsAt: timestamptz_comparison_exp
    minSessionEndsAt: timestamptz_comparison_exp
    minSessionStartsAt: timestamptz_comparison_exp
    name: String_comparison_exp
    overview: String_comparison_exp
    price: Int_comparison_exp
    published: Boolean_comparison_exp
    publishedAt: timestamptz_comparison_exp
    resources: course_resources_bool_exp
    sessions: sessions_bool_exp
    slug: String_comparison_exp
    startTime: timetz_comparison_exp
    tags: course_tags_bool_exp
    topic: topics_bool_exp
    topicId: uuid_comparison_exp
    updatedAt: timestamptz_comparison_exp
}

"Boolean expression to filter rows from the table \"courses_for_collection_assignment\". All fields are combined with a logical 'AND'."
input courses_for_collection_assignment_bool_exp {
    _and: [courses_for_collection_assignment_bool_exp!]
    _not: courses_for_collection_assignment_bool_exp
    _or: [courses_for_collection_assignment_bool_exp!]
    course_type: String_comparison_exp
    created_at: timestamptz_comparison_exp
    day_of_week: Int_comparison_exp
    educator_id: uuid_comparison_exp
    end_time: timetz_comparison_exp
    headline: String_comparison_exp
    id: uuid_comparison_exp
    image: uploads_bool_exp
    image_id: uuid_comparison_exp
    max_session_ends_at: timestamptz_comparison_exp
    max_session_starts_at: timestamptz_comparison_exp
    min_session_ends_at: timestamptz_comparison_exp
    min_session_starts_at: timestamptz_comparison_exp
    name: String_comparison_exp
    overview: String_comparison_exp
    price_per_session: Int_comparison_exp
    published: Boolean_comparison_exp
    published_at: timestamptz_comparison_exp
    slug: String_comparison_exp
    start_time: timetz_comparison_exp
    topic_id: uuid_comparison_exp
    updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"courses_for_collection_assignment\"."
input courses_for_collection_assignment_order_by {
    course_type: order_by
    created_at: order_by
    day_of_week: order_by
    educator_id: order_by
    end_time: order_by
    headline: order_by
    id: order_by
    image: uploads_order_by
    image_id: order_by
    max_session_ends_at: order_by
    max_session_starts_at: order_by
    min_session_ends_at: order_by
    min_session_starts_at: order_by
    name: order_by
    overview: order_by
    price_per_session: order_by
    published: order_by
    published_at: order_by
    slug: order_by
    start_time: order_by
    topic_id: order_by
    updated_at: order_by
}

"input type for incrementing numeric columns in table \"courses\""
input courses_inc_input {
    dayOfWeek: Int
    price: Int
}

"input type for inserting data into table \"courses\""
input courses_insert_input {
    collections: collection_courses_arr_rel_insert_input
    courseType: course_types_enum
    courseTypeDescriptor: course_types_obj_rel_insert_input
    createdAt: timestamptz
    dayOfWeek: Int
    educator: educators_obj_rel_insert_input
    educatorId: uuid
    endTime: timetz
    enrollments: enrollments_arr_rel_insert_input
    headline: String
    id: uuid
    image: uploads_obj_rel_insert_input
    imageId: uuid
    includeInSubscription: Boolean
    mailchimpSegmentId: String
    maxSessionEndsAt: timestamptz
    maxSessionStartsAt: timestamptz
    minSessionEndsAt: timestamptz
    minSessionStartsAt: timestamptz
    name: String
    overview: String
    price: Int
    published: Boolean
    publishedAt: timestamptz
    resources: course_resources_arr_rel_insert_input
    sessions: sessions_arr_rel_insert_input
    slug: String
    startTime: timetz
    tags: course_tags_arr_rel_insert_input
    topic: topics_obj_rel_insert_input
    topicId: uuid
    updatedAt: timestamptz
}

"order by max() on columns of table \"courses\""
input courses_max_order_by {
    createdAt: order_by
    dayOfWeek: order_by
    educatorId: order_by
    endTime: order_by
    headline: order_by
    id: order_by
    imageId: order_by
    mailchimpSegmentId: order_by
    maxSessionEndsAt: order_by
    maxSessionStartsAt: order_by
    minSessionEndsAt: order_by
    minSessionStartsAt: order_by
    name: order_by
    overview: order_by
    price: order_by
    publishedAt: order_by
    slug: order_by
    startTime: order_by
    topicId: order_by
    updatedAt: order_by
}

"order by min() on columns of table \"courses\""
input courses_min_order_by {
    createdAt: order_by
    dayOfWeek: order_by
    educatorId: order_by
    endTime: order_by
    headline: order_by
    id: order_by
    imageId: order_by
    mailchimpSegmentId: order_by
    maxSessionEndsAt: order_by
    maxSessionStartsAt: order_by
    minSessionEndsAt: order_by
    minSessionStartsAt: order_by
    name: order_by
    overview: order_by
    price: order_by
    publishedAt: order_by
    slug: order_by
    startTime: order_by
    topicId: order_by
    updatedAt: order_by
}

"input type for inserting object relation for remote table \"courses\""
input courses_obj_rel_insert_input {
    data: courses_insert_input!
    "on conflict condition"
    on_conflict: courses_on_conflict
}

"on conflict condition type for table \"courses\""
input courses_on_conflict {
    constraint: courses_constraint!
    update_columns: [courses_update_column!]! = []
    where: courses_bool_exp
}

"Ordering options when selecting data from \"courses\"."
input courses_order_by {
    collection_aggregate: collections_aggregate_order_by
    collections_aggregate: collection_courses_aggregate_order_by
    courseType: order_by
    courseTypeDescriptor: course_types_order_by
    createdAt: order_by
    currentTotalPrice: order_by
    dayOfWeek: order_by
    educator: educators_order_by
    educatorId: order_by
    endTime: order_by
    enrolled: order_by
    enrollments_aggregate: enrollments_aggregate_order_by
    headline: order_by
    id: order_by
    image: uploads_order_by
    imageId: order_by
    includeInSubscription: order_by
    mailchimpSegmentId: order_by
    maxSessionEndsAt: order_by
    maxSessionStartsAt: order_by
    minSessionEndsAt: order_by
    minSessionStartsAt: order_by
    name: order_by
    overview: order_by
    price: order_by
    published: order_by
    publishedAt: order_by
    resources_aggregate: course_resources_aggregate_order_by
    sessions_aggregate: sessions_aggregate_order_by
    slug: order_by
    startTime: order_by
    tags_aggregate: course_tags_aggregate_order_by
    topic: topics_order_by
    topicId: order_by
    updatedAt: order_by
}

"primary key columns input for table: courses"
input courses_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"courses\""
input courses_set_input {
    courseType: course_types_enum
    createdAt: timestamptz
    dayOfWeek: Int
    educatorId: uuid
    endTime: timetz
    headline: String
    id: uuid
    imageId: uuid
    includeInSubscription: Boolean
    mailchimpSegmentId: String
    maxSessionEndsAt: timestamptz
    maxSessionStartsAt: timestamptz
    minSessionEndsAt: timestamptz
    minSessionStartsAt: timestamptz
    name: String
    overview: String
    price: Int
    published: Boolean
    publishedAt: timestamptz
    slug: String
    startTime: timetz
    topicId: uuid
    updatedAt: timestamptz
}

"order by stddev() on columns of table \"courses\""
input courses_stddev_order_by {
    dayOfWeek: order_by
    price: order_by
}

"order by stddev_pop() on columns of table \"courses\""
input courses_stddev_pop_order_by {
    dayOfWeek: order_by
    price: order_by
}

"order by stddev_samp() on columns of table \"courses\""
input courses_stddev_samp_order_by {
    dayOfWeek: order_by
    price: order_by
}

"order by sum() on columns of table \"courses\""
input courses_sum_order_by {
    dayOfWeek: order_by
    price: order_by
}

"order by var_pop() on columns of table \"courses\""
input courses_var_pop_order_by {
    dayOfWeek: order_by
    price: order_by
}

"order by var_samp() on columns of table \"courses\""
input courses_var_samp_order_by {
    dayOfWeek: order_by
    price: order_by
}

"order by variance() on columns of table \"courses\""
input courses_variance_order_by {
    dayOfWeek: order_by
    price: order_by
}

"order by aggregate values of table \"educator_books\""
input educator_books_aggregate_order_by {
    avg: educator_books_avg_order_by
    count: order_by
    max: educator_books_max_order_by
    min: educator_books_min_order_by
    stddev: educator_books_stddev_order_by
    stddev_pop: educator_books_stddev_pop_order_by
    stddev_samp: educator_books_stddev_samp_order_by
    sum: educator_books_sum_order_by
    var_pop: educator_books_var_pop_order_by
    var_samp: educator_books_var_samp_order_by
    variance: educator_books_variance_order_by
}

"input type for inserting array relation for remote table \"educator_books\""
input educator_books_arr_rel_insert_input {
    data: [educator_books_insert_input!]!
    "on conflict condition"
    on_conflict: educator_books_on_conflict
}

"order by avg() on columns of table \"educator_books\""
input educator_books_avg_order_by {
    order: order_by
    year: order_by
}

"Boolean expression to filter rows from the table \"educator_books\". All fields are combined with a logical 'AND'."
input educator_books_bool_exp {
    _and: [educator_books_bool_exp!]
    _not: educator_books_bool_exp
    _or: [educator_books_bool_exp!]
    cover: uploads_bool_exp
    educator: users_bool_exp
    educatorId: uuid_comparison_exp
    id: uuid_comparison_exp
    imageId: uuid_comparison_exp
    link: String_comparison_exp
    name: String_comparison_exp
    order: Int_comparison_exp
    year: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"educator_books\""
input educator_books_inc_input {
    order: Int
    year: Int
}

"input type for inserting data into table \"educator_books\""
input educator_books_insert_input {
    cover: uploads_obj_rel_insert_input
    educator: users_obj_rel_insert_input
    educatorId: uuid
    id: uuid
    imageId: uuid
    link: String
    name: String
    order: Int
    year: Int
}

"order by max() on columns of table \"educator_books\""
input educator_books_max_order_by {
    educatorId: order_by
    id: order_by
    imageId: order_by
    link: order_by
    name: order_by
    order: order_by
    year: order_by
}

"order by min() on columns of table \"educator_books\""
input educator_books_min_order_by {
    educatorId: order_by
    id: order_by
    imageId: order_by
    link: order_by
    name: order_by
    order: order_by
    year: order_by
}

"on conflict condition type for table \"educator_books\""
input educator_books_on_conflict {
    constraint: educator_books_constraint!
    update_columns: [educator_books_update_column!]! = []
    where: educator_books_bool_exp
}

"Ordering options when selecting data from \"educator_books\"."
input educator_books_order_by {
    cover: uploads_order_by
    educator: users_order_by
    educatorId: order_by
    id: order_by
    imageId: order_by
    link: order_by
    name: order_by
    order: order_by
    year: order_by
}

"primary key columns input for table: educator_books"
input educator_books_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"educator_books\""
input educator_books_set_input {
    educatorId: uuid
    id: uuid
    imageId: uuid
    link: String
    name: String
    order: Int
    year: Int
}

"order by stddev() on columns of table \"educator_books\""
input educator_books_stddev_order_by {
    order: order_by
    year: order_by
}

"order by stddev_pop() on columns of table \"educator_books\""
input educator_books_stddev_pop_order_by {
    order: order_by
    year: order_by
}

"order by stddev_samp() on columns of table \"educator_books\""
input educator_books_stddev_samp_order_by {
    order: order_by
    year: order_by
}

"order by sum() on columns of table \"educator_books\""
input educator_books_sum_order_by {
    order: order_by
    year: order_by
}

"order by var_pop() on columns of table \"educator_books\""
input educator_books_var_pop_order_by {
    order: order_by
    year: order_by
}

"order by var_samp() on columns of table \"educator_books\""
input educator_books_var_samp_order_by {
    order: order_by
    year: order_by
}

"order by variance() on columns of table \"educator_books\""
input educator_books_variance_order_by {
    order: order_by
    year: order_by
}

input educator_by_slug_args {
    _slug: String
}

"order by aggregate values of table \"educator_educations\""
input educator_educations_aggregate_order_by {
    avg: educator_educations_avg_order_by
    count: order_by
    max: educator_educations_max_order_by
    min: educator_educations_min_order_by
    stddev: educator_educations_stddev_order_by
    stddev_pop: educator_educations_stddev_pop_order_by
    stddev_samp: educator_educations_stddev_samp_order_by
    sum: educator_educations_sum_order_by
    var_pop: educator_educations_var_pop_order_by
    var_samp: educator_educations_var_samp_order_by
    variance: educator_educations_variance_order_by
}

"input type for inserting array relation for remote table \"educator_educations\""
input educator_educations_arr_rel_insert_input {
    data: [educator_educations_insert_input!]!
    "on conflict condition"
    on_conflict: educator_educations_on_conflict
}

"order by avg() on columns of table \"educator_educations\""
input educator_educations_avg_order_by {
    order: order_by
}

"Boolean expression to filter rows from the table \"educator_educations\". All fields are combined with a logical 'AND'."
input educator_educations_bool_exp {
    _and: [educator_educations_bool_exp!]
    _not: educator_educations_bool_exp
    _or: [educator_educations_bool_exp!]
    educator: users_bool_exp
    educatorId: uuid_comparison_exp
    id: uuid_comparison_exp
    image: uploads_bool_exp
    imageId: uuid_comparison_exp
    order: Int_comparison_exp
    title: String_comparison_exp
}

"input type for incrementing numeric columns in table \"educator_educations\""
input educator_educations_inc_input {
    order: Int
}

"input type for inserting data into table \"educator_educations\""
input educator_educations_insert_input {
    educator: users_obj_rel_insert_input
    educatorId: uuid
    id: uuid
    image: uploads_obj_rel_insert_input
    imageId: uuid
    order: Int
    title: String
}

"order by max() on columns of table \"educator_educations\""
input educator_educations_max_order_by {
    educatorId: order_by
    id: order_by
    imageId: order_by
    order: order_by
    title: order_by
}

"order by min() on columns of table \"educator_educations\""
input educator_educations_min_order_by {
    educatorId: order_by
    id: order_by
    imageId: order_by
    order: order_by
    title: order_by
}

"on conflict condition type for table \"educator_educations\""
input educator_educations_on_conflict {
    constraint: educator_educations_constraint!
    update_columns: [educator_educations_update_column!]! = []
    where: educator_educations_bool_exp
}

"Ordering options when selecting data from \"educator_educations\"."
input educator_educations_order_by {
    educator: users_order_by
    educatorId: order_by
    id: order_by
    image: uploads_order_by
    imageId: order_by
    order: order_by
    title: order_by
}

"primary key columns input for table: educator_educations"
input educator_educations_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"educator_educations\""
input educator_educations_set_input {
    educatorId: uuid
    id: uuid
    imageId: uuid
    order: Int
    title: String
}

"order by stddev() on columns of table \"educator_educations\""
input educator_educations_stddev_order_by {
    order: order_by
}

"order by stddev_pop() on columns of table \"educator_educations\""
input educator_educations_stddev_pop_order_by {
    order: order_by
}

"order by stddev_samp() on columns of table \"educator_educations\""
input educator_educations_stddev_samp_order_by {
    order: order_by
}

"order by sum() on columns of table \"educator_educations\""
input educator_educations_sum_order_by {
    order: order_by
}

"order by var_pop() on columns of table \"educator_educations\""
input educator_educations_var_pop_order_by {
    order: order_by
}

"order by var_samp() on columns of table \"educator_educations\""
input educator_educations_var_samp_order_by {
    order: order_by
}

"order by variance() on columns of table \"educator_educations\""
input educator_educations_variance_order_by {
    order: order_by
}

"Boolean expression to filter rows from the table \"educator_profiles\". All fields are combined with a logical 'AND'."
input educator_profiles_bool_exp {
    _and: [educator_profiles_bool_exp!]
    _not: educator_profiles_bool_exp
    _or: [educator_profiles_bool_exp!]
    awardsAndFeatures: String_comparison_exp
    bio: String_comparison_exp
    educator: educators_bool_exp
    educatorId: uuid_comparison_exp
    prefix: String_comparison_exp
    primaryTopicId: uuid_comparison_exp
    tagline: String_comparison_exp
    topic: topics_bool_exp
}

"input type for inserting data into table \"educator_profiles\""
input educator_profiles_insert_input {
    awardsAndFeatures: String
    bio: String
    educator: educators_obj_rel_insert_input
    educatorId: uuid
    prefix: String
    primaryTopicId: uuid
    tagline: String
    topic: topics_obj_rel_insert_input
}

"input type for inserting object relation for remote table \"educator_profiles\""
input educator_profiles_obj_rel_insert_input {
    data: educator_profiles_insert_input!
    "on conflict condition"
    on_conflict: educator_profiles_on_conflict
}

"on conflict condition type for table \"educator_profiles\""
input educator_profiles_on_conflict {
    constraint: educator_profiles_constraint!
    update_columns: [educator_profiles_update_column!]! = []
    where: educator_profiles_bool_exp
}

"Ordering options when selecting data from \"educator_profiles\"."
input educator_profiles_order_by {
    awardsAndFeatures: order_by
    bio: order_by
    educator: educators_order_by
    educatorId: order_by
    prefix: order_by
    primaryTopicId: order_by
    tagline: order_by
    topic: topics_order_by
}

"primary key columns input for table: educator_profiles"
input educator_profiles_pk_columns_input {
    educatorId: uuid!
}

"input type for updating data in table \"educator_profiles\""
input educator_profiles_set_input {
    awardsAndFeatures: String
    bio: String
    educatorId: uuid
    prefix: String
    primaryTopicId: uuid
    tagline: String
}

"order by aggregate values of table \"educator_publications\""
input educator_publications_aggregate_order_by {
    avg: educator_publications_avg_order_by
    count: order_by
    max: educator_publications_max_order_by
    min: educator_publications_min_order_by
    stddev: educator_publications_stddev_order_by
    stddev_pop: educator_publications_stddev_pop_order_by
    stddev_samp: educator_publications_stddev_samp_order_by
    sum: educator_publications_sum_order_by
    var_pop: educator_publications_var_pop_order_by
    var_samp: educator_publications_var_samp_order_by
    variance: educator_publications_variance_order_by
}

"input type for inserting array relation for remote table \"educator_publications\""
input educator_publications_arr_rel_insert_input {
    data: [educator_publications_insert_input!]!
    "on conflict condition"
    on_conflict: educator_publications_on_conflict
}

"order by avg() on columns of table \"educator_publications\""
input educator_publications_avg_order_by {
    order: order_by
    year: order_by
}

"Boolean expression to filter rows from the table \"educator_publications\". All fields are combined with a logical 'AND'."
input educator_publications_bool_exp {
    _and: [educator_publications_bool_exp!]
    _not: educator_publications_bool_exp
    _or: [educator_publications_bool_exp!]
    createdAt: timestamptz_comparison_exp
    educator: users_bool_exp
    educatorId: uuid_comparison_exp
    id: uuid_comparison_exp
    image: uploads_bool_exp
    imageId: uuid_comparison_exp
    link: String_comparison_exp
    order: Int_comparison_exp
    title: String_comparison_exp
    updatedAt: timestamptz_comparison_exp
    year: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"educator_publications\""
input educator_publications_inc_input {
    order: Int
    year: Int
}

"input type for inserting data into table \"educator_publications\""
input educator_publications_insert_input {
    createdAt: timestamptz
    educator: users_obj_rel_insert_input
    educatorId: uuid
    id: uuid
    image: uploads_obj_rel_insert_input
    imageId: uuid
    link: String
    order: Int
    title: String
    updatedAt: timestamptz
    year: Int
}

"order by max() on columns of table \"educator_publications\""
input educator_publications_max_order_by {
    createdAt: order_by
    educatorId: order_by
    id: order_by
    imageId: order_by
    link: order_by
    order: order_by
    title: order_by
    updatedAt: order_by
    year: order_by
}

"order by min() on columns of table \"educator_publications\""
input educator_publications_min_order_by {
    createdAt: order_by
    educatorId: order_by
    id: order_by
    imageId: order_by
    link: order_by
    order: order_by
    title: order_by
    updatedAt: order_by
    year: order_by
}

"on conflict condition type for table \"educator_publications\""
input educator_publications_on_conflict {
    constraint: educator_publications_constraint!
    update_columns: [educator_publications_update_column!]! = []
    where: educator_publications_bool_exp
}

"Ordering options when selecting data from \"educator_publications\"."
input educator_publications_order_by {
    createdAt: order_by
    educator: users_order_by
    educatorId: order_by
    id: order_by
    image: uploads_order_by
    imageId: order_by
    link: order_by
    order: order_by
    title: order_by
    updatedAt: order_by
    year: order_by
}

"primary key columns input for table: educator_publications"
input educator_publications_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"educator_publications\""
input educator_publications_set_input {
    createdAt: timestamptz
    educatorId: uuid
    id: uuid
    imageId: uuid
    link: String
    order: Int
    title: String
    updatedAt: timestamptz
    year: Int
}

"order by stddev() on columns of table \"educator_publications\""
input educator_publications_stddev_order_by {
    order: order_by
    year: order_by
}

"order by stddev_pop() on columns of table \"educator_publications\""
input educator_publications_stddev_pop_order_by {
    order: order_by
    year: order_by
}

"order by stddev_samp() on columns of table \"educator_publications\""
input educator_publications_stddev_samp_order_by {
    order: order_by
    year: order_by
}

"order by sum() on columns of table \"educator_publications\""
input educator_publications_sum_order_by {
    order: order_by
    year: order_by
}

"order by var_pop() on columns of table \"educator_publications\""
input educator_publications_var_pop_order_by {
    order: order_by
    year: order_by
}

"order by var_samp() on columns of table \"educator_publications\""
input educator_publications_var_samp_order_by {
    order: order_by
    year: order_by
}

"order by variance() on columns of table \"educator_publications\""
input educator_publications_variance_order_by {
    order: order_by
    year: order_by
}

"order by aggregate values of table \"educator_teaching_styles\""
input educator_teaching_styles_aggregate_order_by {
    count: order_by
    max: educator_teaching_styles_max_order_by
    min: educator_teaching_styles_min_order_by
}

"input type for inserting array relation for remote table \"educator_teaching_styles\""
input educator_teaching_styles_arr_rel_insert_input {
    data: [educator_teaching_styles_insert_input!]!
    "on conflict condition"
    on_conflict: educator_teaching_styles_on_conflict
}

"Boolean expression to filter rows from the table \"educator_teaching_styles\". All fields are combined with a logical 'AND'."
input educator_teaching_styles_bool_exp {
    _and: [educator_teaching_styles_bool_exp!]
    _not: educator_teaching_styles_bool_exp
    _or: [educator_teaching_styles_bool_exp!]
    educator: users_bool_exp
    educatorId: uuid_comparison_exp
    style: teaching_styles_enum_comparison_exp
    teachingStyle: teaching_styles_bool_exp
}

"input type for inserting data into table \"educator_teaching_styles\""
input educator_teaching_styles_insert_input {
    educator: users_obj_rel_insert_input
    educatorId: uuid
    style: teaching_styles_enum
    teachingStyle: teaching_styles_obj_rel_insert_input
}

"order by max() on columns of table \"educator_teaching_styles\""
input educator_teaching_styles_max_order_by {
    educatorId: order_by
}

"order by min() on columns of table \"educator_teaching_styles\""
input educator_teaching_styles_min_order_by {
    educatorId: order_by
}

"on conflict condition type for table \"educator_teaching_styles\""
input educator_teaching_styles_on_conflict {
    constraint: educator_teaching_styles_constraint!
    update_columns: [educator_teaching_styles_update_column!]! = []
    where: educator_teaching_styles_bool_exp
}

"Ordering options when selecting data from \"educator_teaching_styles\"."
input educator_teaching_styles_order_by {
    educator: users_order_by
    educatorId: order_by
    style: order_by
    teachingStyle: teaching_styles_order_by
}

"primary key columns input for table: educator_teaching_styles"
input educator_teaching_styles_pk_columns_input {
    educatorId: uuid!
    style: teaching_styles_enum!
}

"input type for updating data in table \"educator_teaching_styles\""
input educator_teaching_styles_set_input {
    educatorId: uuid
    style: teaching_styles_enum
}

"order by aggregate values of table \"educator_testimonials\""
input educator_testimonials_aggregate_order_by {
    avg: educator_testimonials_avg_order_by
    count: order_by
    max: educator_testimonials_max_order_by
    min: educator_testimonials_min_order_by
    stddev: educator_testimonials_stddev_order_by
    stddev_pop: educator_testimonials_stddev_pop_order_by
    stddev_samp: educator_testimonials_stddev_samp_order_by
    sum: educator_testimonials_sum_order_by
    var_pop: educator_testimonials_var_pop_order_by
    var_samp: educator_testimonials_var_samp_order_by
    variance: educator_testimonials_variance_order_by
}

"input type for inserting array relation for remote table \"educator_testimonials\""
input educator_testimonials_arr_rel_insert_input {
    data: [educator_testimonials_insert_input!]!
    "on conflict condition"
    on_conflict: educator_testimonials_on_conflict
}

"order by avg() on columns of table \"educator_testimonials\""
input educator_testimonials_avg_order_by {
    order: order_by
}

"Boolean expression to filter rows from the table \"educator_testimonials\". All fields are combined with a logical 'AND'."
input educator_testimonials_bool_exp {
    _and: [educator_testimonials_bool_exp!]
    _not: educator_testimonials_bool_exp
    _or: [educator_testimonials_bool_exp!]
    content: String_comparison_exp
    educatorId: uuid_comparison_exp
    id: uuid_comparison_exp
    order: numeric_comparison_exp
    subTitle: String_comparison_exp
    title: String_comparison_exp
}

"input type for incrementing numeric columns in table \"educator_testimonials\""
input educator_testimonials_inc_input {
    order: numeric
}

"input type for inserting data into table \"educator_testimonials\""
input educator_testimonials_insert_input {
    content: String
    educatorId: uuid
    id: uuid
    order: numeric
    subTitle: String
    title: String
}

"order by max() on columns of table \"educator_testimonials\""
input educator_testimonials_max_order_by {
    content: order_by
    educatorId: order_by
    id: order_by
    order: order_by
    subTitle: order_by
    title: order_by
}

"order by min() on columns of table \"educator_testimonials\""
input educator_testimonials_min_order_by {
    content: order_by
    educatorId: order_by
    id: order_by
    order: order_by
    subTitle: order_by
    title: order_by
}

"on conflict condition type for table \"educator_testimonials\""
input educator_testimonials_on_conflict {
    constraint: educator_testimonials_constraint!
    update_columns: [educator_testimonials_update_column!]! = []
    where: educator_testimonials_bool_exp
}

"Ordering options when selecting data from \"educator_testimonials\"."
input educator_testimonials_order_by {
    content: order_by
    educatorId: order_by
    id: order_by
    order: order_by
    subTitle: order_by
    title: order_by
}

"primary key columns input for table: educator_testimonials"
input educator_testimonials_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"educator_testimonials\""
input educator_testimonials_set_input {
    content: String
    educatorId: uuid
    id: uuid
    order: numeric
    subTitle: String
    title: String
}

"order by stddev() on columns of table \"educator_testimonials\""
input educator_testimonials_stddev_order_by {
    order: order_by
}

"order by stddev_pop() on columns of table \"educator_testimonials\""
input educator_testimonials_stddev_pop_order_by {
    order: order_by
}

"order by stddev_samp() on columns of table \"educator_testimonials\""
input educator_testimonials_stddev_samp_order_by {
    order: order_by
}

"order by sum() on columns of table \"educator_testimonials\""
input educator_testimonials_sum_order_by {
    order: order_by
}

"order by var_pop() on columns of table \"educator_testimonials\""
input educator_testimonials_var_pop_order_by {
    order: order_by
}

"order by var_samp() on columns of table \"educator_testimonials\""
input educator_testimonials_var_samp_order_by {
    order: order_by
}

"order by variance() on columns of table \"educator_testimonials\""
input educator_testimonials_variance_order_by {
    order: order_by
}

"Boolean expression to filter rows from the table \"educator_topics\". All fields are combined with a logical 'AND'."
input educator_topics_bool_exp {
    _and: [educator_topics_bool_exp!]
    _not: educator_topics_bool_exp
    _or: [educator_topics_bool_exp!]
    id: uuid_comparison_exp
    mask_upload_id: uuid_comparison_exp
    name: String_comparison_exp
    order: Int_comparison_exp
    primary_color: String_comparison_exp
    secondary_color: String_comparison_exp
    slug: String_comparison_exp
}

"input type for incrementing numeric columns in table \"educator_topics\""
input educator_topics_inc_input {
    order: Int
}

"input type for inserting data into table \"educator_topics\""
input educator_topics_insert_input {
    id: uuid
    mask_upload_id: uuid
    name: String
    order: Int
    primary_color: String
    secondary_color: String
    slug: String
}

"Ordering options when selecting data from \"educator_topics\"."
input educator_topics_order_by {
    id: order_by
    mask_upload_id: order_by
    name: order_by
    order: order_by
    primary_color: order_by
    secondary_color: order_by
    slug: order_by
}

"input type for updating data in table \"educator_topics\""
input educator_topics_set_input {
    id: uuid
    mask_upload_id: uuid
    name: String
    order: Int
    primary_color: String
    secondary_color: String
    slug: String
}

"Boolean expression to filter rows from the table \"educators\". All fields are combined with a logical 'AND'."
input educators_bool_exp {
    _and: [educators_bool_exp!]
    _not: educators_bool_exp
    _or: [educators_bool_exp!]
    avatar: uploads_bool_exp
    avatarId: uuid_comparison_exp
    books: educator_books_bool_exp
    courses: courses_bool_exp
    created_at: timestamptz_comparison_exp
    educations: educator_educations_bool_exp
    email: citext_comparison_exp
    firstName: String_comparison_exp
    fullName: citext_comparison_exp
    has_confirmed: Boolean_comparison_exp
    id: uuid_comparison_exp
    is_mailchimp_registered: Boolean_comparison_exp
    lastName: String_comparison_exp
    profile: educator_profiles_bool_exp
    publications: educator_publications_bool_exp
    role: String_comparison_exp
    slug: String_comparison_exp
    teachingStyles: educator_teaching_styles_bool_exp
    testimonials: educator_testimonials_bool_exp
    updated_at: timestamptz_comparison_exp
}

"input type for inserting data into table \"educators\""
input educators_insert_input {
    avatar: uploads_obj_rel_insert_input
    avatarId: uuid
    books: educator_books_arr_rel_insert_input
    courses: courses_arr_rel_insert_input
    created_at: timestamptz
    educations: educator_educations_arr_rel_insert_input
    email: citext
    firstName: String
    fullName: citext
    has_confirmed: Boolean
    id: uuid
    is_mailchimp_registered: Boolean
    lastName: String
    profile: educator_profiles_obj_rel_insert_input
    publications: educator_publications_arr_rel_insert_input
    role: String
    slug: String
    teachingStyles: educator_teaching_styles_arr_rel_insert_input
    testimonials: educator_testimonials_arr_rel_insert_input
    updated_at: timestamptz
}

"input type for inserting object relation for remote table \"educators\""
input educators_obj_rel_insert_input {
    data: educators_insert_input!
}

"Ordering options when selecting data from \"educators\"."
input educators_order_by {
    avatar: uploads_order_by
    avatarId: order_by
    books_aggregate: educator_books_aggregate_order_by
    courses_aggregate: courses_aggregate_order_by
    created_at: order_by
    educations_aggregate: educator_educations_aggregate_order_by
    email: order_by
    firstName: order_by
    fullName: order_by
    has_confirmed: order_by
    id: order_by
    is_mailchimp_registered: order_by
    lastName: order_by
    profile: educator_profiles_order_by
    publications_aggregate: educator_publications_aggregate_order_by
    role: order_by
    slug: order_by
    teachingStyles_aggregate: educator_teaching_styles_aggregate_order_by
    testimonials_aggregate: educator_testimonials_aggregate_order_by
    updated_at: order_by
}

"input type for updating data in table \"educators\""
input educators_set_input {
    avatarId: uuid
    created_at: timestamptz
    email: citext
    firstName: String
    fullName: citext
    has_confirmed: Boolean
    id: uuid
    is_mailchimp_registered: Boolean
    lastName: String
    role: String
    slug: String
    updated_at: timestamptz
}

"order by aggregate values of table \"enrollment_sessions\""
input enrollment_sessions_aggregate_order_by {
    count: order_by
    max: enrollment_sessions_max_order_by
    min: enrollment_sessions_min_order_by
}

"input type for inserting array relation for remote table \"enrollment_sessions\""
input enrollment_sessions_arr_rel_insert_input {
    data: [enrollment_sessions_insert_input!]!
    "on conflict condition"
    on_conflict: enrollment_sessions_on_conflict
}

"Boolean expression to filter rows from the table \"enrollment_sessions\". All fields are combined with a logical 'AND'."
input enrollment_sessions_bool_exp {
    _and: [enrollment_sessions_bool_exp!]
    _not: enrollment_sessions_bool_exp
    _or: [enrollment_sessions_bool_exp!]
    course: courses_bool_exp
    courseId: uuid_comparison_exp
    enrollment: enrollments_bool_exp
    enrollmentId: uuid_comparison_exp
    id: uuid_comparison_exp
    session: sessions_bool_exp
    sessionId: uuid_comparison_exp
    user: users_bool_exp
    userId: uuid_comparison_exp
}

"input type for inserting data into table \"enrollment_sessions\""
input enrollment_sessions_insert_input {
    course: courses_obj_rel_insert_input
    courseId: uuid
    enrollment: enrollments_obj_rel_insert_input
    enrollmentId: uuid
    id: uuid
    session: sessions_obj_rel_insert_input
    sessionId: uuid
    user: users_obj_rel_insert_input
    userId: uuid
}

"order by max() on columns of table \"enrollment_sessions\""
input enrollment_sessions_max_order_by {
    courseId: order_by
    enrollmentId: order_by
    id: order_by
    sessionId: order_by
    userId: order_by
}

"order by min() on columns of table \"enrollment_sessions\""
input enrollment_sessions_min_order_by {
    courseId: order_by
    enrollmentId: order_by
    id: order_by
    sessionId: order_by
    userId: order_by
}

"on conflict condition type for table \"enrollment_sessions\""
input enrollment_sessions_on_conflict {
    constraint: enrollment_sessions_constraint!
    update_columns: [enrollment_sessions_update_column!]! = []
    where: enrollment_sessions_bool_exp
}

"Ordering options when selecting data from \"enrollment_sessions\"."
input enrollment_sessions_order_by {
    course: courses_order_by
    courseId: order_by
    enrollment: enrollments_order_by
    enrollmentId: order_by
    id: order_by
    session: sessions_order_by
    sessionId: order_by
    user: users_order_by
    userId: order_by
}

"primary key columns input for table: enrollment_sessions"
input enrollment_sessions_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"enrollment_sessions\""
input enrollment_sessions_set_input {
    courseId: uuid
    enrollmentId: uuid
    id: uuid
    sessionId: uuid
    userId: uuid
}

"order by aggregate values of table \"enrollments\""
input enrollments_aggregate_order_by {
    count: order_by
    max: enrollments_max_order_by
    min: enrollments_min_order_by
}

"input type for inserting array relation for remote table \"enrollments\""
input enrollments_arr_rel_insert_input {
    data: [enrollments_insert_input!]!
    "on conflict condition"
    on_conflict: enrollments_on_conflict
}

"Boolean expression to filter rows from the table \"enrollments\". All fields are combined with a logical 'AND'."
input enrollments_bool_exp {
    _and: [enrollments_bool_exp!]
    _not: enrollments_bool_exp
    _or: [enrollments_bool_exp!]
    course: courses_bool_exp
    courseId: uuid_comparison_exp
    createdAt: timestamptz_comparison_exp
    id: uuid_comparison_exp
    sessions: enrollment_sessions_bool_exp
    user: users_bool_exp
    userId: uuid_comparison_exp
    withSubscription: Boolean_comparison_exp
}

"input type for inserting data into table \"enrollments\""
input enrollments_insert_input {
    course: courses_obj_rel_insert_input
    courseId: uuid
    createdAt: timestamptz
    id: uuid
    sessions: enrollment_sessions_arr_rel_insert_input
    user: users_obj_rel_insert_input
    userId: uuid
    withSubscription: Boolean
}

"order by max() on columns of table \"enrollments\""
input enrollments_max_order_by {
    courseId: order_by
    createdAt: order_by
    id: order_by
    userId: order_by
}

"order by min() on columns of table \"enrollments\""
input enrollments_min_order_by {
    courseId: order_by
    createdAt: order_by
    id: order_by
    userId: order_by
}

"input type for inserting object relation for remote table \"enrollments\""
input enrollments_obj_rel_insert_input {
    data: enrollments_insert_input!
    "on conflict condition"
    on_conflict: enrollments_on_conflict
}

"on conflict condition type for table \"enrollments\""
input enrollments_on_conflict {
    constraint: enrollments_constraint!
    update_columns: [enrollments_update_column!]! = []
    where: enrollments_bool_exp
}

"Ordering options when selecting data from \"enrollments\"."
input enrollments_order_by {
    course: courses_order_by
    courseId: order_by
    createdAt: order_by
    id: order_by
    sessions_aggregate: enrollment_sessions_aggregate_order_by
    user: users_order_by
    userId: order_by
    withSubscription: order_by
}

"primary key columns input for table: enrollments"
input enrollments_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"enrollments\""
input enrollments_set_input {
    courseId: uuid
    createdAt: timestamptz
    id: uuid
    userId: uuid
    withSubscription: Boolean
}

"Boolean expression to compare columns of type \"json\". All fields are combined with logical 'AND'."
input json_comparison_exp {
    _eq: json
    _gt: json
    _gte: json
    _in: [json!]
    _is_null: Boolean
    _lt: json
    _lte: json
    _neq: json
    _nin: [json!]
}

"Boolean expression to filter rows from the table \"my_enrolled_sessions\". All fields are combined with a logical 'AND'."
input my_enrolled_sessions_bool_exp {
    _and: [my_enrolled_sessions_bool_exp!]
    _not: my_enrolled_sessions_bool_exp
    _or: [my_enrolled_sessions_bool_exp!]
    enrollment_id: uuid_comparison_exp
    session_id: uuid_comparison_exp
    user_id: uuid_comparison_exp
}

"Ordering options when selecting data from \"my_enrolled_sessions\"."
input my_enrolled_sessions_order_by {
    enrollment_id: order_by
    session_id: order_by
    user_id: order_by
}

"Boolean expression to compare columns of type \"numeric\". All fields are combined with logical 'AND'."
input numeric_comparison_exp {
    _eq: numeric
    _gt: numeric
    _gte: numeric
    _in: [numeric!]
    _is_null: Boolean
    _lt: numeric
    _lte: numeric
    _neq: numeric
    _nin: [numeric!]
}

"Boolean expression to filter rows from the table \"orderable_entities\". All fields are combined with a logical 'AND'."
input orderable_entities_bool_exp {
    _and: [orderable_entities_bool_exp!]
    _not: orderable_entities_bool_exp
    _or: [orderable_entities_bool_exp!]
    description: String_comparison_exp
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"orderable_entities_enum\". All fields are combined with logical 'AND'."
input orderable_entities_enum_comparison_exp {
    _eq: orderable_entities_enum
    _in: [orderable_entities_enum!]
    _is_null: Boolean
    _neq: orderable_entities_enum
    _nin: [orderable_entities_enum!]
}

"input type for inserting data into table \"orderable_entities\""
input orderable_entities_insert_input {
    description: String
    value: String
}

"on conflict condition type for table \"orderable_entities\""
input orderable_entities_on_conflict {
    constraint: orderable_entities_constraint!
    update_columns: [orderable_entities_update_column!]! = []
    where: orderable_entities_bool_exp
}

"Ordering options when selecting data from \"orderable_entities\"."
input orderable_entities_order_by {
    description: order_by
    value: order_by
}

"primary key columns input for table: orderable_entities"
input orderable_entities_pk_columns_input {
    value: String!
}

"input type for updating data in table \"orderable_entities\""
input orderable_entities_set_input {
    description: String
    value: String
}

"Boolean expression to filter rows from the table \"orders\". All fields are combined with a logical 'AND'."
input orders_bool_exp {
    _and: [orders_bool_exp!]
    _not: orders_bool_exp
    _or: [orders_bool_exp!]
    amount: numeric_comparison_exp
    createdAt: timestamptz_comparison_exp
    enrollment: enrollments_bool_exp
    enrollmentId: uuid_comparison_exp
    id: uuid_comparison_exp
    lastKnownEvent: String_comparison_exp
    promoCode: promo_codes_bool_exp
    promoId: String_comparison_exp
    stripeInvoiceId: String_comparison_exp
    stripeUrl: String_comparison_exp
    user: users_bool_exp
    userId: uuid_comparison_exp
    withSubscription: Boolean_comparison_exp
}

"input type for incrementing numeric columns in table \"orders\""
input orders_inc_input {
    amount: numeric
}

"input type for inserting data into table \"orders\""
input orders_insert_input {
    amount: numeric
    createdAt: timestamptz
    enrollment: enrollments_obj_rel_insert_input
    enrollmentId: uuid
    id: uuid
    lastKnownEvent: String
    promoCode: promo_codes_obj_rel_insert_input
    promoId: String
    stripeInvoiceId: String
    stripeUrl: String
    user: users_obj_rel_insert_input
    userId: uuid
    withSubscription: Boolean
}

"on conflict condition type for table \"orders\""
input orders_on_conflict {
    constraint: orders_constraint!
    update_columns: [orders_update_column!]! = []
    where: orders_bool_exp
}

"Ordering options when selecting data from \"orders\"."
input orders_order_by {
    amount: order_by
    createdAt: order_by
    enrollment: enrollments_order_by
    enrollmentId: order_by
    id: order_by
    lastKnownEvent: order_by
    promoCode: promo_codes_order_by
    promoId: order_by
    stripeInvoiceId: order_by
    stripeUrl: order_by
    user: users_order_by
    userId: order_by
    withSubscription: order_by
}

"primary key columns input for table: orders"
input orders_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"orders\""
input orders_set_input {
    amount: numeric
    createdAt: timestamptz
    enrollmentId: uuid
    id: uuid
    lastKnownEvent: String
    promoId: String
    stripeInvoiceId: String
    stripeUrl: String
    userId: uuid
    withSubscription: Boolean
}

"Boolean expression to filter rows from the table \"organization\". All fields are combined with a logical 'AND'."
input organization_bool_exp {
    _and: [organization_bool_exp!]
    _not: organization_bool_exp
    _or: [organization_bool_exp!]
    id: uuid_comparison_exp
    name: String_comparison_exp
}

"input type for inserting data into table \"organization\""
input organization_insert_input {
    id: uuid
    name: String
}

"on conflict condition type for table \"organization\""
input organization_on_conflict {
    constraint: organization_constraint!
    update_columns: [organization_update_column!]! = []
    where: organization_bool_exp
}

"Ordering options when selecting data from \"organization\"."
input organization_order_by {
    id: order_by
    name: order_by
}

"primary key columns input for table: organization"
input organization_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"organization\""
input organization_set_input {
    id: uuid
    name: String
}

input pastClasses_args {
    limit: Int
    offset: Int
}

"order by aggregate values of table \"product_prices\""
input product_prices_aggregate_order_by {
    avg: product_prices_avg_order_by
    count: order_by
    max: product_prices_max_order_by
    min: product_prices_min_order_by
    stddev: product_prices_stddev_order_by
    stddev_pop: product_prices_stddev_pop_order_by
    stddev_samp: product_prices_stddev_samp_order_by
    sum: product_prices_sum_order_by
    var_pop: product_prices_var_pop_order_by
    var_samp: product_prices_var_samp_order_by
    variance: product_prices_variance_order_by
}

"input type for inserting array relation for remote table \"product_prices\""
input product_prices_arr_rel_insert_input {
    data: [product_prices_insert_input!]!
    "on conflict condition"
    on_conflict: product_prices_on_conflict
}

"order by avg() on columns of table \"product_prices\""
input product_prices_avg_order_by {
    amount: order_by
}

"Boolean expression to filter rows from the table \"product_prices\". All fields are combined with a logical 'AND'."
input product_prices_bool_exp {
    _and: [product_prices_bool_exp!]
    _not: product_prices_bool_exp
    _or: [product_prices_bool_exp!]
    active: Boolean_comparison_exp
    amount: Int_comparison_exp
    id: String_comparison_exp
    product: products_bool_exp
    productId: String_comparison_exp
    stripeObject: json_comparison_exp
}

"input type for incrementing numeric columns in table \"product_prices\""
input product_prices_inc_input {
    amount: Int
}

"input type for inserting data into table \"product_prices\""
input product_prices_insert_input {
    active: Boolean
    amount: Int
    id: String
    product: products_obj_rel_insert_input
    productId: String
    stripeObject: json
}

"order by max() on columns of table \"product_prices\""
input product_prices_max_order_by {
    amount: order_by
    id: order_by
    productId: order_by
}

"order by min() on columns of table \"product_prices\""
input product_prices_min_order_by {
    amount: order_by
    id: order_by
    productId: order_by
}

"input type for inserting object relation for remote table \"product_prices\""
input product_prices_obj_rel_insert_input {
    data: product_prices_insert_input!
    "on conflict condition"
    on_conflict: product_prices_on_conflict
}

"on conflict condition type for table \"product_prices\""
input product_prices_on_conflict {
    constraint: product_prices_constraint!
    update_columns: [product_prices_update_column!]! = []
    where: product_prices_bool_exp
}

"Ordering options when selecting data from \"product_prices\"."
input product_prices_order_by {
    active: order_by
    amount: order_by
    id: order_by
    product: products_order_by
    productId: order_by
    stripeObject: order_by
}

"primary key columns input for table: product_prices"
input product_prices_pk_columns_input {
    id: String!
}

"input type for updating data in table \"product_prices\""
input product_prices_set_input {
    active: Boolean
    amount: Int
    id: String
    productId: String
    stripeObject: json
}

"order by stddev() on columns of table \"product_prices\""
input product_prices_stddev_order_by {
    amount: order_by
}

"order by stddev_pop() on columns of table \"product_prices\""
input product_prices_stddev_pop_order_by {
    amount: order_by
}

"order by stddev_samp() on columns of table \"product_prices\""
input product_prices_stddev_samp_order_by {
    amount: order_by
}

"order by sum() on columns of table \"product_prices\""
input product_prices_sum_order_by {
    amount: order_by
}

"order by var_pop() on columns of table \"product_prices\""
input product_prices_var_pop_order_by {
    amount: order_by
}

"order by var_samp() on columns of table \"product_prices\""
input product_prices_var_samp_order_by {
    amount: order_by
}

"order by variance() on columns of table \"product_prices\""
input product_prices_variance_order_by {
    amount: order_by
}

"Boolean expression to filter rows from the table \"products\". All fields are combined with a logical 'AND'."
input products_bool_exp {
    _and: [products_bool_exp!]
    _not: products_bool_exp
    _or: [products_bool_exp!]
    id: String_comparison_exp
    name: String_comparison_exp
    prices: product_prices_bool_exp
    stripeObject: json_comparison_exp
}

"input type for inserting data into table \"products\""
input products_insert_input {
    id: String
    name: String
    prices: product_prices_arr_rel_insert_input
    stripeObject: json
}

"input type for inserting object relation for remote table \"products\""
input products_obj_rel_insert_input {
    data: products_insert_input!
    "on conflict condition"
    on_conflict: products_on_conflict
}

"on conflict condition type for table \"products\""
input products_on_conflict {
    constraint: products_constraint!
    update_columns: [products_update_column!]! = []
    where: products_bool_exp
}

"Ordering options when selecting data from \"products\"."
input products_order_by {
    id: order_by
    name: order_by
    prices_aggregate: product_prices_aggregate_order_by
    stripeObject: order_by
}

"primary key columns input for table: products"
input products_pk_columns_input {
    id: String!
}

"input type for updating data in table \"products\""
input products_set_input {
    id: String
    name: String
    stripeObject: json
}

"Boolean expression to filter rows from the table \"promo_codes\". All fields are combined with a logical 'AND'."
input promo_codes_bool_exp {
    _and: [promo_codes_bool_exp!]
    _not: promo_codes_bool_exp
    _or: [promo_codes_bool_exp!]
    active: Boolean_comparison_exp
    code: String_comparison_exp
    coupon: coupons_bool_exp
    couponId: String_comparison_exp
    id: String_comparison_exp
    stripeObject: json_comparison_exp
}

"input type for inserting data into table \"promo_codes\""
input promo_codes_insert_input {
    active: Boolean
    code: String
    coupon: coupons_obj_rel_insert_input
    couponId: String
    id: String
    stripeObject: json
}

"input type for inserting object relation for remote table \"promo_codes\""
input promo_codes_obj_rel_insert_input {
    data: promo_codes_insert_input!
    "on conflict condition"
    on_conflict: promo_codes_on_conflict
}

"on conflict condition type for table \"promo_codes\""
input promo_codes_on_conflict {
    constraint: promo_codes_constraint!
    update_columns: [promo_codes_update_column!]! = []
    where: promo_codes_bool_exp
}

"Ordering options when selecting data from \"promo_codes\"."
input promo_codes_order_by {
    active: order_by
    code: order_by
    coupon: coupons_order_by
    couponId: order_by
    id: order_by
    stripeObject: order_by
}

"primary key columns input for table: promo_codes"
input promo_codes_pk_columns_input {
    id: String!
}

"input type for updating data in table \"promo_codes\""
input promo_codes_set_input {
    active: Boolean
    code: String
    couponId: String
    id: String
    stripeObject: json
}

"Boolean expression to filter rows from the table \"redirect_mappings\". All fields are combined with a logical 'AND'."
input redirect_mappings_bool_exp {
    _and: [redirect_mappings_bool_exp!]
    _not: redirect_mappings_bool_exp
    _or: [redirect_mappings_bool_exp!]
    code: Int_comparison_exp
    from_slug: String_comparison_exp
    kind: String_comparison_exp
    to_slug: String_comparison_exp
}

"input type for incrementing numeric columns in table \"redirect_mappings\""
input redirect_mappings_inc_input {
    code: Int
}

"input type for inserting data into table \"redirect_mappings\""
input redirect_mappings_insert_input {
    code: Int
    from_slug: String
    kind: String
    to_slug: String
}

"on conflict condition type for table \"redirect_mappings\""
input redirect_mappings_on_conflict {
    constraint: redirect_mappings_constraint!
    update_columns: [redirect_mappings_update_column!]! = []
    where: redirect_mappings_bool_exp
}

"Ordering options when selecting data from \"redirect_mappings\"."
input redirect_mappings_order_by {
    code: order_by
    from_slug: order_by
    kind: order_by
    to_slug: order_by
}

"primary key columns input for table: redirect_mappings"
input redirect_mappings_pk_columns_input {
    from_slug: String!
    kind: String!
    to_slug: String!
}

"input type for updating data in table \"redirect_mappings\""
input redirect_mappings_set_input {
    code: Int
    from_slug: String
    kind: String
    to_slug: String
}

"Boolean expression to filter rows from the table \"resource_types\". All fields are combined with a logical 'AND'."
input resource_types_bool_exp {
    _and: [resource_types_bool_exp!]
    _not: resource_types_bool_exp
    _or: [resource_types_bool_exp!]
    description: String_comparison_exp
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"resource_types_enum\". All fields are combined with logical 'AND'."
input resource_types_enum_comparison_exp {
    _eq: resource_types_enum
    _in: [resource_types_enum!]
    _is_null: Boolean
    _neq: resource_types_enum
    _nin: [resource_types_enum!]
}

"input type for inserting data into table \"resource_types\""
input resource_types_insert_input {
    description: String
    value: String
}

"on conflict condition type for table \"resource_types\""
input resource_types_on_conflict {
    constraint: resource_types_constraint!
    update_columns: [resource_types_update_column!]! = []
    where: resource_types_bool_exp
}

"Ordering options when selecting data from \"resource_types\"."
input resource_types_order_by {
    description: order_by
    value: order_by
}

"primary key columns input for table: resource_types"
input resource_types_pk_columns_input {
    value: String!
}

"input type for updating data in table \"resource_types\""
input resource_types_set_input {
    description: String
    value: String
}

"order by aggregate values of table \"sessions\""
input sessions_aggregate_order_by {
    count: order_by
    max: sessions_max_order_by
    min: sessions_min_order_by
}

"input type for inserting array relation for remote table \"sessions\""
input sessions_arr_rel_insert_input {
    data: [sessions_insert_input!]!
    "on conflict condition"
    on_conflict: sessions_on_conflict
}

"Boolean expression to filter rows from the table \"sessions\". All fields are combined with a logical 'AND'."
input sessions_bool_exp {
    _and: [sessions_bool_exp!]
    _not: sessions_bool_exp
    _or: [sessions_bool_exp!]
    cancelled: Boolean_comparison_exp
    course: courses_bool_exp
    courseId: uuid_comparison_exp
    createdAt: timestamptz_comparison_exp
    endTime: timestamptz_comparison_exp
    id: uuid_comparison_exp
    mailchimpCampaignId: String_comparison_exp
    meetingLink: String_comparison_exp
    protectedMeetingLink: String_comparison_exp
    protectedRecordingLink: String_comparison_exp
    recordingLink: String_comparison_exp
    startTime: timestamptz_comparison_exp
    title: String_comparison_exp
    updatedAt: timestamptz_comparison_exp
}

"input type for inserting data into table \"sessions\""
input sessions_insert_input {
    cancelled: Boolean
    course: courses_obj_rel_insert_input
    courseId: uuid
    createdAt: timestamptz
    endTime: timestamptz
    id: uuid
    mailchimpCampaignId: String
    protectedMeetingLink: String
    protectedRecordingLink: String
    startTime: timestamptz
    title: String
    updatedAt: timestamptz
}

"order by max() on columns of table \"sessions\""
input sessions_max_order_by {
    courseId: order_by
    createdAt: order_by
    endTime: order_by
    id: order_by
    mailchimpCampaignId: order_by
    protectedMeetingLink: order_by
    protectedRecordingLink: order_by
    startTime: order_by
    title: order_by
    updatedAt: order_by
}

"order by min() on columns of table \"sessions\""
input sessions_min_order_by {
    courseId: order_by
    createdAt: order_by
    endTime: order_by
    id: order_by
    mailchimpCampaignId: order_by
    protectedMeetingLink: order_by
    protectedRecordingLink: order_by
    startTime: order_by
    title: order_by
    updatedAt: order_by
}

"input type for inserting object relation for remote table \"sessions\""
input sessions_obj_rel_insert_input {
    data: sessions_insert_input!
    "on conflict condition"
    on_conflict: sessions_on_conflict
}

"on conflict condition type for table \"sessions\""
input sessions_on_conflict {
    constraint: sessions_constraint!
    update_columns: [sessions_update_column!]! = []
    where: sessions_bool_exp
}

"Ordering options when selecting data from \"sessions\"."
input sessions_order_by {
    cancelled: order_by
    course: courses_order_by
    courseId: order_by
    createdAt: order_by
    endTime: order_by
    id: order_by
    mailchimpCampaignId: order_by
    meetingLink: order_by
    protectedMeetingLink: order_by
    protectedRecordingLink: order_by
    recordingLink: order_by
    startTime: order_by
    title: order_by
    updatedAt: order_by
}

"primary key columns input for table: sessions"
input sessions_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"sessions\""
input sessions_set_input {
    cancelled: Boolean
    courseId: uuid
    createdAt: timestamptz
    endTime: timestamptz
    id: uuid
    mailchimpCampaignId: String
    protectedMeetingLink: String
    protectedRecordingLink: String
    startTime: timestamptz
    title: String
    updatedAt: timestamptz
}

"Boolean expression to filter rows from the table \"stripe_customers\". All fields are combined with a logical 'AND'."
input stripe_customers_bool_exp {
    _and: [stripe_customers_bool_exp!]
    _not: stripe_customers_bool_exp
    _or: [stripe_customers_bool_exp!]
    customerId: String_comparison_exp
    subscription: subscriptions_bool_exp
    user: users_bool_exp
    userId: uuid_comparison_exp
}

"input type for inserting data into table \"stripe_customers\""
input stripe_customers_insert_input {
    customerId: String
    subscription: subscriptions_obj_rel_insert_input
    user: users_obj_rel_insert_input
    userId: uuid
}

"input type for inserting object relation for remote table \"stripe_customers\""
input stripe_customers_obj_rel_insert_input {
    data: stripe_customers_insert_input!
    "on conflict condition"
    on_conflict: stripe_customers_on_conflict
}

"on conflict condition type for table \"stripe_customers\""
input stripe_customers_on_conflict {
    constraint: stripe_customers_constraint!
    update_columns: [stripe_customers_update_column!]! = []
    where: stripe_customers_bool_exp
}

"Ordering options when selecting data from \"stripe_customers\"."
input stripe_customers_order_by {
    customerId: order_by
    subscription: subscriptions_order_by
    user: users_order_by
    userId: order_by
}

"primary key columns input for table: stripe_customers"
input stripe_customers_pk_columns_input {
    userId: uuid!
}

"input type for updating data in table \"stripe_customers\""
input stripe_customers_set_input {
    customerId: String
    userId: uuid
}

"Boolean expression to filter rows from the table \"subscription_status\". All fields are combined with a logical 'AND'."
input subscription_status_bool_exp {
    _and: [subscription_status_bool_exp!]
    _not: subscription_status_bool_exp
    _or: [subscription_status_bool_exp!]
    description: String_comparison_exp
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"subscription_status_enum\". All fields are combined with logical 'AND'."
input subscription_status_enum_comparison_exp {
    _eq: subscription_status_enum
    _in: [subscription_status_enum!]
    _is_null: Boolean
    _neq: subscription_status_enum
    _nin: [subscription_status_enum!]
}

"input type for inserting data into table \"subscription_status\""
input subscription_status_insert_input {
    description: String
    value: String
}

"on conflict condition type for table \"subscription_status\""
input subscription_status_on_conflict {
    constraint: subscription_status_constraint!
    update_columns: [subscription_status_update_column!]! = []
    where: subscription_status_bool_exp
}

"Ordering options when selecting data from \"subscription_status\"."
input subscription_status_order_by {
    description: order_by
    value: order_by
}

"primary key columns input for table: subscription_status"
input subscription_status_pk_columns_input {
    value: String!
}

"input type for updating data in table \"subscription_status\""
input subscription_status_set_input {
    description: String
    value: String
}

"Boolean expression to filter rows from the table \"subscriptions\". All fields are combined with a logical 'AND'."
input subscriptions_bool_exp {
    _and: [subscriptions_bool_exp!]
    _not: subscriptions_bool_exp
    _or: [subscriptions_bool_exp!]
    cancelAt: timestamptz_comparison_exp
    createdAt: timestamptz_comparison_exp
    id: uuid_comparison_exp
    price: product_prices_bool_exp
    productPriceId: String_comparison_exp
    status: subscription_status_enum_comparison_exp
    stripeObject: json_comparison_exp
    stripePendingInvoiceId: String_comparison_exp
    stripeSubscriptionId: String_comparison_exp
    stripeSubscriptionItemId: String_comparison_exp
    updatedAt: timestamptz_comparison_exp
    user: users_bool_exp
    userId: uuid_comparison_exp
}

"input type for inserting data into table \"subscriptions\""
input subscriptions_insert_input {
    cancelAt: timestamptz
    createdAt: timestamptz
    id: uuid
    price: product_prices_obj_rel_insert_input
    productPriceId: String
    status: subscription_status_enum
    stripeObject: json
    stripePendingInvoiceId: String
    stripeSubscriptionId: String
    stripeSubscriptionItemId: String
    updatedAt: timestamptz
    user: users_obj_rel_insert_input
    userId: uuid
}

"input type for inserting object relation for remote table \"subscriptions\""
input subscriptions_obj_rel_insert_input {
    data: subscriptions_insert_input!
    "on conflict condition"
    on_conflict: subscriptions_on_conflict
}

"on conflict condition type for table \"subscriptions\""
input subscriptions_on_conflict {
    constraint: subscriptions_constraint!
    update_columns: [subscriptions_update_column!]! = []
    where: subscriptions_bool_exp
}

"Ordering options when selecting data from \"subscriptions\"."
input subscriptions_order_by {
    cancelAt: order_by
    createdAt: order_by
    id: order_by
    price: product_prices_order_by
    productPriceId: order_by
    status: order_by
    stripeObject: order_by
    stripePendingInvoiceId: order_by
    stripeSubscriptionId: order_by
    stripeSubscriptionItemId: order_by
    updatedAt: order_by
    user: users_order_by
    userId: order_by
}

"primary key columns input for table: subscriptions"
input subscriptions_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"subscriptions\""
input subscriptions_set_input {
    cancelAt: timestamptz
    createdAt: timestamptz
    id: uuid
    productPriceId: String
    status: subscription_status_enum
    stripeObject: json
    stripePendingInvoiceId: String
    stripeSubscriptionId: String
    stripeSubscriptionItemId: String
    updatedAt: timestamptz
    userId: uuid
}

"Boolean expression to filter rows from the table \"teaching_styles\". All fields are combined with a logical 'AND'."
input teaching_styles_bool_exp {
    _and: [teaching_styles_bool_exp!]
    _not: teaching_styles_bool_exp
    _or: [teaching_styles_bool_exp!]
    description: String_comparison_exp
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"teaching_styles_enum\". All fields are combined with logical 'AND'."
input teaching_styles_enum_comparison_exp {
    _eq: teaching_styles_enum
    _in: [teaching_styles_enum!]
    _is_null: Boolean
    _neq: teaching_styles_enum
    _nin: [teaching_styles_enum!]
}

"input type for inserting data into table \"teaching_styles\""
input teaching_styles_insert_input {
    description: String
    value: String
}

"input type for inserting object relation for remote table \"teaching_styles\""
input teaching_styles_obj_rel_insert_input {
    data: teaching_styles_insert_input!
    "on conflict condition"
    on_conflict: teaching_styles_on_conflict
}

"on conflict condition type for table \"teaching_styles\""
input teaching_styles_on_conflict {
    constraint: teaching_styles_constraint!
    update_columns: [teaching_styles_update_column!]! = []
    where: teaching_styles_bool_exp
}

"Ordering options when selecting data from \"teaching_styles\"."
input teaching_styles_order_by {
    description: order_by
    value: order_by
}

"primary key columns input for table: teaching_styles"
input teaching_styles_pk_columns_input {
    value: String!
}

"input type for updating data in table \"teaching_styles\""
input teaching_styles_set_input {
    description: String
    value: String
}

"Boolean expression to compare columns of type \"timestamptz\". All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
    _eq: timestamptz
    _gt: timestamptz
    _gte: timestamptz
    _in: [timestamptz!]
    _is_null: Boolean
    _lt: timestamptz
    _lte: timestamptz
    _neq: timestamptz
    _nin: [timestamptz!]
}

"Boolean expression to compare columns of type \"timetz\". All fields are combined with logical 'AND'."
input timetz_comparison_exp {
    _eq: timetz
    _gt: timetz
    _gte: timetz
    _in: [timetz!]
    _is_null: Boolean
    _lt: timetz
    _lte: timetz
    _neq: timetz
    _nin: [timetz!]
}

"Boolean expression to filter rows from the table \"topics\". All fields are combined with a logical 'AND'."
input topics_bool_exp {
    _and: [topics_bool_exp!]
    _not: topics_bool_exp
    _or: [topics_bool_exp!]
    id: uuid_comparison_exp
    mask: uploads_bool_exp
    maskUploadId: uuid_comparison_exp
    name: String_comparison_exp
    order: Int_comparison_exp
    primaryColor: String_comparison_exp
    secondaryColor: String_comparison_exp
    shapeType: String_comparison_exp
    slug: String_comparison_exp
}

"input type for incrementing numeric columns in table \"topics\""
input topics_inc_input {
    order: Int
}

"input type for inserting data into table \"topics\""
input topics_insert_input {
    id: uuid
    mask: uploads_obj_rel_insert_input
    maskUploadId: uuid
    name: String
    order: Int
    primaryColor: String
    secondaryColor: String
    shapeType: String
    slug: String
}

"input type for inserting object relation for remote table \"topics\""
input topics_obj_rel_insert_input {
    data: topics_insert_input!
    "on conflict condition"
    on_conflict: topics_on_conflict
}

"on conflict condition type for table \"topics\""
input topics_on_conflict {
    constraint: topics_constraint!
    update_columns: [topics_update_column!]! = []
    where: topics_bool_exp
}

"Ordering options when selecting data from \"topics\"."
input topics_order_by {
    id: order_by
    mask: uploads_order_by
    maskUploadId: order_by
    name: order_by
    order: order_by
    primaryColor: order_by
    secondaryColor: order_by
    shapeType: order_by
    slug: order_by
}

"primary key columns input for table: topics"
input topics_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"topics\""
input topics_set_input {
    id: uuid
    maskUploadId: uuid
    name: String
    order: Int
    primaryColor: String
    secondaryColor: String
    shapeType: String
    slug: String
}

input upcomingClasses_args {
    limit: Int
    offset: Int
}

input update_entity_order_args {
    requests: _update_entity_order_request
}

"Boolean expression to filter rows from the table \"update_entity_order_request\". All fields are combined with a logical 'AND'."
input update_entity_order_request_bool_exp {
    _and: [update_entity_order_request_bool_exp!]
    _not: update_entity_order_request_bool_exp
    _or: [update_entity_order_request_bool_exp!]
    entityId: uuid_comparison_exp
    entityTable: orderable_entities_enum_comparison_exp
    order: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"update_entity_order_request\""
input update_entity_order_request_inc_input {
    order: Int
}

"input type for inserting data into table \"update_entity_order_request\""
input update_entity_order_request_insert_input {
    entityId: uuid
    entityTable: orderable_entities_enum
    order: Int
}

"on conflict condition type for table \"update_entity_order_request\""
input update_entity_order_request_on_conflict {
    constraint: update_entity_order_request_constraint!
    update_columns: [update_entity_order_request_update_column!]! = []
    where: update_entity_order_request_bool_exp
}

"Ordering options when selecting data from \"update_entity_order_request\"."
input update_entity_order_request_order_by {
    entityId: order_by
    entityTable: order_by
    order: order_by
}

"primary key columns input for table: update_entity_order_request"
input update_entity_order_request_pk_columns_input {
    entityId: uuid!
    order: Int!
}

"input type for updating data in table \"update_entity_order_request\""
input update_entity_order_request_set_input {
    entityId: uuid
    entityTable: orderable_entities_enum
    order: Int
}

"Boolean expression to filter rows from the table \"uploads\". All fields are combined with a logical 'AND'."
input uploads_bool_exp {
    _and: [uploads_bool_exp!]
    _not: uploads_bool_exp
    _or: [uploads_bool_exp!]
    bucket: String_comparison_exp
    createdAt: timestamptz_comparison_exp
    deletedAt: timestamptz_comparison_exp
    id: uuid_comparison_exp
    mediaType: String_comparison_exp
    name: String_comparison_exp
    size: Int_comparison_exp
    updatedAt: timestamptz_comparison_exp
    url: String_comparison_exp
}

"input type for incrementing numeric columns in table \"uploads\""
input uploads_inc_input {
    size: Int
}

"input type for inserting data into table \"uploads\""
input uploads_insert_input {
    bucket: String
    createdAt: timestamptz
    deletedAt: timestamptz
    id: uuid
    mediaType: String
    name: String
    size: Int
    updatedAt: timestamptz
}

"input type for inserting object relation for remote table \"uploads\""
input uploads_obj_rel_insert_input {
    data: uploads_insert_input!
    "on conflict condition"
    on_conflict: uploads_on_conflict
}

"on conflict condition type for table \"uploads\""
input uploads_on_conflict {
    constraint: uploads_constraint!
    update_columns: [uploads_update_column!]! = []
    where: uploads_bool_exp
}

"Ordering options when selecting data from \"uploads\"."
input uploads_order_by {
    bucket: order_by
    createdAt: order_by
    deletedAt: order_by
    id: order_by
    mediaType: order_by
    name: order_by
    size: order_by
    updatedAt: order_by
    url: order_by
}

"primary key columns input for table: uploads"
input uploads_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"uploads\""
input uploads_set_input {
    bucket: String
    createdAt: timestamptz
    deletedAt: timestamptz
    id: uuid
    mediaType: String
    name: String
    size: Int
    updatedAt: timestamptz
}

"Boolean expression to filter rows from the table \"user_class_preferences\". All fields are combined with a logical 'AND'."
input user_class_preferences_bool_exp {
    _and: [user_class_preferences_bool_exp!]
    _not: user_class_preferences_bool_exp
    _or: [user_class_preferences_bool_exp!]
    preference: class_tags_bool_exp
    preferenceValue: class_tags_enum_comparison_exp
    user: users_bool_exp
    userId: uuid_comparison_exp
}

"input type for inserting data into table \"user_class_preferences\""
input user_class_preferences_insert_input {
    preference: class_tags_obj_rel_insert_input
    preferenceValue: class_tags_enum
    user: users_obj_rel_insert_input
    userId: uuid
}

"on conflict condition type for table \"user_class_preferences\""
input user_class_preferences_on_conflict {
    constraint: user_class_preferences_constraint!
    update_columns: [user_class_preferences_update_column!]! = []
    where: user_class_preferences_bool_exp
}

"Ordering options when selecting data from \"user_class_preferences\"."
input user_class_preferences_order_by {
    preference: class_tags_order_by
    preferenceValue: order_by
    user: users_order_by
    userId: order_by
}

"primary key columns input for table: user_class_preferences"
input user_class_preferences_pk_columns_input {
    preferenceValue: class_tags_enum!
    userId: uuid!
}

"input type for updating data in table \"user_class_preferences\""
input user_class_preferences_set_input {
    preferenceValue: class_tags_enum
    userId: uuid
}

"Boolean expression to filter rows from the table \"user_details\". All fields are combined with a logical 'AND'."
input user_details_bool_exp {
    _and: [user_details_bool_exp!]
    _not: user_details_bool_exp
    _or: [user_details_bool_exp!]
    avatarId: uuid_comparison_exp
    createdAt: timestamptz_comparison_exp
    email: citext_comparison_exp
    firstName: String_comparison_exp
    fullName: citext_comparison_exp
    hasConfirmed: Boolean_comparison_exp
    id: uuid_comparison_exp
    lastName: String_comparison_exp
    role: String_comparison_exp
    subscription: subscriptions_bool_exp
    updatedAt: timestamptz_comparison_exp
}

"input type for inserting data into table \"user_details\""
input user_details_insert_input {
    avatarId: uuid
    createdAt: timestamptz
    email: citext
    firstName: String
    fullName: citext
    hasConfirmed: Boolean
    id: uuid
    lastName: String
    role: String
    subscription: subscriptions_obj_rel_insert_input
    updatedAt: timestamptz
}

"Ordering options when selecting data from \"user_details\"."
input user_details_order_by {
    avatarId: order_by
    createdAt: order_by
    email: order_by
    firstName: order_by
    fullName: order_by
    hasConfirmed: order_by
    id: order_by
    lastName: order_by
    role: order_by
    subscription: subscriptions_order_by
    updatedAt: order_by
}

"input type for updating data in table \"user_details\""
input user_details_set_input {
    avatarId: uuid
    createdAt: timestamptz
    email: citext
    firstName: String
    fullName: citext
    hasConfirmed: Boolean
    id: uuid
    lastName: String
    role: String
    updatedAt: timestamptz
}

"Boolean expression to filter rows from the table \"user_roles\". All fields are combined with a logical 'AND'."
input user_roles_bool_exp {
    _and: [user_roles_bool_exp!]
    _not: user_roles_bool_exp
    _or: [user_roles_bool_exp!]
    description: String_comparison_exp
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"user_roles_enum\". All fields are combined with logical 'AND'."
input user_roles_enum_comparison_exp {
    _eq: user_roles_enum
    _in: [user_roles_enum!]
    _is_null: Boolean
    _neq: user_roles_enum
    _nin: [user_roles_enum!]
}

"input type for inserting data into table \"user_roles\""
input user_roles_insert_input {
    description: String
    value: String
}

"on conflict condition type for table \"user_roles\""
input user_roles_on_conflict {
    constraint: user_roles_constraint!
    update_columns: [user_roles_update_column!]! = []
    where: user_roles_bool_exp
}

"Ordering options when selecting data from \"user_roles\"."
input user_roles_order_by {
    description: order_by
    value: order_by
}

"primary key columns input for table: user_roles"
input user_roles_pk_columns_input {
    value: String!
}

"input type for updating data in table \"user_roles\""
input user_roles_set_input {
    description: String
    value: String
}

"Boolean expression to filter rows from the table \"user_teaching_style_preferences\". All fields are combined with a logical 'AND'."
input user_teaching_style_preferences_bool_exp {
    _and: [user_teaching_style_preferences_bool_exp!]
    _not: user_teaching_style_preferences_bool_exp
    _or: [user_teaching_style_preferences_bool_exp!]
    preference: teaching_styles_bool_exp
    preferenceValue: teaching_styles_enum_comparison_exp
    user: users_bool_exp
    userId: uuid_comparison_exp
}

"input type for inserting data into table \"user_teaching_style_preferences\""
input user_teaching_style_preferences_insert_input {
    preference: teaching_styles_obj_rel_insert_input
    preferenceValue: teaching_styles_enum
    user: users_obj_rel_insert_input
    userId: uuid
}

"on conflict condition type for table \"user_teaching_style_preferences\""
input user_teaching_style_preferences_on_conflict {
    constraint: user_teaching_style_preferences_constraint!
    update_columns: [user_teaching_style_preferences_update_column!]! = []
    where: user_teaching_style_preferences_bool_exp
}

"Ordering options when selecting data from \"user_teaching_style_preferences\"."
input user_teaching_style_preferences_order_by {
    preference: teaching_styles_order_by
    preferenceValue: order_by
    user: users_order_by
    userId: order_by
}

"primary key columns input for table: user_teaching_style_preferences"
input user_teaching_style_preferences_pk_columns_input {
    preferenceValue: teaching_styles_enum!
    userId: uuid!
}

"input type for updating data in table \"user_teaching_style_preferences\""
input user_teaching_style_preferences_set_input {
    preferenceValue: teaching_styles_enum
    userId: uuid
}

"Boolean expression to filter rows from the table \"users\". All fields are combined with a logical 'AND'."
input users_bool_exp {
    _and: [users_bool_exp!]
    _not: users_bool_exp
    _or: [users_bool_exp!]
    avatar: uploads_bool_exp
    avatarId: uuid_comparison_exp
    books: educator_books_bool_exp
    courses: courses_bool_exp
    createdAt: timestamptz_comparison_exp
    educations: educator_educations_bool_exp
    email: citext_comparison_exp
    enrollments: enrollments_bool_exp
    firstName: String_comparison_exp
    fullName: citext_comparison_exp
    hasConfirmed: Boolean_comparison_exp
    id: uuid_comparison_exp
    isMailchimpRegistered: Boolean_comparison_exp
    lastName: String_comparison_exp
    profile: educator_profiles_bool_exp
    publications: educator_publications_bool_exp
    role: user_roles_enum_comparison_exp
    stripe: stripe_customers_bool_exp
    subscription: subscriptions_bool_exp
    teachingStyles: educator_teaching_styles_bool_exp
    testimonials: educator_testimonials_bool_exp
    updatedAt: timestamptz_comparison_exp
}

"input type for inserting data into table \"users\""
input users_insert_input {
    avatar: uploads_obj_rel_insert_input
    avatarId: uuid
    books: educator_books_arr_rel_insert_input
    courses: courses_arr_rel_insert_input
    createdAt: timestamptz
    educations: educator_educations_arr_rel_insert_input
    email: citext
    enrollments: enrollments_arr_rel_insert_input
    firstName: String
    fullName: citext
    hasConfirmed: Boolean
    id: uuid
    isMailchimpRegistered: Boolean
    lastName: String
    profile: educator_profiles_obj_rel_insert_input
    publications: educator_publications_arr_rel_insert_input
    role: user_roles_enum
    stripe: stripe_customers_obj_rel_insert_input
    subscription: subscriptions_obj_rel_insert_input
    teachingStyles: educator_teaching_styles_arr_rel_insert_input
    testimonials: educator_testimonials_arr_rel_insert_input
    updatedAt: timestamptz
}

"input type for inserting object relation for remote table \"users\""
input users_obj_rel_insert_input {
    data: users_insert_input!
    "on conflict condition"
    on_conflict: users_on_conflict
}

"on conflict condition type for table \"users\""
input users_on_conflict {
    constraint: users_constraint!
    update_columns: [users_update_column!]! = []
    where: users_bool_exp
}

"Ordering options when selecting data from \"users\"."
input users_order_by {
    avatar: uploads_order_by
    avatarId: order_by
    books_aggregate: educator_books_aggregate_order_by
    courses_aggregate: courses_aggregate_order_by
    createdAt: order_by
    educations_aggregate: educator_educations_aggregate_order_by
    email: order_by
    enrollments_aggregate: enrollments_aggregate_order_by
    firstName: order_by
    fullName: order_by
    hasConfirmed: order_by
    id: order_by
    isMailchimpRegistered: order_by
    lastName: order_by
    profile: educator_profiles_order_by
    publications_aggregate: educator_publications_aggregate_order_by
    role: order_by
    stripe: stripe_customers_order_by
    subscription: subscriptions_order_by
    teachingStyles_aggregate: educator_teaching_styles_aggregate_order_by
    testimonials_aggregate: educator_testimonials_aggregate_order_by
    updatedAt: order_by
}

"primary key columns input for table: users"
input users_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"users\""
input users_set_input {
    avatarId: uuid
    createdAt: timestamptz
    email: citext
    firstName: String
    fullName: citext
    hasConfirmed: Boolean
    id: uuid
    isMailchimpRegistered: Boolean
    lastName: String
    role: user_roles_enum
    updatedAt: timestamptz
}

"Boolean expression to compare columns of type \"uuid\". All fields are combined with logical 'AND'."
input uuid_comparison_exp {
    _eq: uuid
    _gt: uuid
    _gte: uuid
    _in: [uuid!]
    _is_null: Boolean
    _lt: uuid
    _lte: uuid
    _neq: uuid
    _nin: [uuid!]
}
